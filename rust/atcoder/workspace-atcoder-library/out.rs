extern crate lazy_static ; extern crate num_bigint ; extern crate num_traits ; use num_bigint :: BigInt ; use num_traits :: { one , zero , Num , NumAssignOps , NumOps , One , Pow , Zero , ToPrimitive } ; use proconio :: fastout ; use proconio :: input ; use proconio :: marker :: Chars ; use itertools :: { assert_equal , concat , Itertools } ; use lazy_static :: lazy_static ; use std :: cmp :: * ; use std :: collections :: { BinaryHeap , HashMap , HashSet , VecDeque } ; use std :: io :: * ; use std :: mem :: swap ; use std :: ops :: { BitAnd , Range , ShrAssign , Neg } ; use std :: str :: FromStr ; use std :: sync :: Mutex ; use superslice :: * ; use ascii :: AsciiChar ; use ac_library_rs :: * ; pub fn read < T : FromStr > () -> T { let stdin = stdin () ; let stdin = stdin . lock () ; let token : String = stdin . bytes () . map (| c | c . expect ("failed to read char") as char) . skip_while (| c | c . is_whitespace ()) . take_while (| c | ! c . is_whitespace ()) . collect () ; token . parse () . ok () . expect ("failed to parse token") } # [allow (unused_macros)] macro_rules ! chmin { ($ base : expr , $ ($ cmps : expr) ,+ $ (,) *) => { { let cmp_min = min ! ($ ($ cmps) ,+) ; if $ base > cmp_min { $ base = cmp_min ; true } else { false } } } ; } # [allow (unused_macros)] macro_rules ! chmax { ($ base : expr , $ ($ cmps : expr) ,+ $ (,) *) => { { let cmp_max = max ! ($ ($ cmps) ,+) ; if $ base < cmp_max { $ base = cmp_max ; true } else { false } } } ; } # [allow (unused_macros)] macro_rules ! min { ($ a : expr $ (,) *) => { { $ a } } ; ($ a : expr , $ b : expr $ (,) *) => { { std :: cmp :: min ($ a , $ b) } } ; ($ a : expr , $ ($ rest : expr) ,+ $ (,) *) => { { std :: cmp :: min ($ a , min ! ($ ($ rest) ,+)) } } ; } # [allow (unused_macros)] macro_rules ! max { ($ a : expr $ (,) *) => { { $ a } } ; ($ a : expr , $ b : expr $ (,) *) => { { std :: cmp :: max ($ a , $ b) } } ; ($ a : expr , $ ($ rest : expr) ,+ $ (,) *) => { { std :: cmp :: max ($ a , max ! ($ ($ rest) ,+)) } } ; } # [allow (dead_code)] fn modinv < T : Num + NumAssignOps + NumOps + Copy + PartialOrd + Neg > (a : T , m : T) -> T { let mut a = a ; let mut b = m ; let mut u : T = one () ; let mut v : T = zero () ; while b != zero () { let t = a / b ; a -= t * b ; swap (& mut a , & mut b) ; u -= t * v ; swap (& mut u , & mut v) ; } u %= m ; if u < zero () { u += m ; } return u ; } # [test] fn modinv_test () { assert_eq ! (1 , modinv (1 , 13)) ; assert_eq ! (2 , modinv (7 , 13)) ; assert_eq ! (3 , modinv (9 , 13)) ; assert_eq ! (4 , modinv (10 , 13)) ; assert_eq ! (5 , modinv (8 , 13)) ; } # [allow (dead_code)] fn modpow < T > (a : T , n : T , modulo : T) -> T where T : Num + NumAssignOps + NumOps + Copy + PartialOrd + BitAnd + PartialEq + ShrAssign , < T as BitAnd > :: Output : PartialEq + Num , { let mut res = one () ; let mut a = a ; let mut n = n ; while n > zero () { if (n & one ()) == one () { res = res * a % modulo ; } a = a * a % modulo ; n >>= one () ; } return res ; } # [test] fn modpow_test () { assert_eq ! (4 , modpow (2 , 2 , 13)) ; assert_eq ! (3 , modpow (2 , 4 , 13)) ; } mod comb { use super :: * ; lazy_static ! { static ref FAC : Mutex < Vec < usize >> = Mutex :: default () ; static ref FINV : Mutex < Vec < usize >> = Mutex :: default () ; static ref INV : Mutex < Vec < usize >> = Mutex :: default () ; static ref MODULO : Mutex < usize > = Mutex :: default () ; } # [allow (dead_code)] fn com_init_with (modulo : usize , maxn_conv : usize) { let mut fac = FAC . lock () . unwrap () ; let mut finv = FINV . lock () . unwrap () ; let mut inv = INV . lock () . unwrap () ; * fac = vec ! [0 ; maxn_conv] ; * finv = vec ! [0 ; maxn_conv] ; * inv = vec ! [0 ; maxn_conv] ; let mut g_modulo = MODULO . lock () . unwrap () ; * g_modulo = modulo ; fac [0] = 1 ; fac [1] = 1 ; finv [0] = 1 ; finv [1] = 1 ; inv [1] = 1 ; for i in 2 .. maxn_conv { fac [i] = fac [i - 1] * i % modulo ; inv [i] = modulo - inv [modulo % i] * (modulo / i) % modulo ; finv [i] = finv [i - 1] * inv [i] % modulo ; } } # [allow (dead_code)] pub fn com_init () { com_init_with (MOD , MAXN_CONV) ; } # [allow (dead_code)] pub fn com (n : usize , k : usize) -> usize { let fac = FAC . lock () . unwrap () ; let finv = FINV . lock () . unwrap () ; let m = * MODULO . lock () . unwrap () ; if n < k { return 0 ; } return fac [n] * (finv [k] * finv [n - k] % m) % m ; } # [test] fn com_test () { com_init_with (13 , 100) ; assert_eq ! (12 , com (12 , 1)) ; assert_eq ! (66 % 13 , com (12 , 2)) ; assert_eq ! (220 % 13 , com (12 , 3)) ; assert_eq ! (495 % 13 , com (12 , 4)) ; assert_eq ! (792 % 13 , com (12 , 5)) ; assert_eq ! (924 % 13 , com (12 , 6)) ; assert_eq ! (com (12 , 5) , com (12 , 7)) ; } } mod uf { # [allow (dead_code)] # [derive (Debug)] pub struct UnionFind { par : Vec < i64 > , rank : Vec < usize > , } impl UnionFind { # [allow (dead_code)] pub fn new (n : usize) -> UnionFind { let mut vec = vec ! [0 ; n] ; for i in 0 .. n { vec [i] = - 1 ; } UnionFind { par : vec , rank : vec ! [0 ; n] , } } # [allow (dead_code)] fn find (& mut self , x : usize) -> usize { if self . par [x] < 0 { x } else { let par = self . par [x] ; let res = self . find (par as usize) ; self . par [x] = res as i64 ; res } } # [allow (dead_code)] pub fn same (& mut self , a : usize , b : usize) -> bool { self . find (a) == self . find (b) } # [allow (dead_code)] pub fn unite (& mut self , a : usize , b : usize) { let apar = self . find (a) ; let bpar = self . find (b) ; if self . rank [apar] > self . rank [bpar] { self . par [apar] += self . par [bpar] ; self . par [bpar] = apar as i64 ; } else { self . par [bpar] += self . par [apar] ; self . par [apar] = bpar as i64 ; if self . rank [apar] == self . rank [bpar] { self . rank [bpar] += 1 ; } } } # [allow (dead_code)] pub fn size (& mut self , x : usize) -> usize { let parent = self . find (x) ; return (- self . par [parent]) as usize ; } } # [test] fn union_find_test () { let mut uf = UnionFind :: new (10) ; for i in 0 .. 10 { for j in 0 .. 10 { assert_eq ! (i == j , uf . same (i , j)) ; } } uf . unite (0 , 1) ; assert_eq ! (true , uf . same (0 , 1)) ; assert_eq ! (false , uf . same (0 , 9)) ; assert_eq ! (false , uf . same (1 , 9)) ; assert_eq ! (false , uf . same (2 , 9)) ; assert_eq ! (2 , uf . size (0)) ; assert_eq ! (2 , uf . size (1)) ; assert_eq ! (1 , uf . size (2)) ; assert_eq ! (1 , uf . size (8)) ; assert_eq ! (1 , uf . size (9)) ; uf . unite (8 , 9) ; assert_eq ! (true , uf . same (0 , 1)) ; assert_eq ! (true , uf . same (8 , 9)) ; assert_eq ! (false , uf . same (0 , 9)) ; assert_eq ! (false , uf . same (1 , 9)) ; assert_eq ! (false , uf . same (2 , 9)) ; assert_eq ! (2 , uf . size (0)) ; assert_eq ! (2 , uf . size (1)) ; assert_eq ! (2 , uf . size (8)) ; assert_eq ! (2 , uf . size (9)) ; assert_eq ! (1 , uf . size (2)) ; uf . unite (1 , 9) ; assert_eq ! (true , uf . same (0 , 1)) ; assert_eq ! (true , uf . same (8 , 9)) ; assert_eq ! (true , uf . same (0 , 8)) ; assert_eq ! (true , uf . same (0 , 9)) ; assert_eq ! (true , uf . same (1 , 8)) ; assert_eq ! (true , uf . same (1 , 9)) ; assert_eq ! (false , uf . same (2 , 9)) ; assert_eq ! (4 , uf . size (0)) ; assert_eq ! (4 , uf . size (1)) ; assert_eq ! (4 , uf . size (8)) ; assert_eq ! (4 , uf . size (9)) ; assert_eq ! (1 , uf . size (2)) ; } } mod seg_tree { # [derive (Debug)] pub struct SegTree < T : Clone > { n : usize , dat : Vec < Option < T > > , } impl < T : Clone + std :: fmt :: Debug > SegTree < T > { # [allow (dead_code)] pub fn new (size : usize) -> SegTree < T > { let mut size_pow2 = 1 ; while size_pow2 < size { size_pow2 *= 2 ; } let dat : Vec < Option < T > > = vec ! [None ; 2 * size_pow2 - 1] ; SegTree { n : size_pow2 , dat } } # [allow (dead_code)] pub fn update < F : Fn (& Option < T > , & Option < T >) -> Option < T > > (& mut self , k : usize , a : T , update : F ,) { let mut k = k ; k += self . n - 1 ; self . dat [k] = Some (a) ; while k > 0 { k = (k - 1) / 2 ; self . dat [k] = update (& self . dat [k * 2 + 1] , & self . dat [k * 2 + 2]) ; } } # [allow (dead_code)] fn query_inner < F : Fn (& Option < T > , & Option < T >) -> Option < T > > (& self , selection_query : & F , a : usize , b : usize , k : usize , l : usize , r : usize ,) -> Option < T > { if r <= a || b <= l { return None ; } return if a <= l && r <= b { self . dat [k] . clone () } else { let vl = self . query_inner (selection_query , a , b , k * 2 + 1 , l , (l + r) / 2) ; let vr = self . query_inner (selection_query , a , b , k * 2 + 2 , (l + r) / 2 , r) ; selection_query (& vl , & vr) } ; } # [allow (dead_code)] pub fn query < F : Fn (& Option < T > , & Option < T >) -> Option < T > > (& self , selection_query : & F , a : usize , b : usize ,) -> Option < T > { return self . query_inner (selection_query , a , b , 0 , 0 , self . n) ; } } # [test] fn test_segtree_rmq () { let mut t : SegTree < usize > = SegTree :: new (5) ; let cmp_f = | lhs : & Option < usize > , rhs : & Option < usize > | { if lhs . is_none () { return rhs . clone () ; } if rhs . is_none () { return lhs . clone () ; } return if lhs . unwrap () <= rhs . unwrap () { lhs . clone () } else { rhs . clone () } ; } ; t . update (0 , 1 , cmp_f) ; t . update (1 , 3 , cmp_f) ; t . update (2 , 2 , cmp_f) ; t . update (3 , 5 , cmp_f) ; t . update (4 , 1 , cmp_f) ; assert_eq ! (1 , t . query (& cmp_f , 0 , 1) . unwrap ()) ; assert_eq ! (3 , t . query (& cmp_f , 1 , 2) . unwrap ()) ; assert_eq ! (2 , t . query (& cmp_f , 2 , 3) . unwrap ()) ; assert_eq ! (5 , t . query (& cmp_f , 3 , 4) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 4 , 5) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 0 , 2) . unwrap ()) ; assert_eq ! (2 , t . query (& cmp_f , 1 , 3) . unwrap ()) ; assert_eq ! (2 , t . query (& cmp_f , 2 , 4) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 3 , 5) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 0 , 3) . unwrap ()) ; assert_eq ! (2 , t . query (& cmp_f , 1 , 4) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 2 , 5) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 0 , 4) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 1 , 5) . unwrap ()) ; assert_eq ! (1 , t . query (& cmp_f , 0 , 6) . unwrap ()) ; } } mod rolling_hash { use super :: * ; use ascii :: { AsciiStr , AsciiString } ; use num_traits :: AsPrimitive ; fn contains_with (base : u64 , a : & AsciiStr , b : & AsciiStr) -> bool { let (al , bl) = (a . len () , b . len ()) ; if al > bl { return false ; } let mut t : u64 = 1 ; for _ in 0 .. al { t = t . wrapping_mul (base) ; } let (mut ah , mut bh) : (u64 , u64) = (0 , 0) ; for i in 0 .. al { ah = ah . wrapping_mul (base) + a [i] . as_byte () as u64 ; } for i in 0 .. al { bh = bh . wrapping_mul (base) + b [i] . as_byte () as u64 ; } for i in 0 ..= bl - al { if ah == bh { return true ; } if i + al < bl { let mut add : i64 = b [i + al] . as_byte () . as_ () ; add -= ((b [i] . as_byte () as u64) . wrapping_mul (t)) as i64 ; bh = (bh . wrapping_mul (base) as i64) . wrapping_add (add) as u64 ; } } return false ; } # [allow (dead_code)] pub fn contains (a : & AsciiStr , b : & AsciiStr) -> bool { return contains_with (BASE_ROLLING_HASH , a , b) ; } # [test] fn contains_test () { const base : u64 = 1000_000_007 ; assert_eq ! (false , contains_with (base , & AsciiString :: from_str ("abc") . unwrap () , & AsciiString :: from_str ("a") . unwrap ())) ; assert_eq ! (true , contains_with (base , & AsciiString :: from_str ("abc") . unwrap () , & AsciiString :: from_str ("aaabca") . unwrap ())) ; assert_eq ! (true , contains_with (base , & AsciiString :: from_str ("aaaaaa") . unwrap () , & AsciiString :: from_str ("aaaaaa") . unwrap ())) ; assert_eq ! (false , contains_with (base , & AsciiString :: from_str ("abc") . unwrap () , & AsciiString :: from_str ("aacbaa") . unwrap ())) } fn overlap_last_and_head_with (base : u64 , a : & AsciiStr , b : & AsciiStr) -> usize { let (al , bl) = (a . len () , b . len ()) ; let mut ans = 0 ; let (mut ah , mut bh , mut t) : (u64 , u64 , u64) = (0 , 0 , 1) ; for i in 1 ..= min (al , bl) { ah = ah . wrapping_add ((a [al - i] . as_byte () as u64) . wrapping_mul (t)) ; bh = bh . wrapping_mul (base) . wrapping_add (b [i - 1] . as_byte () as u64) ; if ah == bh { ans = i ; } t = t . wrapping_mul (base) ; } return ans ; } fn overlap_last_and_head (a : & AsciiStr , b : & AsciiStr) -> usize { return overlap_last_and_head_with (BASE_ROLLING_HASH , a , b) ; } # [test] fn overlap_test () { const base : u64 = 1000_000_007 ; assert_eq ! (0 , overlap_last_and_head_with (base , & AsciiString :: from_str ("abc") . unwrap () , & AsciiString :: from_str ("a") . unwrap ())) ; assert_eq ! (2 , overlap_last_and_head_with (base , & AsciiString :: from_str ("abc") . unwrap () , & AsciiString :: from_str ("bca") . unwrap ())) ; assert_eq ! (5 , overlap_last_and_head_with (base , & AsciiString :: from_str ("hogefoobar") . unwrap () , & AsciiString :: from_str ("oobarhoge") . unwrap ())) ; } } # [allow (dead_code)] fn to_alphabet_num (a : AsciiChar) -> usize { (a . as_byte () - AsciiChar :: a . as_byte ()) as usize } # [allow (dead_code)] fn num_to_alphabet (a : usize) -> Option < AsciiChar > { let a = a . to_u8 () . map (| a | AsciiChar :: from_ascii (AsciiChar :: a . as_byte () + a as u8) . ok ()) ; return a . flatten () ; } # [allow (dead_code)] const BASE_ROLLING_HASH : u64 = 1158187049 ; # [allow (dead_code)] const MOD : usize = 1000000007 ; # [allow (dead_code)] const MAXN_CONV : usize = 510000 ; fn main () { input ! [n : usize] ; let conv = convolution_i64 ((0 .. 10) . map (| a | a) . collect_vec () . as_slice () , (10 .. 20) . map (| a | a) . collect_vec () . as_slice ()) ; println ! ("{:?}" , conv) ; }mod ac_library_rs { pub mod convolution { macro_rules ! modulus { ($ ($ name : ident) ,*) => { $ (# [derive (Copy , Clone , Eq , PartialEq)] enum $ name { } impl Modulus for $ name { const VALUE : u32 = $ name as _ ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> &'static :: std :: thread :: LocalKey <:: std :: cell :: RefCell <:: std :: option :: Option <$ crate :: modint :: ButterflyCache < Self >>>> { thread_local ! { static BUTTERFLY_CACHE : :: std :: cell :: RefCell <:: std :: option :: Option <$ crate :: modint :: ButterflyCache <$ name >>> = :: std :: default :: Default :: default () ; } & BUTTERFLY_CACHE } }) * } ; } use super :: { internal_bit , internal_math , modint :: { ButterflyCache , Modulus , RemEuclidU32 , StaticModInt } , } ; use std :: { cmp , convert :: { TryFrom , TryInto as _ } , fmt , } ; # [allow (clippy :: many_single_char_names)] pub fn convolution < M > (a : & [StaticModInt < M >] , b : & [StaticModInt < M >]) -> Vec < StaticModInt < M > > where M : Modulus , { if a . is_empty () || b . is_empty () { return vec ! [] ; } let (n , m) = (a . len () , b . len ()) ; if cmp :: min (n , m) <= 60 { let (n , m , a , b) = if n < m { (m , n , b , a) } else { (n , m , a , b) } ; let mut ans = vec ! [StaticModInt :: new (0) ; n + m - 1] ; for i in 0 .. n { for j in 0 .. m { ans [i + j] += a [i] * b [j] ; } } return ans ; } let (mut a , mut b) = (a . to_owned () , b . to_owned ()) ; let z = 1 << internal_bit :: ceil_pow2 ((n + m - 1) as _) ; a . resize (z , StaticModInt :: raw (0)) ; butterfly (& mut a) ; b . resize (z , StaticModInt :: raw (0)) ; butterfly (& mut b) ; for (a , b) in a . iter_mut () . zip (& b) { * a *= b ; } butterfly_inv (& mut a) ; a . resize (n + m - 1 , StaticModInt :: raw (0)) ; let iz = StaticModInt :: new (z) . inv () ; for a in & mut a { * a *= iz ; } a } pub fn convolution_raw < T , M > (a : & [T] , b : & [T]) -> Vec < T > where T : RemEuclidU32 + TryFrom < u32 > + Clone , T :: Error : fmt :: Debug , M : Modulus , { let a = a . iter () . cloned () . map (Into :: into) . collect :: < Vec < _ > > () ; let b = b . iter () . cloned () . map (Into :: into) . collect :: < Vec < _ > > () ; convolution :: < M > (& a , & b) . into_iter () . map (| z | { z . val () . try_into () . expect ("the numeric type is smaller than the modulus") }) . collect () } # [allow (clippy :: many_single_char_names)] pub fn convolution_i64 (a : & [i64] , b : & [i64]) -> Vec < i64 > { const M1 : u64 = 754_974_721 ; const M2 : u64 = 167_772_161 ; const M3 : u64 = 469_762_049 ; const M2M3 : u64 = M2 * M3 ; const M1M3 : u64 = M1 * M3 ; const M1M2 : u64 = M1 * M2 ; const M1M2M3 : u64 = M1M2 . wrapping_mul (M3) ; modulus ! (M1 , M2 , M3) ; if a . is_empty () || b . is_empty () { return vec ! [] ; } let (_ , i1) = internal_math :: inv_gcd (M2M3 as _ , M1 as _) ; let (_ , i2) = internal_math :: inv_gcd (M1M3 as _ , M2 as _) ; let (_ , i3) = internal_math :: inv_gcd (M1M2 as _ , M3 as _) ; let c1 = convolution_raw :: < i64 , M1 > (a , b) ; let c2 = convolution_raw :: < i64 , M2 > (a , b) ; let c3 = convolution_raw :: < i64 , M3 > (a , b) ; c1 . into_iter () . zip (c2) . zip (c3) . map (| ((c1 , c2) , c3) | { const OFFSET : & [u64] = & [0 , 0 , M1M2M3 , 2 * M1M2M3 , 3 * M1M2M3] ; let mut x = [(c1 , i1 , M1 , M2M3) , (c2 , i2 , M2 , M1M3) , (c3 , i3 , M3 , M1M2)] . iter () . map (| & (c , i , m1 , m2) | c . wrapping_mul (i) . rem_euclid (m1 as _) . wrapping_mul (m2 as _)) . fold (0 , i64 :: wrapping_add) ; let mut diff = c1 - internal_math :: safe_mod (x , M1 as _) ; if diff < 0 { diff += M1 as i64 ; } x = x . wrapping_sub (OFFSET [diff . rem_euclid (5) as usize] as _) ; x }) . collect () } # [allow (clippy :: many_single_char_names)] fn butterfly < M : Modulus > (a : & mut [StaticModInt < M >]) { let n = a . len () ; let h = internal_bit :: ceil_pow2 (n as u32) ; M :: butterfly_cache () . with (| cache | { let mut cache = cache . borrow_mut () ; let ButterflyCache { sum_e , .. } = cache . get_or_insert_with (prepare) ; for ph in 1 ..= h { let w = 1 << (ph - 1) ; let p = 1 << (h - ph) ; let mut now = StaticModInt :: < M > :: new (1) ; for s in 0 .. w { let offset = s << (h - ph + 1) ; for i in 0 .. p { let l = a [i + offset] ; let r = a [i + offset + p] * now ; a [i + offset] = l + r ; a [i + offset + p] = l - r ; } now *= sum_e [(! s) . trailing_zeros () as usize] ; } } }) ; } # [allow (clippy :: many_single_char_names)] fn butterfly_inv < M : Modulus > (a : & mut [StaticModInt < M >]) { let n = a . len () ; let h = internal_bit :: ceil_pow2 (n as u32) ; M :: butterfly_cache () . with (| cache | { let mut cache = cache . borrow_mut () ; let ButterflyCache { sum_ie , .. } = cache . get_or_insert_with (prepare) ; for ph in (1 ..= h) . rev () { let w = 1 << (ph - 1) ; let p = 1 << (h - ph) ; let mut inow = StaticModInt :: < M > :: new (1) ; for s in 0 .. w { let offset = s << (h - ph + 1) ; for i in 0 .. p { let l = a [i + offset] ; let r = a [i + offset + p] ; a [i + offset] = l + r ; a [i + offset + p] = StaticModInt :: new (M :: VALUE + l . val () - r . val ()) * inow ; } inow *= sum_ie [(! s) . trailing_zeros () as usize] ; } } }) ; } fn prepare < M : Modulus > () -> ButterflyCache < M > { let g = StaticModInt :: < M > :: raw (internal_math :: primitive_root (M :: VALUE as i32) as u32) ; let mut es = [StaticModInt :: < M > :: raw (0) ; 30] ; let mut ies = [StaticModInt :: < M > :: raw (0) ; 30] ; let cnt2 = (M :: VALUE - 1) . trailing_zeros () as usize ; let mut e = g . pow (((M :: VALUE - 1) >> cnt2) . into ()) ; let mut ie = e . inv () ; for i in (2 ..= cnt2) . rev () { es [i - 2] = e ; ies [i - 2] = ie ; e *= e ; ie *= ie ; } let sum_e = es . iter () . scan (StaticModInt :: new (1) , | acc , e | { * acc *= e ; Some (* acc) }) . collect () ; let sum_ie = ies . iter () . scan (StaticModInt :: new (1) , | acc , ie | { * acc *= ie ; Some (* acc) }) . collect () ; ButterflyCache { sum_e , sum_ie } } # [cfg (test)] mod tests { use super :: super :: { modint :: { Mod998244353 , Modulus , StaticModInt } , RemEuclidU32 , } ; use rand :: { rngs :: ThreadRng , Rng as _ } ; use std :: { convert :: { TryFrom , TryInto as _ } , fmt , } ; # [test] fn empty () { assert ! (super :: convolution_raw ::< i32 , Mod998244353 > (& [] , & []) . is_empty ()) ; assert ! (super :: convolution_raw ::< i32 , Mod998244353 > (& [] , & [1 , 2]) . is_empty ()) ; assert ! (super :: convolution_raw ::< i32 , Mod998244353 > (& [1 , 2] , & []) . is_empty ()) ; assert ! (super :: convolution_raw ::< i32 , Mod998244353 > (& [1] , & []) . is_empty ()) ; assert ! (super :: convolution_raw ::< i64 , Mod998244353 > (& [] , & []) . is_empty ()) ; assert ! (super :: convolution_raw ::< i64 , Mod998244353 > (& [] , & [1 , 2]) . is_empty ()) ; assert ! (super :: convolution ::< Mod998244353 > (& [] , & []) . is_empty ()) ; assert ! (super :: convolution ::< Mod998244353 > (& [] , & [1 . into () , 2 . into ()]) . is_empty ()) ; } # [test] fn mid () { const N : usize = 1234 ; const M : usize = 2345 ; let mut rng = rand :: thread_rng () ; let mut gen_values = | n | gen_values :: < Mod998244353 > (& mut rng , n) ; let (a , b) = (gen_values (N) , gen_values (M)) ; assert_eq ! (conv_naive (& a , & b) , super :: convolution (& a , & b)) ; } # [test] fn simple_s_mod () { const M1 : u32 = 998_244_353 ; const M2 : u32 = 924_844_033 ; modulus ! (M1 , M2) ; fn test < M : Modulus > (rng : & mut ThreadRng) { let mut gen_values = | n | gen_values :: < Mod998244353 > (rng , n) ; for (n , m) in (1 .. 20) . flat_map (| i | (1 .. 20) . map (move | j | (i , j))) { let (a , b) = (gen_values (n) , gen_values (m)) ; assert_eq ! (conv_naive (& a , & b) , super :: convolution (& a , & b)) ; } } let mut rng = rand :: thread_rng () ; test :: < M1 > (& mut rng) ; test :: < M2 > (& mut rng) ; } # [test] fn simple_int () { simple_raw :: < i32 > () ; } # [test] fn simple_uint () { simple_raw :: < u32 > () ; } # [test] fn simple_ll () { simple_raw :: < i64 > () ; } # [test] fn simple_ull () { simple_raw :: < u64 > () ; } # [test] fn simple_int128 () { simple_raw :: < i128 > () ; } # [test] fn simple_uint128 () { simple_raw :: < u128 > () ; } fn simple_raw < T > () where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , { const M1 : u32 = 998_244_353 ; const M2 : u32 = 924_844_033 ; modulus ! (M1 , M2) ; fn test < T , M > (rng : & mut ThreadRng) where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , M : Modulus , { let mut gen_raw_values = | n | gen_raw_values :: < u32 , Mod998244353 > (rng , n) ; for (n , m) in (1 .. 20) . flat_map (| i | (1 .. 20) . map (move | j | (i , j))) { let (a , b) = (gen_raw_values (n) , gen_raw_values (m)) ; assert_eq ! (conv_raw_naive ::< _ , M > (& a , & b) , super :: convolution_raw ::< _ , M > (& a , & b) ,) ; } } let mut rng = rand :: thread_rng () ; test :: < T , M1 > (& mut rng) ; test :: < T , M2 > (& mut rng) ; } # [test] fn conv_ll () { let mut rng = rand :: thread_rng () ; for (n , m) in (1 .. 20) . flat_map (| i | (1 .. 20) . map (move | j | (i , j))) { let mut gen = | n : usize | -> Vec < _ > { (0 .. n) . map (| _ | rng . gen_range (- 500_000 , 500_000)) . collect () } ; let (a , b) = (gen (n) , gen (m)) ; assert_eq ! (conv_i64_naive (& a , & b) , super :: convolution_i64 (& a , & b)) ; } } # [test] fn conv_ll_bound () { const M1 : u64 = 754_974_721 ; const M2 : u64 = 167_772_161 ; const M3 : u64 = 469_762_049 ; const M2M3 : u64 = M2 * M3 ; const M1M3 : u64 = M1 * M3 ; const M1M2 : u64 = M1 * M2 ; modulus ! (M1 , M2 , M3) ; for i in - 1000 ..= 1000 { let a = vec ! [0u64 . wrapping_sub (M1M2 + M1M3 + M2M3) as i64 + i] ; let b = vec ! [1] ; assert_eq ! (a , super :: convolution_i64 (& a , & b)) ; } for i in 0 .. 1000 { let a = vec ! [i64 :: min_value () + i] ; let b = vec ! [1] ; assert_eq ! (a , super :: convolution_i64 (& a , & b)) ; } for i in 0 .. 1000 { let a = vec ! [i64 :: max_value () - i] ; let b = vec ! [1] ; assert_eq ! (a , super :: convolution_i64 (& a , & b)) ; } } # [test] fn conv_641 () { const M : u32 = 641 ; modulus ! (M) ; let mut rng = rand :: thread_rng () ; let mut gen_values = | n | gen_values :: < M > (& mut rng , n) ; let (a , b) = (gen_values (64) , gen_values (65)) ; assert_eq ! (conv_naive (& a , & b) , super :: convolution (& a , & b)) ; } # [test] fn conv_18433 () { const M : u32 = 18433 ; modulus ! (M) ; let mut rng = rand :: thread_rng () ; let mut gen_values = | n | gen_values :: < M > (& mut rng , n) ; let (a , b) = (gen_values (1024) , gen_values (1025)) ; assert_eq ! (conv_naive (& a , & b) , super :: convolution (& a , & b)) ; } # [allow (clippy :: many_single_char_names)] fn conv_naive < M : Modulus > (a : & [StaticModInt < M >] , b : & [StaticModInt < M >] ,) -> Vec < StaticModInt < M > > { let (n , m) = (a . len () , b . len ()) ; let mut c = vec ! [StaticModInt :: raw (0) ; n + m - 1] ; for (i , j) in (0 .. n) . flat_map (| i | (0 .. m) . map (move | j | (i , j))) { c [i + j] += a [i] * b [j] ; } c } fn conv_raw_naive < T , M > (a : & [T] , b : & [T]) -> Vec < T > where T : TryFrom < u32 > + Copy + RemEuclidU32 , T :: Error : fmt :: Debug , M : Modulus , { conv_naive :: < M > (& a . iter () . copied () . map (Into :: into) . collect :: < Vec < _ > > () , & b . iter () . copied () . map (Into :: into) . collect :: < Vec < _ > > () ,) . into_iter () . map (| x | x . val () . try_into () . unwrap ()) . collect () } # [allow (clippy :: many_single_char_names)] fn conv_i64_naive (a : & [i64] , b : & [i64]) -> Vec < i64 > { let (n , m) = (a . len () , b . len ()) ; let mut c = vec ! [0 ; n + m - 1] ; for (i , j) in (0 .. n) . flat_map (| i | (0 .. m) . map (move | j | (i , j))) { c [i + j] += a [i] * b [j] ; } c } fn gen_values < M : Modulus > (rng : & mut ThreadRng , n : usize) -> Vec < StaticModInt < M > > { (0 .. n) . map (| _ | rng . gen_range (0 , M :: VALUE) . into ()) . collect () } fn gen_raw_values < T , M > (rng : & mut ThreadRng , n : usize) -> Vec < T > where T : TryFrom < u32 > , T :: Error : fmt :: Debug , M : Modulus , { (0 .. n) . map (| _ | rng . gen_range (0 , M :: VALUE) . try_into () . unwrap ()) . collect () } } } pub mod dsu { # [doc = " Implement (union by size) + (path compression)"] # [doc = " Reference:"] # [doc = " Zvi Galil and Giuseppe F. Italiano,"] # [doc = " Data structures and algorithms for disjoint set union problems"] pub struct Dsu { n : usize , parent_or_size : Vec < i32 > , } impl Dsu { pub fn new (size : usize) -> Self { Self { n : size , parent_or_size : vec ! [- 1 ; size] , } } pub fn merge (& mut self , a : usize , b : usize) -> usize { assert ! (a < self . n) ; assert ! (b < self . n) ; let (mut x , mut y) = (self . leader (a) , self . leader (b)) ; if x == y { return x ; } if - self . parent_or_size [x] < - self . parent_or_size [y] { std :: mem :: swap (& mut x , & mut y) ; } self . parent_or_size [x] += self . parent_or_size [y] ; self . parent_or_size [y] = x as i32 ; x } pub fn same (& mut self , a : usize , b : usize) -> bool { assert ! (a < self . n) ; assert ! (b < self . n) ; self . leader (a) == self . leader (b) } pub fn leader (& mut self , a : usize) -> usize { assert ! (a < self . n) ; if self . parent_or_size [a] < 0 { return a ; } self . parent_or_size [a] = self . leader (self . parent_or_size [a] as usize) as i32 ; self . parent_or_size [a] as usize } pub fn size (& mut self , a : usize) -> usize { assert ! (a < self . n) ; let x = self . leader (a) ; - self . parent_or_size [x] as usize } pub fn groups (& mut self) -> Vec < Vec < usize > > { let mut leader_buf = vec ! [0 ; self . n] ; let mut group_size = vec ! [0 ; self . n] ; for i in 0 .. self . n { leader_buf [i] = self . leader (i) ; group_size [leader_buf [i]] += 1 ; } let mut result = vec ! [Vec :: new () ; self . n] ; for i in 0 .. self . n { result [i] . reserve (group_size [i]) ; } for i in 0 .. self . n { result [leader_buf [i]] . push (i) ; } result . into_iter () . filter (| x | ! x . is_empty ()) . collect :: < Vec < Vec < usize > > > () } } # [cfg (test)] mod tests { use super :: * ; # [test] fn dsu_works () { let mut d = Dsu :: new (4) ; d . merge (0 , 1) ; assert_eq ! (d . same (0 , 1) , true) ; d . merge (1 , 2) ; assert_eq ! (d . same (0 , 2) , true) ; assert_eq ! (d . size (0) , 3) ; assert_eq ! (d . same (0 , 3) , false) ; assert_eq ! (d . groups () , vec ! [vec ! [0 , 1 , 2] , vec ! [3]]) ; } } } pub mod fenwicktree { pub struct FenwickTree < T > { n : usize , ary : Vec < T > , e : T , } impl < T : Clone + std :: ops :: AddAssign < T > > FenwickTree < T > { pub fn new (n : usize , e : T) -> Self { FenwickTree { n , ary : vec ! [e . clone () ; n] , e , } } pub fn accum (& self , mut idx : usize) -> T { let mut sum = self . e . clone () ; while idx > 0 { sum += self . ary [idx - 1] . clone () ; idx &= idx - 1 ; } sum } # [doc = " performs data[idx] += val;"] pub fn add < U : Clone > (& mut self , mut idx : usize , val : U) where T : std :: ops :: AddAssign < U > , { let n = self . n ; idx += 1 ; while idx <= n { self . ary [idx - 1] += val . clone () ; idx += idx & idx . wrapping_neg () ; } } # [doc = " Returns data[l] + ... + data[r - 1]."] pub fn sum (& self , l : usize , r : usize) -> T where T : std :: ops :: Sub < Output = T > , { self . accum (r) - self . accum (l) } } # [cfg (test)] mod tests { use super :: * ; # [test] fn fenwick_tree_works () { let mut bit = FenwickTree :: new (5 , 0i64) ; for i in 0 .. 5 { bit . add (i , i as i64 + 1) ; } assert_eq ! (bit . sum (0 , 5) , 15) ; assert_eq ! (bit . sum (0 , 4) , 10) ; assert_eq ! (bit . sum (1 , 3) , 5) ; } } } pub mod lazysegtree { use super :: internal_bit :: ceil_pow2 ; use super :: Monoid ; pub trait MapMonoid { type M : Monoid ; type F : Clone ; fn identity_element () -> < Self :: M as Monoid > :: S { Self :: M :: identity () } fn binary_operation (a : & < Self :: M as Monoid > :: S , b : & < Self :: M as Monoid > :: S ,) -> < Self :: M as Monoid > :: S { Self :: M :: binary_operation (a , b) } fn identity_map () -> Self :: F ; fn mapping (f : & Self :: F , x : & < Self :: M as Monoid > :: S) -> < Self :: M as Monoid > :: S ; fn composition (f : & Self :: F , g : & Self :: F) -> Self :: F ; } impl < F : MapMonoid > Default for LazySegtree < F > { fn default () -> Self { Self :: new (0) } } impl < F : MapMonoid > LazySegtree < F > { pub fn new (n : usize) -> Self { vec ! [F :: identity_element () ; n] . into () } } impl < F : MapMonoid > From < Vec < < F :: M as Monoid > :: S > > for LazySegtree < F > { fn from (v : Vec < < F :: M as Monoid > :: S >) -> Self { let n = v . len () ; let log = ceil_pow2 (n as u32) as usize ; let size = 1 << log ; let mut d = vec ! [F :: identity_element () ; 2 * size] ; let lz = vec ! [F :: identity_map () ; size] ; d [size .. (size + n)] . clone_from_slice (& v) ; let mut ret = LazySegtree { n , size , log , d , lz , } ; for i in (1 .. size) . rev () { ret . update (i) ; } ret } } impl < F : MapMonoid > LazySegtree < F > { pub fn set (& mut self , mut p : usize , x : < F :: M as Monoid > :: S) { assert ! (p < self . n) ; p += self . size ; for i in (1 ..= self . log) . rev () { self . push (p >> i) ; } self . d [p] = x ; for i in 1 ..= self . log { self . update (p >> i) ; } } pub fn get (& mut self , mut p : usize) -> < F :: M as Monoid > :: S { assert ! (p < self . n) ; p += self . size ; for i in (1 ..= self . log) . rev () { self . push (p >> i) ; } self . d [p] . clone () } pub fn prod (& mut self , mut l : usize , mut r : usize) -> < F :: M as Monoid > :: S { assert ! (l <= r && r <= self . n) ; if l == r { return F :: identity_element () ; } l += self . size ; r += self . size ; for i in (1 ..= self . log) . rev () { if ((l >> i) << i) != l { self . push (l >> i) ; } if ((r >> i) << i) != r { self . push (r >> i) ; } } let mut sml = F :: identity_element () ; let mut smr = F :: identity_element () ; while l < r { if l & 1 != 0 { sml = F :: binary_operation (& sml , & self . d [l]) ; l += 1 ; } if r & 1 != 0 { r -= 1 ; smr = F :: binary_operation (& self . d [r] , & smr) ; } l >>= 1 ; r >>= 1 ; } F :: binary_operation (& sml , & smr) } pub fn all_prod (& self) -> < F :: M as Monoid > :: S { self . d [1] . clone () } pub fn apply (& mut self , mut p : usize , f : F :: F) { assert ! (p < self . n) ; p += self . size ; for i in (1 ..= self . log) . rev () { self . push (p >> i) ; } self . d [p] = F :: mapping (& f , & self . d [p]) ; for i in 1 ..= self . log { self . update (p >> i) ; } } pub fn apply_range (& mut self , mut l : usize , mut r : usize , f : F :: F) { assert ! (l <= r && r <= self . n) ; if l == r { return ; } l += self . size ; r += self . size ; for i in (1 ..= self . log) . rev () { if ((l >> i) << i) != l { self . push (l >> i) ; } if ((r >> i) << i) != r { self . push ((r - 1) >> i) ; } } { let l2 = l ; let r2 = r ; while l < r { if l & 1 != 0 { self . all_apply (l , f . clone ()) ; l += 1 ; } if r & 1 != 0 { r -= 1 ; self . all_apply (r , f . clone ()) ; } l >>= 1 ; r >>= 1 ; } l = l2 ; r = r2 ; } for i in 1 ..= self . log { if ((l >> i) << i) != l { self . update (l >> i) ; } if ((r >> i) << i) != r { self . update ((r - 1) >> i) ; } } } pub fn max_right < G > (& mut self , mut l : usize , g : G) -> usize where G : Fn (< F :: M as Monoid > :: S) -> bool , { assert ! (l <= self . n) ; assert ! (g (F :: identity_element ())) ; if l == self . n { return self . n ; } l += self . size ; for i in (1 ..= self . log) . rev () { self . push (l >> i) ; } let mut sm = F :: identity_element () ; while { while l % 2 == 0 { l >>= 1 ; } if ! g (F :: binary_operation (& sm , & self . d [l])) { while l < self . size { self . push (l) ; l *= 2 ; let res = F :: binary_operation (& sm , & self . d [l]) ; if g (res . clone ()) { sm = res ; l += 1 ; } } return l - self . size ; } sm = F :: binary_operation (& sm , & self . d [l]) ; l += 1 ; { let l = l as isize ; (l & - l) != l } } { } self . n } pub fn min_left < G > (& mut self , mut r : usize , g : G) -> usize where G : Fn (< F :: M as Monoid > :: S) -> bool , { assert ! (r <= self . n) ; assert ! (g (F :: identity_element ())) ; if r == 0 { return 0 ; } r += self . size ; for i in (1 ..= self . log) . rev () { self . push ((r - 1) >> i) ; } let mut sm = F :: identity_element () ; while { r -= 1 ; while r > 1 && r % 2 != 0 { r >>= 1 ; } if ! g (F :: binary_operation (& self . d [r] , & sm)) { while r < self . size { self . push (r) ; r = 2 * r + 1 ; let res = F :: binary_operation (& self . d [r] , & sm) ; if g (res . clone ()) { sm = res ; r -= 1 ; } } return r + 1 - self . size ; } sm = F :: binary_operation (& self . d [r] , & sm) ; { let r = r as isize ; (r & - r) != r } } { } 0 } } pub struct LazySegtree < F > where F : MapMonoid , { n : usize , size : usize , log : usize , d : Vec < < F :: M as Monoid > :: S > , lz : Vec < F :: F > , } impl < F > LazySegtree < F > where F : MapMonoid , { fn update (& mut self , k : usize) { self . d [k] = F :: binary_operation (& self . d [2 * k] , & self . d [2 * k + 1]) ; } fn all_apply (& mut self , k : usize , f : F :: F) { self . d [k] = F :: mapping (& f , & self . d [k]) ; if k < self . size { self . lz [k] = F :: composition (& f , & self . lz [k]) ; } } fn push (& mut self , k : usize) { self . all_apply (2 * k , self . lz [k] . clone ()) ; self . all_apply (2 * k + 1 , self . lz [k] . clone ()) ; self . lz [k] = F :: identity_map () ; } } use std :: fmt :: { Debug , Error , Formatter , Write } ; impl < F > Debug for LazySegtree < F > where F : MapMonoid , F :: F : Debug , < F :: M as Monoid > :: S : Debug , { fn fmt (& self , f : & mut Formatter < '_ >) -> Result < () , Error > { for i in 0 .. self . log { for j in 0 .. 1 << i { f . write_fmt (format_args ! ("{:?}[{:?}]\t" , self . d [(1 << i) + j] , self . lz [(1 << i) + j])) ? ; } f . write_char ('\n') ? ; } for i in 0 .. self . size { f . write_fmt (format_args ! ("{:?}\t" , self . d [self . size + i])) ? ; } Ok (()) } } # [cfg (test)] mod tests { use super :: super :: segtree :: Max ; use super :: { LazySegtree , MapMonoid } ; struct MaxAdd ; impl MapMonoid for MaxAdd { type M = Max < i32 > ; type F = i32 ; fn identity_map () -> Self :: F { 0 } fn mapping (& f : & i32 , & x : & i32) -> i32 { f + x } fn composition (& f : & i32 , & g : & i32) -> i32 { f + g } } # [test] fn test_max_add_lazy_segtree () { let base = vec ! [3 , 1 , 4 , 1 , 5 , 9 , 2 , 6 , 5 , 3] ; let n = base . len () ; let mut segtree : LazySegtree < MaxAdd > = base . clone () . into () ; check_segtree (& base , & mut segtree) ; let mut segtree = LazySegtree :: < MaxAdd > :: new (n) ; let mut internal = vec ! [i32 :: min_value () ; n] ; for i in 0 .. n { segtree . set (i , base [i]) ; internal [i] = base [i] ; check_segtree (& internal , & mut segtree) ; } segtree . set (6 , 5) ; internal [6] = 5 ; check_segtree (& internal , & mut segtree) ; segtree . apply (5 , 1) ; internal [5] += 1 ; check_segtree (& internal , & mut segtree) ; segtree . set (6 , 0) ; internal [6] = 0 ; check_segtree (& internal , & mut segtree) ; segtree . apply_range (3 , 8 , 2) ; internal [3 .. 8] . iter_mut () . for_each (| e | * e += 2) ; check_segtree (& internal , & mut segtree) ; } fn check_segtree (base : & [i32] , segtree : & mut LazySegtree < MaxAdd >) { let n = base . len () ; # [allow (clippy :: needless_range_loop)] for i in 0 .. n { assert_eq ! (segtree . get (i) , base [i]) ; } for i in 0 ..= n { for j in i ..= n { assert_eq ! (segtree . prod (i , j) , base [i .. j] . iter () . max () . copied () . unwrap_or (i32 :: min_value ())) ; } } assert_eq ! (segtree . all_prod () , base . iter () . max () . copied () . unwrap_or (i32 :: min_value ())) ; for k in 0 ..= 10 { let f = | x | x < k ; for i in 0 ..= n { assert_eq ! (Some (segtree . max_right (i , f)) , (i ..= n) . filter (|& j | f (base [i .. j] . iter () . max () . copied () . unwrap_or (i32 :: min_value ()))) . max ()) ; } for j in 0 ..= n { assert_eq ! (Some (segtree . min_left (j , f)) , (0 ..= j) . filter (|& i | f (base [i .. j] . iter () . max () . copied () . unwrap_or (i32 :: min_value ()))) . min ()) ; } } } } } pub mod math { use super :: internal_math ; use std :: mem :: swap ; # [allow (clippy :: many_single_char_names)] pub fn pow_mod (x : i64 , mut n : i64 , m : u32) -> u32 { assert ! (0 <= n && 1 <= m && m <= 2u32 . pow (31)) ; if m == 1 { return 0 ; } let bt = internal_math :: Barrett :: new (m) ; let mut r = 1 ; let mut y = internal_math :: safe_mod (x , m as i64) as u32 ; while n != 0 { if n & 1 != 0 { r = bt . mul (r , y) ; } y = bt . mul (y , y) ; n >>= 1 ; } r } pub fn inv_mod (x : i64 , m : i64) -> i64 { assert ! (1 <= m) ; let z = internal_math :: inv_gcd (x , m) ; assert ! (z . 0 == 1) ; z . 1 } pub fn crt (r : & [i64] , m : & [i64]) -> (i64 , i64) { assert_eq ! (r . len () , m . len ()) ; let (mut r0 , mut m0) = (0 , 1) ; for (& (mut ri) , & (mut mi)) in r . iter () . zip (m . iter ()) { assert ! (1 <= mi) ; ri = internal_math :: safe_mod (ri , mi) ; if m0 < mi { swap (& mut r0 , & mut ri) ; swap (& mut m0 , & mut mi) ; } if m0 % mi == 0 { if r0 % mi != ri { return (0 , 0) ; } continue ; } let (g , im) = internal_math :: inv_gcd (m0 , mi) ; let u1 = mi / g ; if (ri - r0) % g != 0 { return (0 , 0) ; } let x = (ri - r0) / g % u1 * im % u1 ; r0 += x * m0 ; m0 *= u1 ; if r0 < 0 { r0 += m0 } ; } (r0 , m0) } pub fn floor_sum (n : i64 , m : i64 , mut a : i64 , mut b : i64) -> i64 { let mut ans = 0 ; if a >= m { ans += (n - 1) * n * (a / m) / 2 ; a %= m ; } if b >= m { ans += n * (b / m) ; b %= m ; } let y_max = (a * n + b) / m ; let x_max = y_max * m - b ; if y_max == 0 { return ans ; } ans += (n - (x_max + a - 1) / a) * y_max ; ans += floor_sum (y_max , a , m , (a - x_max % a) % a) ; ans } # [cfg (test)] mod tests { # ! [allow (clippy :: unreadable_literal)] # ! [allow (clippy :: cognitive_complexity)] use super :: * ; # [test] fn test_pow_mod () { assert_eq ! (pow_mod (0 , 0 , 1) , 0) ; assert_eq ! (pow_mod (0 , 0 , 3) , 1) ; assert_eq ! (pow_mod (0 , 0 , 723) , 1) ; assert_eq ! (pow_mod (0 , 0 , 998244353) , 1) ; assert_eq ! (pow_mod (0 , 0 , 2u32 . pow (31)) , 1) ; assert_eq ! (pow_mod (0 , 1 , 1) , 0) ; assert_eq ! (pow_mod (0 , 1 , 3) , 0) ; assert_eq ! (pow_mod (0 , 1 , 723) , 0) ; assert_eq ! (pow_mod (0 , 1 , 998244353) , 0) ; assert_eq ! (pow_mod (0 , 1 , 2u32 . pow (31)) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 1) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 3) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 723) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 998244353) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 2u32 . pow (31)) , 0) ; assert_eq ! (pow_mod (1 , 0 , 1) , 0) ; assert_eq ! (pow_mod (1 , 0 , 3) , 1) ; assert_eq ! (pow_mod (1 , 0 , 723) , 1) ; assert_eq ! (pow_mod (1 , 0 , 998244353) , 1) ; assert_eq ! (pow_mod (1 , 0 , 2u32 . pow (31)) , 1) ; assert_eq ! (pow_mod (1 , 1 , 1) , 0) ; assert_eq ! (pow_mod (1 , 1 , 3) , 1) ; assert_eq ! (pow_mod (1 , 1 , 723) , 1) ; assert_eq ! (pow_mod (1 , 1 , 998244353) , 1) ; assert_eq ! (pow_mod (1 , 1 , 2u32 . pow (31)) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 1) , 0) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 3) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 723) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 998244353) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 2u32 . pow (31)) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 1) , 0) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 3) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 723) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 998244353) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 2u32 . pow (31)) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 1) , 0) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 3) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 723) , 640) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 998244353) , 683296792) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 2u32 . pow (31)) , 2147483647) ; assert_eq ! (pow_mod (2 , 3 , 1_000_000_007) , 8) ; assert_eq ! (pow_mod (5 , 7 , 1_000_000_007) , 78125) ; assert_eq ! (pow_mod (123 , 456 , 1_000_000_007) , 565291922) ; } # [test] # [should_panic] fn test_inv_mod_1 () { inv_mod (271828 , 0) ; } # [test] # [should_panic] fn test_inv_mod_2 () { inv_mod (3141592 , 1000000008) ; } # [test] fn test_crt () { let a = [44 , 23 , 13] ; let b = [13 , 50 , 22] ; assert_eq ! (crt (& a , & b) , (1773 , 7150)) ; let a = [12345 , 67890 , 99999] ; let b = [13 , 444321 , 95318] ; assert_eq ! (crt (& a , & b) , (103333581255 , 550573258014)) ; let a = [0 , 3 , 4] ; let b = [1 , 9 , 5] ; assert_eq ! (crt (& a , & b) , (39 , 45)) ; } # [test] fn test_floor_sum () { assert_eq ! (floor_sum (0 , 1 , 0 , 0) , 0) ; assert_eq ! (floor_sum (1_000_000_000 , 1 , 1 , 1) , 500_000_000_500_000_000) ; assert_eq ! (floor_sum (1_000_000_000 , 1_000_000_000 , 999_999_999 , 999_999_999) , 499_999_999_500_000_000) ; assert_eq ! (floor_sum (332955 , 5590132 , 2231 , 999423) , 22014575) ; } } } pub mod maxflow { use super :: internal_queue :: SimpleQueue ; use super :: internal_type_traits :: Integral ; use std :: cmp :: min ; use std :: iter ; impl < Cap > MfGraph < Cap > where Cap : Integral , { pub fn new (n : usize) -> MfGraph < Cap > { MfGraph { _n : n , pos : Vec :: new () , g : iter :: repeat_with (Vec :: new) . take (n) . collect () , } } pub fn add_edge (& mut self , from : usize , to : usize , cap : Cap) -> usize { assert ! (from < self . _n) ; assert ! (to < self . _n) ; assert ! (Cap :: zero () <= cap) ; let m = self . pos . len () ; self . pos . push ((from , self . g [from] . len ())) ; let rev = self . g [to] . len () + if from == to { 1 } else { 0 } ; self . g [from] . push (_Edge { to , rev , cap }) ; let rev = self . g [from] . len () - 1 ; self . g [to] . push (_Edge { to : from , rev , cap : Cap :: zero () , }) ; m } } # [derive (Debug , PartialEq , Eq)] pub struct Edge < Cap : Integral > { pub from : usize , pub to : usize , pub cap : Cap , pub flow : Cap , } impl < Cap > MfGraph < Cap > where Cap : Integral , { pub fn get_edge (& self , i : usize) -> Edge < Cap > { let m = self . pos . len () ; assert ! (i < m) ; let _e = & self . g [self . pos [i] . 0] [self . pos [i] . 1] ; let _re = & self . g [_e . to] [_e . rev] ; Edge { from : self . pos [i] . 0 , to : _e . to , cap : _e . cap + _re . cap , flow : _re . cap , } } pub fn edges (& self) -> Vec < Edge < Cap > > { let m = self . pos . len () ; (0 .. m) . map (| i | self . get_edge (i)) . collect () } pub fn change_edge (& mut self , i : usize , new_cap : Cap , new_flow : Cap) { let m = self . pos . len () ; assert ! (i < m) ; assert ! (Cap :: zero () <= new_flow && new_flow <= new_cap) ; let (to , rev) = { let _e = & mut self . g [self . pos [i] . 0] [self . pos [i] . 1] ; _e . cap = new_cap - new_flow ; (_e . to , _e . rev) } ; let _re = & mut self . g [to] [rev] ; _re . cap = new_flow ; } # [doc = " `s != t` must hold, otherwise it panics."] pub fn flow (& mut self , s : usize , t : usize) -> Cap { self . flow_with_capacity (s , t , Cap :: max_value ()) } # [doc = " # Parameters"] # [doc = " * `s != t` must hold, otherwise it panics."] # [doc = " * `flow_limit >= 0`"] pub fn flow_with_capacity (& mut self , s : usize , t : usize , flow_limit : Cap) -> Cap { let n_ = self . _n ; assert ! (s < n_) ; assert ! (t < n_) ; assert_ne ! (s , t) ; assert ! (Cap :: zero () <= flow_limit) ; let mut calc = FlowCalculator { graph : self , s , t , flow_limit , level : vec ! [0 ; n_] , iter : vec ! [0 ; n_] , que : SimpleQueue :: default () , } ; let mut flow = Cap :: zero () ; while flow < flow_limit { calc . bfs () ; if calc . level [t] == - 1 { break ; } calc . iter . iter_mut () . for_each (| e | * e = 0) ; while flow < flow_limit { let f = calc . dfs (t , flow_limit - flow) ; if f == Cap :: zero () { break ; } flow += f ; } } flow } pub fn min_cut (& self , s : usize) -> Vec < bool > { let mut visited = vec ! [false ; self . _n] ; let mut que = SimpleQueue :: default () ; que . push (s) ; while ! que . empty () { let & p = que . front () . unwrap () ; que . pop () ; visited [p] = true ; for e in & self . g [p] { if e . cap != Cap :: zero () && ! visited [e . to] { visited [e . to] = true ; que . push (e . to) ; } } } visited } } struct FlowCalculator < 'a , Cap > { graph : & 'a mut MfGraph < Cap > , s : usize , t : usize , flow_limit : Cap , level : Vec < i32 > , iter : Vec < usize > , que : SimpleQueue < usize > , } impl < Cap > FlowCalculator < '_ , Cap > where Cap : Integral , { fn bfs (& mut self) { self . level . iter_mut () . for_each (| e | * e = - 1) ; self . level [self . s] = 0 ; self . que . clear () ; self . que . push (self . s) ; while ! self . que . empty () { let v = * self . que . front () . unwrap () ; self . que . pop () ; for e in & self . graph . g [v] { if e . cap == Cap :: zero () || self . level [e . to] >= 0 { continue ; } self . level [e . to] = self . level [v] + 1 ; if e . to == self . t { return ; } self . que . push (e . to) ; } } } fn dfs (& mut self , v : usize , up : Cap) -> Cap { if v == self . s { return up ; } let mut res = Cap :: zero () ; let level_v = self . level [v] ; for i in self . iter [v] .. self . graph . g [v] . len () { self . iter [v] = i ; let & _Edge { to : e_to , rev : e_rev , .. } = & self . graph . g [v] [i] ; if level_v <= self . level [e_to] || self . graph . g [e_to] [e_rev] . cap == Cap :: zero () { continue ; } let d = self . dfs (e_to , min (up - res , self . graph . g [e_to] [e_rev] . cap)) ; if d <= Cap :: zero () { continue ; } self . graph . g [v] [i] . cap += d ; self . graph . g [e_to] [e_rev] . cap -= d ; res += d ; if res == up { break ; } } self . iter [v] = self . graph . g [v] . len () ; res } } # [derive (Default)] pub struct MfGraph < Cap > { _n : usize , pos : Vec < (usize , usize) > , g : Vec < Vec < _Edge < Cap > > > , } struct _Edge < Cap > { to : usize , rev : usize , cap : Cap , } # [cfg (test)] mod test { use super :: { Edge , MfGraph } ; # [test] fn test_max_flow_wikipedia () { let mut graph = MfGraph :: new (6) ; assert_eq ! (graph . add_edge (0 , 1 , 3) , 0) ; assert_eq ! (graph . add_edge (0 , 2 , 3) , 1) ; assert_eq ! (graph . add_edge (1 , 2 , 2) , 2) ; assert_eq ! (graph . add_edge (1 , 3 , 3) , 3) ; assert_eq ! (graph . add_edge (2 , 4 , 2) , 4) ; assert_eq ! (graph . add_edge (3 , 4 , 4) , 5) ; assert_eq ! (graph . add_edge (3 , 5 , 2) , 6) ; assert_eq ! (graph . add_edge (4 , 5 , 3) , 7) ; assert_eq ! (graph . flow (0 , 5) , 5) ; let edges = graph . edges () ; { # [rustfmt :: skip] assert_eq ! (edges , vec ! [Edge { from : 0 , to : 1 , cap : 3 , flow : 3 } , Edge { from : 0 , to : 2 , cap : 3 , flow : 2 } , Edge { from : 1 , to : 2 , cap : 2 , flow : 0 } , Edge { from : 1 , to : 3 , cap : 3 , flow : 3 } , Edge { from : 2 , to : 4 , cap : 2 , flow : 2 } , Edge { from : 3 , to : 4 , cap : 4 , flow : 1 } , Edge { from : 3 , to : 5 , cap : 2 , flow : 2 } , Edge { from : 4 , to : 5 , cap : 3 , flow : 3 } ,]) ; } assert_eq ! (graph . min_cut (0) , vec ! [true , false , true , false , false , false]) ; } # [test] fn test_max_flow_wikipedia_multiple_edges () { let mut graph = MfGraph :: new (6) ; for & (u , v , c) in & [(0 , 1 , 3) , (0 , 2 , 3) , (1 , 2 , 2) , (1 , 3 , 3) , (2 , 4 , 2) , (3 , 4 , 4) , (3 , 5 , 2) , (4 , 5 , 3) ,] { for _ in 0 .. c { graph . add_edge (u , v , 1) ; } } assert_eq ! (graph . flow (0 , 5) , 5) ; assert_eq ! (graph . min_cut (0) , vec ! [true , false , true , false , false , false]) ; } # [test] # [allow (clippy :: many_single_char_names)] fn test_max_flow_misawa () { let n = 100 ; let mut graph = MfGraph :: new ((n + 1) * 2 + 5) ; let (s , a , b , c , t) = (0 , 1 , 2 , 3 , 4) ; graph . add_edge (s , a , 1) ; graph . add_edge (s , b , 2) ; graph . add_edge (b , a , 2) ; graph . add_edge (c , t , 2) ; for i in 0 .. n { let i = 2 * i + 5 ; for j in 0 .. 2 { for k in 2 .. 4 { graph . add_edge (i + j , i + k , 3) ; } } } for j in 0 .. 2 { graph . add_edge (a , 5 + j , 3) ; graph . add_edge (2 * n + 5 + j , c , 3) ; } assert_eq ! (graph . flow (s , t) , 2) ; } } } pub mod mincostflow { use super :: internal_type_traits :: Integral ; pub struct MinCostFlowEdge < T > { pub from : usize , pub to : usize , pub cap : T , pub flow : T , pub cost : T , } pub struct MinCostFlowGraph < T > { pos : Vec < (usize , usize) > , g : Vec < Vec < _Edge < T > > > , cost_sum : T , } impl < T > MinCostFlowGraph < T > where T : Integral + std :: ops :: Neg < Output = T > , { pub fn new (n : usize) -> Self { Self { pos : vec ! [] , g : (0 .. n) . map (| _ | vec ! []) . collect () , cost_sum : T :: zero () , } } pub fn get_edge (& self , i : usize) -> MinCostFlowEdge < T > { assert ! (i < self . pos . len ()) ; let e = & self . g [self . pos [i] . 0] [self . pos [i] . 1] ; let re = & self . g [e . to] [e . rev] ; MinCostFlowEdge { from : self . pos [i] . 0 , to : e . to , cap : e . cap + re . cap , flow : re . cap , cost : e . cost , } } pub fn edges (& self) -> Vec < MinCostFlowEdge < T > > { let m = self . pos . len () ; let mut result = vec ! [] ; for i in 0 .. m { result . push (self . get_edge (i)) ; } result } pub fn add_edge (& mut self , from : usize , to : usize , cap : T , cost : T) -> usize { assert ! (from < self . g . len ()) ; assert ! (to < self . g . len ()) ; assert_ne ! (from , to) ; assert ! (cap >= T :: zero ()) ; assert ! (cost >= T :: zero ()) ; self . pos . push ((from , self . g [from] . len ())) ; self . cost_sum += cost ; let rev = self . g [to] . len () ; self . g [from] . push (_Edge { to , rev , cap , cost }) ; let rev = self . g [from] . len () - 1 ; self . g [to] . push (_Edge { to : from , rev , cap : T :: zero () , cost : - cost , }) ; self . pos . len () - 1 } # [doc = " Returns (maximum flow, cost)"] pub fn flow (& mut self , source : usize , sink : usize , flow_limit : T) -> (T , T) { self . slope (source , sink , flow_limit) . pop () . unwrap () } pub fn slope (& mut self , source : usize , sink : usize , flow_limit : T) -> Vec < (T , T) > { let n = self . g . len () ; assert ! (source < n) ; assert ! (sink < n) ; assert_ne ! (source , sink) ; let mut dual = vec ! [T :: zero () ; n] ; let mut prev_v = vec ! [0 ; n] ; let mut prev_e = vec ! [0 ; n] ; let mut flow = T :: zero () ; let mut cost = T :: zero () ; let mut prev_cost : Option < T > = None ; let mut result = vec ! [(flow , cost)] ; while flow < flow_limit { if ! self . refine_dual (source , sink , & mut dual , & mut prev_v , & mut prev_e) { break ; } let mut c = flow_limit - flow ; let mut v = sink ; while v != source { c = std :: cmp :: min (c , self . g [prev_v [v]] [prev_e [v]] . cap) ; v = prev_v [v] ; } let mut v = sink ; while v != source { self . g [prev_v [v]] [prev_e [v]] . cap -= c ; let rev = self . g [prev_v [v]] [prev_e [v]] . rev ; self . g [v] [rev] . cap += c ; v = prev_v [v] ; } let d = - dual [source] ; flow += c ; cost += d * c ; if prev_cost == Some (d) { assert ! (result . pop () . is_some ()) ; } result . push ((flow , cost)) ; prev_cost = Some (cost) ; } result } fn refine_dual (& self , source : usize , sink : usize , dual : & mut [T] , pv : & mut [usize] , pe : & mut [usize] ,) -> bool { let n = self . g . len () ; let mut dist = vec ! [self . cost_sum ; n] ; let mut vis = vec ! [false ; n] ; let mut que = std :: collections :: BinaryHeap :: new () ; dist [source] = T :: zero () ; que . push ((std :: cmp :: Reverse (T :: zero ()) , source)) ; while let Some ((_ , v)) = que . pop () { if vis [v] { continue ; } vis [v] = true ; if v == sink { break ; } for (i , e) in self . g [v] . iter () . enumerate () { if vis [e . to] || e . cap == T :: zero () { continue ; } let cost = e . cost - dual [e . to] + dual [v] ; if dist [e . to] - dist [v] > cost { dist [e . to] = dist [v] + cost ; pv [e . to] = v ; pe [e . to] = i ; que . push ((std :: cmp :: Reverse (dist [e . to]) , e . to)) ; } } } if ! vis [sink] { return false ; } for v in 0 .. n { if ! vis [v] { continue ; } dual [v] -= dist [sink] - dist [v] ; } true } } struct _Edge < T > { to : usize , rev : usize , cap : T , cost : T , } # [cfg (test)] mod tests { use super :: * ; # [test] fn test_min_cost_flow () { let mut graph = MinCostFlowGraph :: new (4) ; graph . add_edge (0 , 1 , 2 , 1) ; graph . add_edge (0 , 2 , 1 , 2) ; graph . add_edge (1 , 2 , 1 , 1) ; graph . add_edge (1 , 3 , 1 , 3) ; graph . add_edge (2 , 3 , 2 , 1) ; let (flow , cost) = graph . flow (0 , 3 , 2) ; assert_eq ! (flow , 2) ; assert_eq ! (cost , 6) ; } } } pub mod modint { use super :: internal_math ; use std :: { cell :: RefCell , convert :: { Infallible , TryInto as _ } , fmt , hash :: { Hash , Hasher } , iter :: { Product , Sum } , marker :: PhantomData , ops :: { Add , AddAssign , Div , DivAssign , Mul , MulAssign , Neg , Sub , SubAssign } , str :: FromStr , thread :: LocalKey , } ; pub type ModInt1000000007 = StaticModInt < Mod1000000007 > ; pub type ModInt998244353 = StaticModInt < Mod998244353 > ; pub type ModInt = DynamicModInt < DefaultId > ; # [doc = " Corresponds to `atcoder::static_modint` in the original ACL."] # [derive (Copy , Clone , Eq , PartialEq)] # [repr (transparent)] pub struct StaticModInt < M > { val : u32 , phantom : PhantomData < fn () -> M > , } impl < M : Modulus > StaticModInt < M > { # [doc = " Corresponds to `atcoder::static_modint::mod` in the original ACL."] # [inline (always)] pub fn modulus () -> u32 { M :: VALUE } # [doc = " Creates a new `StaticModInt`."] # [inline] pub fn new < T : RemEuclidU32 > (val : T) -> Self { Self :: raw (val . rem_euclid_u32 (M :: VALUE)) } # [doc = " Corresponds to `atcoder::static_modint::raw` in the original ACL."] # [inline] pub fn raw (val : u32) -> Self { Self { val , phantom : PhantomData , } } # [doc = " Corresponds to `atcoder::static_modint::val` in the original ACL."] # [inline] pub fn val (self) -> u32 { self . val } # [doc = " Corresponds to `atcoder::static_modint::pow` in the original ACL."] # [inline] pub fn pow (self , n : u64) -> Self { < Self as ModIntBase > :: pow (self , n) } # [doc = " Corresponds to `atcoder::static_modint::inv` in the original ACL."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " Panics if the multiplicative inverse does not exist."] # [inline] pub fn inv (self) -> Self { if M :: HINT_VALUE_IS_PRIME { if self . val () == 0 { panic ! ("attempt to divide by zero") ; } debug_assert ! (internal_math :: is_prime (M :: VALUE . try_into () . unwrap ()) , "{} is not a prime number" , M :: VALUE ,) ; self . pow ((M :: VALUE - 2) . into ()) } else { Self :: inv_for_non_prime_modulus (self) } } } impl < M : Modulus > ModIntBase for StaticModInt < M > { # [inline (always)] fn modulus () -> u32 { Self :: modulus () } # [inline] fn raw (val : u32) -> Self { Self :: raw (val) } # [inline] fn val (self) -> u32 { self . val () } # [inline] fn inv (self) -> Self { self . inv () } } pub trait Modulus : 'static + Copy + Eq { const VALUE : u32 ; const HINT_VALUE_IS_PRIME : bool ; fn butterfly_cache () -> & 'static LocalKey < RefCell < Option < ButterflyCache < Self > > > > ; } # [derive (Copy , Clone , Ord , PartialOrd , Eq , PartialEq , Hash , Debug)] pub enum Mod1000000007 { } impl Modulus for Mod1000000007 { const VALUE : u32 = 1_000_000_007 ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & 'static LocalKey < RefCell < Option < ButterflyCache < Self > > > > { thread_local ! { static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod1000000007 >>> = RefCell :: default () ; } & BUTTERFLY_CACHE } } # [derive (Copy , Clone , Ord , PartialOrd , Eq , PartialEq , Hash , Debug)] pub enum Mod998244353 { } impl Modulus for Mod998244353 { const VALUE : u32 = 998_244_353 ; const HINT_VALUE_IS_PRIME : bool = true ; fn butterfly_cache () -> & 'static LocalKey < RefCell < Option < ButterflyCache < Self > > > > { thread_local ! { static BUTTERFLY_CACHE : RefCell < Option < ButterflyCache < Mod998244353 >>> = RefCell :: default () ; } & BUTTERFLY_CACHE } } pub struct ButterflyCache < M > { pub (crate) sum_e : Vec < StaticModInt < M > > , pub (crate) sum_ie : Vec < StaticModInt < M > > , } # [derive (Copy , Clone , Eq , PartialEq)] # [repr (transparent)] pub struct DynamicModInt < I > { val : u32 , phantom : PhantomData < fn () -> I > , } impl < I : Id > DynamicModInt < I > { # [inline] pub fn modulus () -> u32 { I :: companion_barrett () . with (| bt | bt . borrow () . umod ()) } # [inline] pub fn set_modulus (modulus : u32) { if modulus == 0 { panic ! ("the modulus must not be 0") ; } I :: companion_barrett () . with (| bt | * bt . borrow_mut () = Barrett :: new (modulus)) } # [inline] pub fn new < T : RemEuclidU32 > (val : T) -> Self { < Self as ModIntBase > :: new (val) } # [inline] pub fn raw (val : u32) -> Self { Self { val , phantom : PhantomData , } } # [inline] pub fn val (self) -> u32 { self . val } # [inline] pub fn pow (self , n : u64) -> Self { < Self as ModIntBase > :: pow (self , n) } # [inline] pub fn inv (self) -> Self { Self :: inv_for_non_prime_modulus (self) } } impl < I : Id > ModIntBase for DynamicModInt < I > { # [inline] fn modulus () -> u32 { Self :: modulus () } # [inline] fn raw (val : u32) -> Self { Self :: raw (val) } # [inline] fn val (self) -> u32 { self . val () } # [inline] fn inv (self) -> Self { self . inv () } } pub trait Id : 'static + Copy + Eq { fn companion_barrett () -> & 'static LocalKey < RefCell < Barrett > > ; } # [derive (Copy , Clone , Ord , PartialOrd , Eq , PartialEq , Hash , Debug)] pub enum DefaultId { } impl Id for DefaultId { fn companion_barrett () -> & 'static LocalKey < RefCell < Barrett > > { thread_local ! { static BARRETT : RefCell < Barrett > = RefCell :: default () ; } & BARRETT } } pub struct Barrett (internal_math :: Barrett) ; impl Barrett { # [inline] pub fn new (m : u32) -> Self { Self (internal_math :: Barrett :: new (m)) } # [inline] fn umod (& self) -> u32 { self . 0 . umod () } # [inline] fn mul (& self , a : u32 , b : u32) -> u32 { self . 0 . mul (a , b) } } impl Default for Barrett { # [inline] fn default () -> Self { Self (internal_math :: Barrett :: new (998_244_353)) } } pub trait ModIntBase : Default + FromStr + From < i8 > + From < i16 > + From < i32 > + From < i64 > + From < i128 > + From < u8 > + From < u16 > + From < u32 > + From < u64 > + From < u128 > + Copy + Eq + Hash + fmt :: Display + fmt :: Debug + Neg < Output = Self > + Add < Output = Self > + Sub < Output = Self > + Mul < Output = Self > + Div < Output = Self > + AddAssign + SubAssign + MulAssign + DivAssign { fn modulus () -> u32 ; fn raw (val : u32) -> Self ; fn val (self) -> u32 ; fn inv (self) -> Self ; # [inline] fn new < T : RemEuclidU32 > (val : T) -> Self { Self :: raw (val . rem_euclid_u32 (Self :: modulus ())) } # [inline] fn pow (self , mut n : u64) -> Self { let mut x = self ; let mut r = Self :: raw (1) ; while n > 0 { if n & 1 == 1 { r *= x ; } x *= x ; n >>= 1 ; } r } } pub trait RemEuclidU32 { fn rem_euclid_u32 (self , modulus : u32) -> u32 ; } macro_rules ! impl_rem_euclid_u32_for_small_signed { ($ ($ ty : tt) ,*) => { $ (impl RemEuclidU32 for $ ty { # [inline] fn rem_euclid_u32 (self , modulus : u32) -> u32 { (self as i64) . rem_euclid (i64 :: from (modulus)) as _ } }) * } } impl_rem_euclid_u32_for_small_signed ! (i8 , i16 , i32 , i64 , isize) ; impl RemEuclidU32 for i128 { # [inline] fn rem_euclid_u32 (self , modulus : u32) -> u32 { self . rem_euclid (i128 :: from (modulus)) as _ } } macro_rules ! impl_rem_euclid_u32_for_small_unsigned { ($ ($ ty : tt) ,*) => { $ (impl RemEuclidU32 for $ ty { # [inline] fn rem_euclid_u32 (self , modulus : u32) -> u32 { self as u32 % modulus } }) * } } macro_rules ! impl_rem_euclid_u32_for_large_unsigned { ($ ($ ty : tt) ,*) => { $ (impl RemEuclidU32 for $ ty { # [inline] fn rem_euclid_u32 (self , modulus : u32) -> u32 { (self % (modulus as $ ty)) as _ } }) * } } impl_rem_euclid_u32_for_small_unsigned ! (u8 , u16 , u32) ; impl_rem_euclid_u32_for_large_unsigned ! (u64 , u128) ; # [cfg (target_pointer_width = "32")] impl_rem_euclid_u32_for_small_unsigned ! (usize) ; # [cfg (target_pointer_width = "64")] impl_rem_euclid_u32_for_large_unsigned ! (usize) ; trait InternalImplementations : ModIntBase { # [inline] fn inv_for_non_prime_modulus (this : Self) -> Self { let (gcd , x) = internal_math :: inv_gcd (this . val () . into () , Self :: modulus () . into ()) ; if gcd != 1 { panic ! ("the multiplicative inverse does not exist") ; } Self :: new (x) } # [inline] fn default_impl () -> Self { Self :: raw (0) } # [inline] fn from_str_impl (s : & str) -> Result < Self , Infallible > { Ok (s . parse :: < i64 > () . map (Self :: new) . unwrap_or_else (| _ | todo ! ("parsing as an arbitrary precision integer?"))) } # [inline] fn hash_impl (this : & Self , state : & mut impl Hasher) { this . val () . hash (state) } # [inline] fn display_impl (this : & Self , f : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Display :: fmt (& this . val () , f) } # [inline] fn debug_impl (this : & Self , f : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Debug :: fmt (& this . val () , f) } # [inline] fn neg_impl (this : Self) -> Self { Self :: sub_impl (Self :: raw (0) , this) } # [inline] fn add_impl (lhs : Self , rhs : Self) -> Self { let modulus = Self :: modulus () ; let mut val = lhs . val () + rhs . val () ; if val >= modulus { val -= modulus ; } Self :: raw (val) } # [inline] fn sub_impl (lhs : Self , rhs : Self) -> Self { let modulus = Self :: modulus () ; let mut val = lhs . val () . wrapping_sub (rhs . val ()) ; if val >= modulus { val = val . wrapping_add (modulus) } Self :: raw (val) } fn mul_impl (lhs : Self , rhs : Self) -> Self ; # [inline] fn div_impl (lhs : Self , rhs : Self) -> Self { Self :: mul_impl (lhs , rhs . inv ()) } } impl < M : Modulus > InternalImplementations for StaticModInt < M > { # [inline] fn mul_impl (lhs : Self , rhs : Self) -> Self { Self :: raw ((u64 :: from (lhs . val ()) * u64 :: from (rhs . val ()) % u64 :: from (M :: VALUE)) as u32) } } impl < I : Id > InternalImplementations for DynamicModInt < I > { # [inline] fn mul_impl (lhs : Self , rhs : Self) -> Self { I :: companion_barrett () . with (| bt | Self :: raw (bt . borrow () . mul (lhs . val , rhs . val))) } } macro_rules ! impl_basic_traits { () => { } ; (impl <$ generic_param : ident : $ generic_param_bound : tt > _ for $ self : ty ; $ ($ rest : tt) *) => { impl <$ generic_param : $ generic_param_bound > Default for $ self { # [inline] fn default () -> Self { Self :: default_impl () } } impl <$ generic_param : $ generic_param_bound > FromStr for $ self { type Err = Infallible ; # [inline] fn from_str (s : & str) -> Result < Self , Infallible > { Self :: from_str_impl (s) } } impl <$ generic_param : $ generic_param_bound , V : RemEuclidU32 > From < V > for $ self { # [inline] fn from (from : V) -> Self { Self :: new (from) } } # [allow (clippy :: derive_hash_xor_eq)] impl <$ generic_param : $ generic_param_bound > Hash for $ self { # [inline] fn hash < H : Hasher > (& self , state : & mut H) { Self :: hash_impl (self , state) } } impl <$ generic_param : $ generic_param_bound > fmt :: Display for $ self { # [inline] fn fmt (& self , f : & mut fmt :: Formatter <'_ >) -> fmt :: Result { Self :: display_impl (self , f) } } impl <$ generic_param : $ generic_param_bound > fmt :: Debug for $ self { # [inline] fn fmt (& self , f : & mut fmt :: Formatter <'_ >) -> fmt :: Result { Self :: debug_impl (self , f) } } impl <$ generic_param : $ generic_param_bound > Neg for $ self { type Output = $ self ; # [inline] fn neg (self) -> $ self { Self :: neg_impl (self) } } impl <$ generic_param : $ generic_param_bound > Neg for &'_ $ self { type Output = $ self ; # [inline] fn neg (self) -> $ self { <$ self >:: neg_impl (* self) } } impl_basic_traits ! ($ ($ rest) *) ; } ; } impl_basic_traits ! { impl < M : Modulus > _ for StaticModInt < M > ; impl < I : Id > _ for DynamicModInt < I >; } macro_rules ! impl_bin_ops { () => { } ; (for <$ generic_param : ident : $ generic_param_bound : tt > <$ lhs_ty : ty > ~ <$ rhs_ty : ty > -> $ output : ty { { $ lhs_body : expr } ~ { $ rhs_body : expr } } $ ($ rest : tt) *) => { impl <$ generic_param : $ generic_param_bound > Add <$ rhs_ty > for $ lhs_ty { type Output = $ output ; # [inline] fn add (self , rhs : $ rhs_ty) -> $ output { <$ output >:: add_impl (apply ($ lhs_body , self) , apply ($ rhs_body , rhs)) } } impl <$ generic_param : $ generic_param_bound > Sub <$ rhs_ty > for $ lhs_ty { type Output = $ output ; # [inline] fn sub (self , rhs : $ rhs_ty) -> $ output { <$ output >:: sub_impl (apply ($ lhs_body , self) , apply ($ rhs_body , rhs)) } } impl <$ generic_param : $ generic_param_bound > Mul <$ rhs_ty > for $ lhs_ty { type Output = $ output ; # [inline] fn mul (self , rhs : $ rhs_ty) -> $ output { <$ output >:: mul_impl (apply ($ lhs_body , self) , apply ($ rhs_body , rhs)) } } impl <$ generic_param : $ generic_param_bound > Div <$ rhs_ty > for $ lhs_ty { type Output = $ output ; # [inline] fn div (self , rhs : $ rhs_ty) -> $ output { <$ output >:: div_impl (apply ($ lhs_body , self) , apply ($ rhs_body , rhs)) } } impl_bin_ops ! ($ ($ rest) *) ; } ; } macro_rules ! impl_assign_ops { () => { } ; (for <$ generic_param : ident : $ generic_param_bound : tt > <$ lhs_ty : ty > ~= <$ rhs_ty : ty > { _ ~= { $ rhs_body : expr } } $ ($ rest : tt) *) => { impl <$ generic_param : $ generic_param_bound > AddAssign <$ rhs_ty > for $ lhs_ty { # [inline] fn add_assign (& mut self , rhs : $ rhs_ty) { * self = * self + apply ($ rhs_body , rhs) ; } } impl <$ generic_param : $ generic_param_bound > SubAssign <$ rhs_ty > for $ lhs_ty { # [inline] fn sub_assign (& mut self , rhs : $ rhs_ty) { * self = * self - apply ($ rhs_body , rhs) ; } } impl <$ generic_param : $ generic_param_bound > MulAssign <$ rhs_ty > for $ lhs_ty { # [inline] fn mul_assign (& mut self , rhs : $ rhs_ty) { * self = * self * apply ($ rhs_body , rhs) ; } } impl <$ generic_param : $ generic_param_bound > DivAssign <$ rhs_ty > for $ lhs_ty { # [inline] fn div_assign (& mut self , rhs : $ rhs_ty) { * self = * self / apply ($ rhs_body , rhs) ; } } impl_assign_ops ! ($ ($ rest) *) ; } ; } # [inline] fn apply < F : FnOnce (X) -> O , X , O > (f : F , x : X) -> O { f (x) } impl_bin_ops ! { for < M : Modulus > < StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > { { | x | x } ~ { | x | x } } for < M : Modulus > < StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > { { | x | x } ~ { |& x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ < StaticModInt < M > > -> StaticModInt < M > { { |& x | x } ~ { | x | x } } for < M : Modulus > <&'_ StaticModInt < M > > ~ <&'_ StaticModInt < M > > -> StaticModInt < M > { { |& x | x } ~ { |& x | x } } for < I : Id > < DynamicModInt < I > > ~ < DynamicModInt < I > > -> DynamicModInt < I > { { | x | x } ~ { | x | x } } for < I : Id > < DynamicModInt < I > > ~ <&'_ DynamicModInt < I >> -> DynamicModInt < I > { { | x | x } ~ { |& x | x } } for < I : Id > <&'_ DynamicModInt < I >> ~ < DynamicModInt < I > > -> DynamicModInt < I > { { |& x | x } ~ { | x | x } } for < I : Id > <&'_ DynamicModInt < I >> ~ <&'_ DynamicModInt < I >> -> DynamicModInt < I > { { |& x | x } ~ { |& x | x } } } impl_assign_ops ! { for < M : Modulus > < StaticModInt < M > > ~= < StaticModInt < M > > { _ ~= { | x | x } } for < M : Modulus > < StaticModInt < M > > ~= <&'_ StaticModInt < M > > { _ ~= { |& x | x } } for < I : Id > < DynamicModInt < I >> ~= < DynamicModInt < I > > { _ ~= { | x | x } } for < I : Id > < DynamicModInt < I >> ~= <&'_ DynamicModInt < I >> { _ ~= { |& x | x } } } macro_rules ! impl_folding { () => { } ; (impl <$ generic_param : ident : $ generic_param_bound : tt > $ trait : ident < _ > for $ self : ty { fn $ method : ident (_) -> _ { _ ($ unit : expr , $ op : expr) } } $ ($ rest : tt) *) => { impl <$ generic_param : $ generic_param_bound > $ trait < Self > for $ self { # [inline] fn $ method < S > (iter : S) -> Self where S : Iterator < Item = Self >, { iter . fold ($ unit , $ op) } } impl <'a , $ generic_param : $ generic_param_bound > $ trait <&'a Self > for $ self { # [inline] fn $ method < S > (iter : S) -> Self where S : Iterator < Item = &'a Self >, { iter . fold ($ unit , $ op) } } impl_folding ! ($ ($ rest) *) ; } ; } impl_folding ! { impl < M : Modulus > Sum < _ > for StaticModInt < M > { fn sum (_) -> _ { _ (Self :: raw (0) , Add :: add) } } impl < M : Modulus > Product < _ > for StaticModInt < M > { fn product (_) -> _ { _ (Self :: raw (1) , Mul :: mul) } } impl < I : Id > Sum < _ > for DynamicModInt < I > { fn sum (_) -> _ { _ (Self :: raw (0) , Add :: add) } } impl < I : Id > Product < _ > for DynamicModInt < I > { fn product (_) -> _ { _ (Self :: raw (1) , Mul :: mul) } } } # [cfg (test)] mod tests { use super :: super :: modint :: ModInt1000000007 ; # [test] fn static_modint_new () { assert_eq ! (0 , ModInt1000000007 :: new (0u32) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1u32) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1_000_000_008u32) . val) ; assert_eq ! (0 , ModInt1000000007 :: new (0u64) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1u64) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1_000_000_008u64) . val) ; assert_eq ! (0 , ModInt1000000007 :: new (0usize) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1usize) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1_000_000_008usize) . val) ; assert_eq ! (0 , ModInt1000000007 :: new (0i64) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1i64) . val) ; assert_eq ! (1 , ModInt1000000007 :: new (1_000_000_008i64) . val) ; assert_eq ! (1_000_000_006 , ModInt1000000007 :: new (- 1i64) . val) ; } # [test] fn static_modint_add () { fn add (lhs : u32 , rhs : u32) -> u32 { (ModInt1000000007 :: new (lhs) + ModInt1000000007 :: new (rhs)) . val } assert_eq ! (2 , add (1 , 1)) ; assert_eq ! (1 , add (1_000_000_006 , 2)) ; } # [test] fn static_modint_sub () { fn sub (lhs : u32 , rhs : u32) -> u32 { (ModInt1000000007 :: new (lhs) - ModInt1000000007 :: new (rhs)) . val } assert_eq ! (1 , sub (2 , 1)) ; assert_eq ! (1_000_000_006 , sub (0 , 1)) ; } # [test] fn static_modint_mul () { fn mul (lhs : u32 , rhs : u32) -> u32 { (ModInt1000000007 :: new (lhs) * ModInt1000000007 :: new (rhs)) . val } assert_eq ! (1 , mul (1 , 1)) ; assert_eq ! (4 , mul (2 , 2)) ; assert_eq ! (999_999_937 , mul (100_000 , 100_000)) ; } # [test] fn static_modint_prime_div () { fn div (lhs : u32 , rhs : u32) -> u32 { (ModInt1000000007 :: new (lhs) / ModInt1000000007 :: new (rhs)) . val } assert_eq ! (0 , div (0 , 1)) ; assert_eq ! (1 , div (1 , 1)) ; assert_eq ! (1 , div (2 , 2)) ; assert_eq ! (23_809_524 , div (1 , 42)) ; } # [test] fn static_modint_sum () { fn sum (values : & [i64]) -> ModInt1000000007 { values . iter () . copied () . map (ModInt1000000007 :: new) . sum () } assert_eq ! (ModInt1000000007 :: new (- 3) , sum (& [- 1 , 2 , - 3 , 4 , - 5])) ; } # [test] fn static_modint_product () { fn product (values : & [i64]) -> ModInt1000000007 { values . iter () . copied () . map (ModInt1000000007 :: new) . product () } assert_eq ! (ModInt1000000007 :: new (- 120) , product (& [- 1 , 2 , - 3 , 4 , - 5])) ; } } } pub mod scc { use super :: internal_scc ; pub struct SccGraph { internal : internal_scc :: SccGraph , } impl SccGraph { pub fn new (n : usize) -> Self { SccGraph { internal : internal_scc :: SccGraph :: new (n) , } } pub fn add_edge (& mut self , from : usize , to : usize) { let n = self . internal . num_vertices () ; assert ! (from < n) ; assert ! (to < n) ; self . internal . add_edge (from , to) ; } pub fn scc (& self) -> Vec < Vec < usize > > { self . internal . scc () } } # [cfg (test)] mod tests { use super :: * ; # [test] fn test_scc_simple () { let mut graph = SccGraph :: new (2) ; graph . add_edge (0 , 1) ; graph . add_edge (1 , 0) ; let scc = graph . scc () ; assert_eq ! (scc . len () , 1) ; } # [test] fn test_scc_self_loop () { let mut graph = SccGraph :: new (2) ; graph . add_edge (0 , 0) ; graph . add_edge (0 , 0) ; graph . add_edge (1 , 1) ; let scc = graph . scc () ; assert_eq ! (scc . len () , 2) ; } # [test] fn solve_alpc_g_sample1 () { let n : usize = 6 ; let edges = vec ! [(1 , 4) , (5 , 2) , (3 , 0) , (5 , 5) , (4 , 1) , (0 , 3) , (4 , 2)] ; let mut graph = SccGraph :: new (n) ; for (u , v) in edges . into_iter () { graph . add_edge (u , v) ; } let scc = graph . scc () ; assert_eq ! (scc , vec ! [vec ! [5] , vec ! [1 , 4] , vec ! [2] , vec ! [0 , 3]]) ; } } } pub mod segtree { use super :: internal_bit :: ceil_pow2 ; use super :: internal_type_traits :: { BoundedAbove , BoundedBelow , One , Zero } ; use std :: cmp :: { max , min } ; use std :: convert :: Infallible ; use std :: marker :: PhantomData ; use std :: ops :: { Add , Mul } ; pub trait Monoid { type S : Clone ; fn identity () -> Self :: S ; fn binary_operation (a : & Self :: S , b : & Self :: S) -> Self :: S ; } pub struct Max < S > (Infallible , PhantomData < fn () -> S >) ; impl < S > Monoid for Max < S > where S : Copy + Ord + BoundedBelow , { type S = S ; fn identity () -> Self :: S { S :: min_value () } fn binary_operation (a : & Self :: S , b : & Self :: S) -> Self :: S { max (* a , * b) } } pub struct Min < S > (Infallible , PhantomData < fn () -> S >) ; impl < S > Monoid for Min < S > where S : Copy + Ord + BoundedAbove , { type S = S ; fn identity () -> Self :: S { S :: max_value () } fn binary_operation (a : & Self :: S , b : & Self :: S) -> Self :: S { min (* a , * b) } } pub struct Additive < S > (Infallible , PhantomData < fn () -> S >) ; impl < S > Monoid for Additive < S > where S : Copy + Add < Output = S > + Zero , { type S = S ; fn identity () -> Self :: S { S :: zero () } fn binary_operation (a : & Self :: S , b : & Self :: S) -> Self :: S { * a + * b } } pub struct Multiplicative < S > (Infallible , PhantomData < fn () -> S >) ; impl < S > Monoid for Multiplicative < S > where S : Copy + Mul < Output = S > + One , { type S = S ; fn identity () -> Self :: S { S :: one () } fn binary_operation (a : & Self :: S , b : & Self :: S) -> Self :: S { * a * * b } } impl < M : Monoid > Default for Segtree < M > { fn default () -> Self { Segtree :: new (0) } } impl < M : Monoid > Segtree < M > { pub fn new (n : usize) -> Segtree < M > { vec ! [M :: identity () ; n] . into () } } impl < M : Monoid > From < Vec < M :: S > > for Segtree < M > { fn from (v : Vec < M :: S >) -> Self { let n = v . len () ; let log = ceil_pow2 (n as u32) as usize ; let size = 1 << log ; let mut d = vec ! [M :: identity () ; 2 * size] ; d [size .. (size + n)] . clone_from_slice (& v) ; let mut ret = Segtree { n , size , log , d } ; for i in (1 .. size) . rev () { ret . update (i) ; } ret } } impl < M : Monoid > Segtree < M > { pub fn set (& mut self , mut p : usize , x : M :: S) { assert ! (p < self . n) ; p += self . size ; self . d [p] = x ; for i in 1 ..= self . log { self . update (p >> i) ; } } pub fn get (& self , p : usize) -> M :: S { assert ! (p < self . n) ; self . d [p + self . size] . clone () } pub fn prod (& self , mut l : usize , mut r : usize) -> M :: S { assert ! (l <= r && r <= self . n) ; let mut sml = M :: identity () ; let mut smr = M :: identity () ; l += self . size ; r += self . size ; while l < r { if l & 1 != 0 { sml = M :: binary_operation (& sml , & self . d [l]) ; l += 1 ; } if r & 1 != 0 { r -= 1 ; smr = M :: binary_operation (& self . d [r] , & smr) ; } l >>= 1 ; r >>= 1 ; } M :: binary_operation (& sml , & smr) } pub fn all_prod (& self) -> M :: S { self . d [1] . clone () } pub fn max_right < F > (& self , mut l : usize , f : F) -> usize where F : Fn (& M :: S) -> bool , { assert ! (l <= self . n) ; assert ! (f (& M :: identity ())) ; if l == self . n { return self . n ; } l += self . size ; let mut sm = M :: identity () ; while { while l % 2 == 0 { l >>= 1 ; } if ! f (& M :: binary_operation (& sm , & self . d [l])) { while l < self . size { l *= 2 ; let res = M :: binary_operation (& sm , & self . d [l]) ; if f (& res) { sm = res ; l += 1 ; } } return l - self . size ; } sm = M :: binary_operation (& sm , & self . d [l]) ; l += 1 ; { let l = l as isize ; (l & - l) != l } } { } self . n } pub fn min_left < F > (& self , mut r : usize , f : F) -> usize where F : Fn (& M :: S) -> bool , { assert ! (r <= self . n) ; assert ! (f (& M :: identity ())) ; if r == 0 { return 0 ; } r += self . size ; let mut sm = M :: identity () ; while { r -= 1 ; while r > 1 && r % 2 == 1 { r >>= 1 ; } if ! f (& M :: binary_operation (& self . d [r] , & sm)) { while r < self . size { r = 2 * r + 1 ; let res = M :: binary_operation (& self . d [r] , & sm) ; if f (& res) { sm = res ; r -= 1 ; } } return r + 1 - self . size ; } sm = M :: binary_operation (& self . d [r] , & sm) ; { let r = r as isize ; (r & - r) != r } } { } 0 } fn update (& mut self , k : usize) { self . d [k] = M :: binary_operation (& self . d [2 * k] , & self . d [2 * k + 1]) ; } } pub struct Segtree < M > where M : Monoid , { n : usize , size : usize , log : usize , d : Vec < M :: S > , } # [cfg (test)] mod tests { use super :: super :: segtree :: Max ; use super :: super :: Segtree ; # [test] fn test_max_segtree () { let base = vec ! [3 , 1 , 4 , 1 , 5 , 9 , 2 , 6 , 5 , 3] ; let n = base . len () ; let segtree : Segtree < Max < _ > > = base . clone () . into () ; check_segtree (& base , & segtree) ; let mut segtree = Segtree :: < Max < _ > > :: new (n) ; let mut internal = vec ! [i32 :: min_value () ; n] ; for i in 0 .. n { segtree . set (i , base [i]) ; internal [i] = base [i] ; check_segtree (& internal , & segtree) ; } segtree . set (6 , 5) ; internal [6] = 5 ; check_segtree (& internal , & segtree) ; segtree . set (6 , 0) ; internal [6] = 0 ; check_segtree (& internal , & segtree) ; } fn check_segtree (base : & [i32] , segtree : & Segtree < Max < i32 > >) { let n = base . len () ; # [allow (clippy :: needless_range_loop)] for i in 0 .. n { assert_eq ! (segtree . get (i) , base [i]) ; } for i in 0 ..= n { for j in i ..= n { assert_eq ! (segtree . prod (i , j) , base [i .. j] . iter () . max () . copied () . unwrap_or (i32 :: min_value ())) ; } } assert_eq ! (segtree . all_prod () , base . iter () . max () . copied () . unwrap_or (i32 :: min_value ())) ; for k in 0 ..= 10 { let f = | & x : & i32 | x < k ; for i in 0 ..= n { assert_eq ! (Some (segtree . max_right (i , f)) , (i ..= n) . filter (|& j | f (& base [i .. j] . iter () . max () . copied () . unwrap_or (i32 :: min_value ()))) . max ()) ; } for j in 0 ..= n { assert_eq ! (Some (segtree . min_left (j , f)) , (0 ..= j) . filter (|& i | f (& base [i .. j] . iter () . max () . copied () . unwrap_or (i32 :: min_value ()))) . min ()) ; } } } } } pub mod string { fn sa_naive < T : Ord > (s : & [T]) -> Vec < usize > { let n = s . len () ; let mut sa : Vec < usize > = (0 .. n) . collect () ; sa . sort_by (| & (mut l) , & (mut r) | { if l == r { return std :: cmp :: Ordering :: Equal ; } while l < n && r < n { if s [l] != s [r] { return s [l] . cmp (& s [r]) ; } l += 1 ; r += 1 ; } if l == n { std :: cmp :: Ordering :: Less } else { std :: cmp :: Ordering :: Greater } }) ; sa } fn sa_doubling (s : & [i32]) -> Vec < usize > { let n = s . len () ; let mut sa : Vec < usize > = (0 .. n) . collect () ; let mut rnk : Vec < i32 > = s . to_vec () ; let mut tmp = vec ! [0 ; n] ; let mut k = 1 ; while k < n { let cmp = | & x : & usize , & y : & usize | { if rnk [x] != rnk [y] { return rnk [x] . cmp (& rnk [y]) ; } let rx = if x + k < n { rnk [x + k] } else { - 1 } ; let ry = if y + k < n { rnk [y + k] } else { - 1 } ; rx . cmp (& ry) } ; sa . sort_by (cmp) ; tmp [sa [0]] = 0 ; for i in 1 .. n { tmp [sa [i]] = tmp [sa [i - 1]] + if cmp (& sa [i - 1] , & sa [i]) == std :: cmp :: Ordering :: Less { 1 } else { 0 } ; } std :: mem :: swap (& mut tmp , & mut rnk) ; k *= 2 ; } sa } trait Threshold { fn threshold_naive () -> usize ; fn threshold_doubling () -> usize ; } enum DefaultThreshold { } impl Threshold for DefaultThreshold { fn threshold_naive () -> usize { 10 } fn threshold_doubling () -> usize { 40 } } # [allow (clippy :: cognitive_complexity)] fn sa_is < T : Threshold > (s : & [usize] , upper : usize) -> Vec < usize > { let n = s . len () ; match n { 0 => return vec ! [] , 1 => return vec ! [0] , 2 => return if s [0] < s [1] { vec ! [0 , 1] } else { vec ! [1 , 0] } , _ => () , } if n < T :: threshold_naive () { return sa_naive (s) ; } if n < T :: threshold_doubling () { let s : Vec < i32 > = s . iter () . map (| & x | x as i32) . collect () ; return sa_doubling (& s) ; } let mut sa = vec ! [0 ; n] ; let mut ls = vec ! [false ; n] ; for i in (0 .. n - 1) . rev () { ls [i] = if s [i] == s [i + 1] { ls [i + 1] } else { s [i] < s [i + 1] } ; } let mut sum_l = vec ! [0 ; upper + 1] ; let mut sum_s = vec ! [0 ; upper + 1] ; for i in 0 .. n { if ! ls [i] { sum_s [s [i]] += 1 ; } else { sum_l [s [i] + 1] += 1 ; } } for i in 0 ..= upper { sum_s [i] += sum_l [i] ; if i < upper { sum_l [i + 1] += sum_s [i] ; } } let induce = | sa : & mut [usize] , lms : & [usize] | { for elem in sa . iter_mut () { * elem = 0 ; } let mut buf = sum_s . clone () ; for & d in lms { if d == n { continue ; } let old = buf [s [d]] ; buf [s [d]] += 1 ; sa [old] = d + 1 ; } buf . copy_from_slice (& sum_l) ; let old = buf [s [n - 1]] ; buf [s [n - 1]] += 1 ; sa [old] = n ; for i in 0 .. n { let v = sa [i] ; if v >= 2 && ! ls [v - 2] { let old = buf [s [v - 2]] ; buf [s [v - 2]] += 1 ; sa [old] = v - 1 ; } } buf . copy_from_slice (& sum_l) ; for i in (0 .. n) . rev () { let v = sa [i] ; if v >= 2 && ls [v - 2] { buf [s [v - 2] + 1] -= 1 ; sa [buf [s [v - 2] + 1]] = v - 1 ; } } } ; let mut lms_map = vec ! [0 ; n + 1] ; let mut m = 0 ; for i in 1 .. n { if ! ls [i - 1] && ls [i] { lms_map [i] = m + 1 ; m += 1 ; } } let mut lms = Vec :: with_capacity (m) ; for i in 1 .. n { if ! ls [i - 1] && ls [i] { lms . push (i) ; } } assert_eq ! (lms . len () , m) ; induce (& mut sa , & lms) ; if m > 0 { let mut sorted_lms = Vec :: with_capacity (m) ; for & v in & sa { if lms_map [v - 1] != 0 { sorted_lms . push (v - 1) ; } } let mut rec_s = vec ! [0 ; m] ; let mut rec_upper = 0 ; rec_s [lms_map [sorted_lms [0]] - 1] = 0 ; for i in 1 .. m { let mut l = sorted_lms [i - 1] ; let mut r = sorted_lms [i] ; let end_l = if lms_map [l] < m { lms [lms_map [l]] } else { n } ; let end_r = if lms_map [r] < m { lms [lms_map [r]] } else { n } ; let same = if end_l - l != end_r - r { false } else { while l < end_l { if s [l] != s [r] { break ; } l += 1 ; r += 1 ; } l != n && s [l] == s [r] } ; if ! same { rec_upper += 1 ; } rec_s [lms_map [sorted_lms [i]] - 1] = rec_upper ; } let rec_sa = sa_is :: < T > (& rec_s , rec_upper) ; for i in 0 .. m { sorted_lms [i] = lms [rec_sa [i]] ; } induce (& mut sa , & mut sorted_lms) ; } for elem in sa . iter_mut () { * elem -= 1 ; } sa } fn sa_is_i32 < T : Threshold > (s : & [i32] , upper : i32) -> Vec < usize > { let s : Vec < usize > = s . iter () . map (| & x | x as usize) . collect () ; sa_is :: < T > (& s , upper as usize) } pub fn suffix_array_manual (s : & [i32] , upper : i32) -> Vec < usize > { assert ! (upper >= 0) ; for & elem in s { assert ! (0 <= elem && elem <= upper) ; } sa_is_i32 :: < DefaultThreshold > (s , upper) } pub fn suffix_array_arbitrary < T : Ord > (s : & [T]) -> Vec < usize > { let n = s . len () ; let mut idx : Vec < usize > = (0 .. n) . collect () ; idx . sort_by_key (| & i | & s [i]) ; let mut s2 = vec ! [0 ; n] ; let mut now = 0 ; for i in 0 .. n { if i > 0 && s [idx [i - 1]] != s [idx [i]] { now += 1 ; } s2 [idx [i]] = now ; } sa_is_i32 :: < DefaultThreshold > (& s2 , now) } pub fn suffix_array (s : & str) -> Vec < usize > { let s2 : Vec < usize > = s . bytes () . map (| x | x as usize) . collect () ; sa_is :: < DefaultThreshold > (& s2 , 255) } pub fn lcp_array_arbitrary < T : Ord > (s : & [T] , sa : & [usize]) -> Vec < usize > { let n = s . len () ; assert ! (n >= 1) ; let mut rnk = vec ! [0 ; n] ; for i in 0 .. n { rnk [sa [i]] = i ; } let mut lcp = vec ! [0 ; n - 1] ; let mut h = 0 ; for i in 0 .. n - 1 { if h > 0 { h -= 1 ; } if rnk [i] == 0 { continue ; } let j = sa [rnk [i] - 1] ; while j + h < n && i + h < n { if s [j + h] != s [i + h] { break ; } h += 1 ; } lcp [rnk [i] - 1] = h ; } lcp } pub fn lcp_array (s : & str , sa : & [usize]) -> Vec < usize > { let s : & [u8] = s . as_bytes () ; lcp_array_arbitrary (s , sa) } pub fn z_algorithm_arbitrary < T : Ord > (s : & [T]) -> Vec < usize > { let n = s . len () ; if n == 0 { return vec ! [] ; } let mut z = vec ! [0 ; n] ; z [0] = 0 ; let mut j = 0 ; for i in 1 .. n { let mut k = if j + z [j] <= i { 0 } else { std :: cmp :: min (j + z [j] - i , z [i - j]) } ; while i + k < n && s [k] == s [i + k] { k += 1 ; } z [i] = k ; if j + z [j] < i + z [i] { j = i ; } } z [0] = n ; z } pub fn z_algorithm (s : & str) -> Vec < usize > { let s : & [u8] = s . as_bytes () ; z_algorithm_arbitrary (s) } # [cfg (test)] mod tests { use super :: * ; enum ZeroThreshold { } impl Threshold for ZeroThreshold { fn threshold_naive () -> usize { 0 } fn threshold_doubling () -> usize { 0 } } fn verify_all (str : & str , expected_array : & [usize]) { let array : Vec < i32 > = str . bytes () . map (| x | x as i32) . collect () ; let sa = sa_doubling (& array) ; assert_eq ! (sa , expected_array) ; let sa_naive = sa_naive (& array) ; assert_eq ! (sa_naive , expected_array) ; let sa_is = sa_is_i32 :: < ZeroThreshold > (& array , 255) ; assert_eq ! (sa_is , expected_array) ; let sa_str = suffix_array (str) ; assert_eq ! (sa_str , expected_array) ; } # [test] fn test_sa_0 () { let array = vec ! [0 , 1 , 2 , 3 , 4] ; let sa = sa_doubling (& array) ; assert_eq ! (sa , vec ! [0 , 1 , 2 , 3 , 4]) ; } # [test] fn test_sa_1 () { let str = "abracadabra" ; verify_all (str , & [10 , 7 , 0 , 3 , 5 , 8 , 1 , 4 , 6 , 9 , 2]) ; } # [test] fn test_sa_2 () { let str = "mmiissiissiippii" ; verify_all (str , & [15 , 14 , 10 , 6 , 2 , 11 , 7 , 3 , 1 , 0 , 13 , 12 , 9 , 5 , 8 , 4]) ; } # [test] fn test_lcp_0 () { let str = "abracadabra" ; let sa = suffix_array (str) ; let lcp = lcp_array (str , & sa) ; assert_eq ! (lcp , & [1 , 4 , 1 , 1 , 0 , 3 , 0 , 0 , 0 , 2]) ; } # [test] fn test_lcp_1 () { let str = "mmiissiissiippii" ; let sa = suffix_array (str) ; let lcp = lcp_array (str , & sa) ; assert_eq ! (lcp , & [1 , 2 , 2 , 6 , 1 , 1 , 5 , 0 , 1 , 0 , 1 , 0 , 3 , 1 , 4]) ; } # [test] fn test_z_0 () { let str = "abracadabra" ; let lcp = z_algorithm (str) ; assert_eq ! (lcp , & [11 , 0 , 0 , 1 , 0 , 1 , 0 , 4 , 0 , 0 , 1]) ; } # [test] fn test_z_1 () { let str = "ababababa" ; let lcp = z_algorithm (str) ; assert_eq ! (lcp , & [9 , 0 , 7 , 0 , 5 , 0 , 3 , 0 , 1]) ; } } } pub mod twosat { use super :: internal_scc ; pub struct TwoSat { n : usize , scc : internal_scc :: SccGraph , answer : Vec < bool > , } impl TwoSat { pub fn new (n : usize) -> Self { TwoSat { n , answer : vec ! [false ; n] , scc : internal_scc :: SccGraph :: new (2 * n) , } } pub fn add_clause (& mut self , i : usize , f : bool , j : usize , g : bool) { assert ! (i < self . n && j < self . n) ; self . scc . add_edge (2 * i + ! f as usize , 2 * j + g as usize) ; self . scc . add_edge (2 * j + ! g as usize , 2 * i + f as usize) ; } pub fn satisfiable (& mut self) -> bool { let id = self . scc . scc_ids () . 1 ; for i in 0 .. self . n { if id [2 * i] == id [2 * i + 1] { return false ; } self . answer [i] = id [2 * i] < id [2 * i + 1] ; } true } pub fn answer (& self) -> & [bool] { & self . answer } } # [cfg (test)] mod tests { # ! [allow (clippy :: many_single_char_names)] use super :: * ; # [test] fn solve_alpc_h_sample1 () { let (n , d) = (3 , 2) ; let x = [1 , 2 , 0i32] ; let y = [4 , 5 , 6] ; let mut t = TwoSat :: new (n) ; for i in 0 .. n { for j in i + 1 .. n { if (x [i] - x [j]) . abs () < d { t . add_clause (i , false , j , false) ; } if (x [i] - y [j]) . abs () < d { t . add_clause (i , false , j , true) ; } if (y [i] - x [j]) . abs () < d { t . add_clause (i , true , j , false) ; } if (y [i] - y [j]) . abs () < d { t . add_clause (i , true , j , true) ; } } } assert ! (t . satisfiable ()) ; let answer = t . answer () ; let mut res = vec ! [] ; for (i , & v) in answer . iter () . enumerate () { if v { res . push (x [i]) } else { res . push (y [i]) ; } } res . sort () ; let mut min_distance = i32 :: max_value () ; for i in 1 .. res . len () { min_distance = std :: cmp :: min (min_distance , res [i] - res [i - 1]) ; } assert ! (min_distance >= d) ; } # [test] fn solve_alpc_h_sample2 () { let (n , d) = (3 , 3) ; let x = [1 , 2 , 0i32] ; let y = [4 , 5 , 6] ; let mut t = TwoSat :: new (n) ; for i in 0 .. n { for j in i + 1 .. n { if (x [i] - x [j]) . abs () < d { t . add_clause (i , false , j , false) ; } if (x [i] - y [j]) . abs () < d { t . add_clause (i , false , j , true) ; } if (y [i] - x [j]) . abs () < d { t . add_clause (i , true , j , false) ; } if (y [i] - y [j]) . abs () < d { t . add_clause (i , true , j , true) ; } } } assert ! (! t . satisfiable ()) ; } } } pub (crate) mod internal_bit { # [allow (dead_code)] pub (crate) fn ceil_pow2 (n : u32) -> u32 { 32 - n . saturating_sub (1) . leading_zeros () } # [cfg (test)] mod tests { # [test] fn ceil_pow2 () { assert_eq ! (0 , super :: ceil_pow2 (0)) ; assert_eq ! (0 , super :: ceil_pow2 (1)) ; assert_eq ! (1 , super :: ceil_pow2 (2)) ; assert_eq ! (2 , super :: ceil_pow2 (3)) ; assert_eq ! (2 , super :: ceil_pow2 (4)) ; assert_eq ! (3 , super :: ceil_pow2 (5)) ; assert_eq ! (3 , super :: ceil_pow2 (6)) ; assert_eq ! (3 , super :: ceil_pow2 (7)) ; assert_eq ! (3 , super :: ceil_pow2 (8)) ; assert_eq ! (4 , super :: ceil_pow2 (9)) ; assert_eq ! (30 , super :: ceil_pow2 (1 << 30)) ; assert_eq ! (31 , super :: ceil_pow2 ((1 << 30) + 1)) ; assert_eq ! (32 , super :: ceil_pow2 (u32 :: max_value ())) ; } } } pub (crate) mod internal_math { use std :: mem :: swap ; # [doc = " # Arguments"] # [doc = " * `m` `1 <= m`"] # [doc = ""] # [doc = " # Returns"] # [doc = " x mod m"] pub (crate) fn safe_mod (mut x : i64 , m : i64) -> i64 { x %= m ; if x < 0 { x += m ; } x } # [doc = " Fast modular by barrett reduction"] # [doc = " Reference: https://en.wikipedia.org/wiki/Barrett_reduction"] # [doc = " NOTE: reconsider after Ice Lake"] pub (crate) struct Barrett { pub (crate) _m : u32 , pub (crate) im : u64 , } impl Barrett { # [doc = " # Arguments"] # [doc = " * `m` `1 <= m`"] # [doc = " (Note: `m <= 2^31` should also hold, which is undocumented in the original library."] # [doc = " See the [pull reqeust commment](https://github.com/rust-lang-ja/ac-library-rs/pull/3#discussion_r484661007)"] # [doc = " for more details.)"] pub (crate) fn new (m : u32) -> Barrett { Barrett { _m : m , im : (- 1i64 as u64 / m as u64) . wrapping_add (1) , } } # [doc = " # Returns"] # [doc = " `m`"] pub (crate) fn umod (& self) -> u32 { self . _m } # [doc = " # Parameters"] # [doc = " * `a` `0 <= a < m`"] # [doc = " * `b` `0 <= b < m`"] # [doc = ""] # [doc = " # Returns"] # [doc = " a * b % m"] # [allow (clippy :: many_single_char_names)] pub (crate) fn mul (& self , a : u32 , b : u32) -> u32 { let mut z = a as u64 ; z *= b as u64 ; let x = (((z as u128) * (self . im as u128)) >> 64) as u64 ; let mut v = z . wrapping_sub (x . wrapping_mul (self . _m as u64)) as u32 ; if self . _m <= v { v = v . wrapping_add (self . _m) ; } v } } # [doc = " # Parameters"] # [doc = " * `n` `0 <= n`"] # [doc = " * `m` `1 <= m`"] # [doc = ""] # [doc = " # Returns"] # [doc = " `(x ** n) % m`"] # [allow (clippy :: many_single_char_names)] pub (crate) fn pow_mod (x : i64 , mut n : i64 , m : i32) -> i64 { if m == 1 { return 0 ; } let _m = m as u32 ; let mut r : u64 = 1 ; let mut y : u64 = safe_mod (x , m as i64) as u64 ; while n != 0 { if (n & 1) > 0 { r = (r * y) % (_m as u64) ; } y = (y * y) % (_m as u64) ; n >>= 1 ; } r as i64 } # [doc = " Reference:"] # [doc = " M. Forisek and J. Jancina,"] # [doc = " Fast Primality Testing for Integers That Fit into a Machine Word"] # [doc = ""] # [doc = " # Parameters"] # [doc = " * `n` `0 <= n`"] pub (crate) fn is_prime (n : i32) -> bool { let n = n as i64 ; match n { _ if n <= 1 => return false , 2 | 7 | 61 => return true , _ if n % 2 == 0 => return false , _ => { } } let mut d = n - 1 ; while d % 2 == 0 { d /= 2 ; } for & a in & [2 , 7 , 61] { let mut t = d ; let mut y = pow_mod (a , t , n as i32) ; while t != n - 1 && y != 1 && y != n - 1 { y = y * y % n ; t <<= 1 ; } if y != n - 1 && t % 2 == 0 { return false ; } } true } # [doc = " # Parameters"] # [doc = " * `b` `1 <= b`"] # [doc = ""] # [doc = " # Returns"] # [doc = " (g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g"] # [allow (clippy :: many_single_char_names)] pub (crate) fn inv_gcd (a : i64 , b : i64) -> (i64 , i64) { let a = safe_mod (a , b) ; if a == 0 { return (b , 0) ; } let mut s = b ; let mut t = a ; let mut m0 = 0 ; let mut m1 = 1 ; while t != 0 { let u = s / t ; s -= t * u ; m0 -= m1 * u ; swap (& mut s , & mut t) ; swap (& mut m0 , & mut m1) ; } if m0 < 0 { m0 += b / s ; } (s , m0) } # [doc = " Compile time (currently not) primitive root"] # [doc = " @param m must be prime"] # [doc = " @return primitive root (and minimum in now)"] pub (crate) fn primitive_root (m : i32) -> i32 { match m { 2 => return 1 , 167_772_161 => return 3 , 469_762_049 => return 3 , 754_974_721 => return 11 , 998_244_353 => return 3 , _ => { } } let mut divs = [0 ; 20] ; divs [0] = 2 ; let mut cnt = 1 ; let mut x = (m - 1) / 2 ; while x % 2 == 0 { x /= 2 ; } for i in (3 .. std :: i32 :: MAX) . step_by (2) { if i as i64 * i as i64 > x as i64 { break ; } if x % i == 0 { divs [cnt] = i ; cnt += 1 ; while x % i == 0 { x /= i ; } } } if x > 1 { divs [cnt] = x ; cnt += 1 ; } let mut g = 2 ; loop { if (0 .. cnt) . all (| i | pow_mod (g , ((m - 1) / divs [i]) as i64 , m) != 1) { break g as i32 ; } g += 1 ; } } # [cfg (test)] mod tests { # ! [allow (clippy :: unreadable_literal)] # ! [allow (clippy :: cognitive_complexity)] use super :: super :: internal_math :: { inv_gcd , is_prime , pow_mod , primitive_root , safe_mod , Barrett , } ; use std :: collections :: HashSet ; # [test] fn test_safe_mod () { assert_eq ! (safe_mod (0 , 3) , 0) ; assert_eq ! (safe_mod (1 , 3) , 1) ; assert_eq ! (safe_mod (2 , 3) , 2) ; assert_eq ! (safe_mod (3 , 3) , 0) ; assert_eq ! (safe_mod (4 , 3) , 1) ; assert_eq ! (safe_mod (5 , 3) , 2) ; assert_eq ! (safe_mod (73 , 11) , 7) ; assert_eq ! (safe_mod (2306249155046129918 , 6620319213327) , 1374210749525) ; assert_eq ! (safe_mod (- 1 , 3) , 2) ; assert_eq ! (safe_mod (- 2 , 3) , 1) ; assert_eq ! (safe_mod (- 3 , 3) , 0) ; assert_eq ! (safe_mod (- 4 , 3) , 2) ; assert_eq ! (safe_mod (- 5 , 3) , 1) ; assert_eq ! (safe_mod (- 7170500492396019511 , 777567337) , 333221848) ; } # [test] fn test_barrett () { let b = Barrett :: new (7) ; assert_eq ! (b . umod () , 7) ; assert_eq ! (b . mul (2 , 3) , 6) ; assert_eq ! (b . mul (4 , 6) , 3) ; assert_eq ! (b . mul (5 , 0) , 0) ; let b = Barrett :: new (998244353) ; assert_eq ! (b . umod () , 998244353) ; assert_eq ! (b . mul (2 , 3) , 6) ; assert_eq ! (b . mul (3141592 , 653589) , 919583920) ; assert_eq ! (b . mul (323846264 , 338327950) , 568012980) ; let b = Barrett :: new (2147483647) ; assert_eq ! (b . umod () , 2147483647) ; assert_eq ! (b . mul (1073741824 , 2147483645) , 2147483646) ; } # [test] fn test_pow_mod () { assert_eq ! (pow_mod (0 , 0 , 1) , 0) ; assert_eq ! (pow_mod (0 , 0 , 3) , 1) ; assert_eq ! (pow_mod (0 , 0 , 723) , 1) ; assert_eq ! (pow_mod (0 , 0 , 998244353) , 1) ; assert_eq ! (pow_mod (0 , 0 , i32 :: max_value ()) , 1) ; assert_eq ! (pow_mod (0 , 1 , 1) , 0) ; assert_eq ! (pow_mod (0 , 1 , 3) , 0) ; assert_eq ! (pow_mod (0 , 1 , 723) , 0) ; assert_eq ! (pow_mod (0 , 1 , 998244353) , 0) ; assert_eq ! (pow_mod (0 , 1 , i32 :: max_value ()) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 1) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 3) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 723) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , 998244353) , 0) ; assert_eq ! (pow_mod (0 , i64 :: max_value () , i32 :: max_value ()) , 0) ; assert_eq ! (pow_mod (1 , 0 , 1) , 0) ; assert_eq ! (pow_mod (1 , 0 , 3) , 1) ; assert_eq ! (pow_mod (1 , 0 , 723) , 1) ; assert_eq ! (pow_mod (1 , 0 , 998244353) , 1) ; assert_eq ! (pow_mod (1 , 0 , i32 :: max_value ()) , 1) ; assert_eq ! (pow_mod (1 , 1 , 1) , 0) ; assert_eq ! (pow_mod (1 , 1 , 3) , 1) ; assert_eq ! (pow_mod (1 , 1 , 723) , 1) ; assert_eq ! (pow_mod (1 , 1 , 998244353) , 1) ; assert_eq ! (pow_mod (1 , 1 , i32 :: max_value ()) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 1) , 0) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 3) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 723) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , 998244353) , 1) ; assert_eq ! (pow_mod (1 , i64 :: max_value () , i32 :: max_value ()) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 1) , 0) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 3) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 723) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , 998244353) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , 0 , i32 :: max_value ()) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 1) , 0) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 3) , 1) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 723) , 640) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , 998244353) , 683296792) ; assert_eq ! (pow_mod (i64 :: max_value () , i64 :: max_value () , i32 :: max_value ()) , 1) ; assert_eq ! (pow_mod (2 , 3 , 1_000_000_007) , 8) ; assert_eq ! (pow_mod (5 , 7 , 1_000_000_007) , 78125) ; assert_eq ! (pow_mod (123 , 456 , 1_000_000_007) , 565291922) ; } # [test] fn test_is_prime () { assert ! (! is_prime (0)) ; assert ! (! is_prime (1)) ; assert ! (is_prime (2)) ; assert ! (is_prime (3)) ; assert ! (! is_prime (4)) ; assert ! (is_prime (5)) ; assert ! (! is_prime (6)) ; assert ! (is_prime (7)) ; assert ! (! is_prime (8)) ; assert ! (! is_prime (9)) ; assert ! (! is_prime (57)) ; assert ! (! is_prime (58)) ; assert ! (is_prime (59)) ; assert ! (! is_prime (60)) ; assert ! (is_prime (61)) ; assert ! (! is_prime (62)) ; assert ! (! is_prime (701928443)) ; assert ! (is_prime (998244353)) ; assert ! (! is_prime (1_000_000_000)) ; assert ! (is_prime (1_000_000_007)) ; assert ! (is_prime (i32 :: max_value ())) ; } # [test] fn test_is_prime_sieve () { let n = 1_000_000 ; let mut prime = vec ! [true ; n] ; prime [0] = false ; prime [1] = false ; for i in 0 .. n { assert_eq ! (prime [i] , is_prime (i as i32)) ; if prime [i] { for j in (2 * i .. n) . step_by (i) { prime [j] = false ; } } } } # [test] fn test_inv_gcd () { for & (a , b , g) in & [(0 , 1 , 1) , (0 , 4 , 4) , (0 , 7 , 7) , (2 , 3 , 1) , (- 2 , 3 , 1) , (4 , 6 , 2) , (- 4 , 6 , 2) , (13 , 23 , 1) , (57 , 81 , 3) , (12345 , 67890 , 15) , (- 3141592 * 6535 , 3141592 * 8979 , 3141592) , (i64 :: max_value () , i64 :: max_value () , i64 :: max_value ()) , (i64 :: min_value () , i64 :: max_value () , 1) ,] { let (g_ , x) = inv_gcd (a , b) ; assert_eq ! (g , g_) ; let b_ = b as i128 ; assert_eq ! (((x as i128 * a as i128) % b_ + b_) % b_ , g as i128 % b_) ; } } # [test] fn test_primitive_root () { for & p in & [2 , 3 , 5 , 7 , 233 , 200003 , 998244353 , 1_000_000_007 , i32 :: max_value () ,] { assert ! (is_prime (p)) ; let g = primitive_root (p) ; if p != 2 { assert_ne ! (g , 1) ; } let q = p - 1 ; for i in (2 .. i32 :: max_value ()) . take_while (| i | i * i <= q) { if q % i != 0 { break ; } for & r in & [i , q / i] { assert_ne ! (pow_mod (g as i64 , r as i64 , p) , 1) ; } } assert_eq ! (pow_mod (g as i64 , q as i64 , p) , 1) ; if p < 1_000_000 { assert_eq ! ((0 .. p - 1) . scan (1 , | i , _ | { * i = * i * g % p ; Some (* i) }) . collect ::< HashSet < _ >> () . len () as i32 , p - 1) ; } } } } } pub (crate) mod internal_queue { # [derive (Default)] pub (crate) struct SimpleQueue < T > { payload : Vec < T > , pos : usize , } impl < T > SimpleQueue < T > { pub (crate) fn reserve (& mut self , n : usize) { if n > self . payload . len () { self . payload . reserve (n - self . payload . len ()) ; } } pub (crate) fn size (& self) -> usize { self . payload . len () - self . pos } pub (crate) fn empty (& self) -> bool { self . pos == self . payload . len () } pub (crate) fn push (& mut self , t : T) { self . payload . push (t) ; } pub (crate) fn front (& self) -> Option < & T > { if self . pos < self . payload . len () { Some (& self . payload [self . pos]) } else { None } } pub (crate) fn clear (& mut self) { self . payload . clear () ; self . pos = 0 ; } pub (crate) fn pop (& mut self) -> Option < & T > { if self . pos < self . payload . len () { self . pos += 1 ; Some (& self . payload [self . pos - 1]) } else { None } } } # [cfg (test)] mod test { use super :: super :: internal_queue :: SimpleQueue ; # [allow (clippy :: cognitive_complexity)] # [test] fn test_simple_queue () { let mut queue = SimpleQueue :: default () ; assert_eq ! (queue . size () , 0) ; assert ! (queue . empty ()) ; assert ! (queue . front () . is_none ()) ; assert ! (queue . pop () . is_none ()) ; queue . push (123) ; assert_eq ! (queue . size () , 1) ; assert ! (! queue . empty ()) ; assert_eq ! (queue . front () , Some (& 123)) ; queue . push (456) ; assert_eq ! (queue . size () , 2) ; assert ! (! queue . empty ()) ; assert_eq ! (queue . front () , Some (& 123)) ; assert_eq ! (queue . pop () , Some (& 123)) ; assert_eq ! (queue . size () , 1) ; assert ! (! queue . empty ()) ; assert_eq ! (queue . front () , Some (& 456)) ; queue . push (789) ; queue . push (789) ; queue . push (456) ; queue . push (456) ; assert_eq ! (queue . size () , 5) ; assert ! (! queue . empty ()) ; assert_eq ! (queue . front () , Some (& 456)) ; assert_eq ! (queue . pop () , Some (& 456)) ; assert_eq ! (queue . size () , 4) ; assert ! (! queue . empty ()) ; assert_eq ! (queue . front () , Some (& 789)) ; queue . clear () ; assert_eq ! (queue . size () , 0) ; assert ! (queue . empty ()) ; assert ! (queue . front () . is_none ()) ; assert ! (queue . pop () . is_none ()) ; } } } pub (crate) mod internal_scc { pub struct Csr < E > { start : Vec < usize > , elist : Vec < E > , } impl < E > Csr < E > where E : Copy , { pub fn new (n : usize , edges : & [(usize , E)] , init : E) -> Self { let mut csr = Csr { start : vec ! [0 ; n + 1] , elist : vec ! [init ; edges . len ()] , } ; for e in edges . iter () { csr . start [e . 0 + 1] += 1 ; } for i in 1 ..= n { csr . start [i] += csr . start [i - 1] ; } let mut counter = csr . start . clone () ; for e in edges . iter () { csr . elist [counter [e . 0]] = e . 1 ; counter [e . 0] += 1 ; } csr } } # [derive (Copy , Clone)] struct _Edge { to : usize , } # [doc = " Reference:"] # [doc = " R. Tarjan,"] # [doc = " Depth-First Search and Linear Graph Algorithms"] pub struct SccGraph { n : usize , edges : Vec < (usize , _Edge) > , } impl SccGraph { pub fn new (n : usize) -> Self { SccGraph { n , edges : vec ! [] } } pub fn num_vertices (& self) -> usize { self . n } pub fn add_edge (& mut self , from : usize , to : usize) { self . edges . push ((from , _Edge { to })) ; } # [doc = " return pair of (# of scc, scc id)"] pub fn scc_ids (& self) -> (usize , Vec < usize >) { struct _Env { g : Csr < _Edge > , now_ord : usize , group_num : usize , visited : Vec < usize > , low : Vec < usize > , ord : Vec < Option < usize > > , ids : Vec < usize > , } let mut env = _Env { g : Csr :: new (self . n , & self . edges , _Edge { to : 0 }) , now_ord : 0 , group_num : 0 , visited : Vec :: with_capacity (self . n) , low : vec ! [0 ; self . n] , ord : vec ! [None ; self . n] , ids : vec ! [0 ; self . n] , } ; fn dfs (v : usize , n : usize , env : & mut _Env) { env . low [v] = env . now_ord ; env . ord [v] = Some (env . now_ord) ; env . now_ord += 1 ; env . visited . push (v) ; for i in env . g . start [v] .. env . g . start [v + 1] { let to = env . g . elist [i] . to ; if let Some (x) = env . ord [to] { env . low [v] = std :: cmp :: min (env . low [v] , x) ; } else { dfs (to , n , env) ; env . low [v] = std :: cmp :: min (env . low [v] , env . low [to]) ; } } if env . low [v] == env . ord [v] . unwrap () { loop { let u = * env . visited . last () . unwrap () ; env . visited . pop () ; env . ord [u] = Some (n) ; env . ids [u] = env . group_num ; if u == v { break ; } } env . group_num += 1 ; } } for i in 0 .. self . n { if env . ord [i] . is_none () { dfs (i , self . n , & mut env) ; } } for x in env . ids . iter_mut () { * x = env . group_num - 1 - * x ; } (env . group_num , env . ids) } pub fn scc (& self) -> Vec < Vec < usize > > { let ids = self . scc_ids () ; let group_num = ids . 0 ; let mut counts = vec ! [0usize ; group_num] ; for & x in ids . 1 . iter () { counts [x] += 1 ; } let mut groups : Vec < Vec < usize > > = (0 .. ids . 0) . map (| _ | vec ! []) . collect () ; for i in 0 .. group_num { groups [i] . reserve (counts [i]) ; } for i in 0 .. self . n { groups [ids . 1 [i]] . push (i) ; } groups } } } pub (crate) mod internal_type_traits { use std :: { fmt , iter :: { Product , Sum } , ops :: { Add , AddAssign , BitAnd , BitAndAssign , BitOr , BitOrAssign , BitXor , BitXorAssign , Div , DivAssign , Mul , MulAssign , Not , Rem , RemAssign , Shl , ShlAssign , Shr , ShrAssign , Sub , SubAssign , } , } ; # [doc = " Corresponds to `std::is_integral` in C++."] pub trait Integral : 'static + Send + Sync + Copy + Ord + Not < Output = Self > + Add < Output = Self > + Sub < Output = Self > + Mul < Output = Self > + Div < Output = Self > + Rem < Output = Self > + AddAssign + SubAssign + MulAssign + DivAssign + RemAssign + Sum + Product + BitOr < Output = Self > + BitAnd < Output = Self > + BitXor < Output = Self > + BitOrAssign + BitAndAssign + BitXorAssign + Shl < Output = Self > + Shr < Output = Self > + ShlAssign + ShrAssign + fmt :: Display + fmt :: Debug + fmt :: Binary + fmt :: Octal + Zero + One + BoundedBelow + BoundedAbove { } # [doc = " Class that has additive identity element"] pub trait Zero { # [doc = " The additive identity element"] fn zero () -> Self ; } # [doc = " Class that has multiplicative identity element"] pub trait One { # [doc = " The multiplicative identity element"] fn one () -> Self ; } pub trait BoundedBelow { fn min_value () -> Self ; } pub trait BoundedAbove { fn max_value () -> Self ; } macro_rules ! impl_integral { ($ ($ ty : ty) ,*) => { $ (impl Zero for $ ty { # [inline] fn zero () -> Self { 0 } } impl One for $ ty { # [inline] fn one () -> Self { 1 } } impl BoundedBelow for $ ty { # [inline] fn min_value () -> Self { Self :: min_value () } } impl BoundedAbove for $ ty { # [inline] fn max_value () -> Self { Self :: max_value () } } impl Integral for $ ty { }) * } ; } impl_integral ! (i8 , i16 , i32 , i64 , i128 , isize , u8 , u16 , u32 , u64 , u128 , usize) ; } pub use convolution :: { convolution , convolution_i64 } ; pub use dsu :: Dsu ; pub use fenwicktree :: FenwickTree ; pub use lazysegtree :: { LazySegtree , MapMonoid } ; pub use math :: { crt , floor_sum , inv_mod , pow_mod } ; pub use maxflow :: { Edge , MfGraph } ; pub use mincostflow :: MinCostFlowGraph ; pub use modint :: { Barrett , ButterflyCache , DefaultId , DynamicModInt , Id , Mod1000000007 , Mod998244353 , ModInt , ModInt1000000007 , ModInt998244353 , Modulus , RemEuclidU32 , StaticModInt , } ; pub use scc :: SccGraph ; pub use segtree :: { Additive , Max , Min , Monoid , Multiplicative , Segtree } ; pub use string :: { lcp_array , lcp_array_arbitrary , suffix_array , suffix_array_arbitrary , suffix_array_manual , z_algorithm , z_algorithm_arbitrary , } ; pub use twosat :: TwoSat ; }mod ascii { # ! [cfg_attr (rustfmt , rustfmt_skip)] # ! [doc = " A library that provides ASCII-only string and character types, equivalent to the `char`, `str`"] # ! [doc = " and `String` types in the standard library."] # ! [doc = ""] # ! [doc = " Please refer to the readme file to learn about the different feature modes of this crate."] # ! [doc = ""] # ! [doc = " # Minimum supported Rust version"] # ! [doc = ""] # ! [doc = " The minimum Rust version for 1.0.\\* releases is 1.33.0."] # ! [doc = " Later 1.y.0 releases might require newer Rust versions, but the three most"] # ! [doc = " recent stable releases at the time of publishing will always be supported.  "] # ! [doc = " For example this means that if the current stable Rust version is 1.38 when"] # ! [doc = " ascii 1.1.0 is released, then ascii 1.1.* will not require a newer"] # ! [doc = " Rust version than 1.36."] # ! [doc = ""] # ! [doc = " # History"] # ! [doc = ""] # ! [doc = " This package included the Ascii types that were removed from the Rust standard library by the"] # ! [doc = " 2014-12 [reform of the `std::ascii` module](https://github.com/rust-lang/rfcs/pull/486). The"] # ! [doc = " API changed significantly since then."] # ! [cfg_attr (not (feature = "std") , no_std)] # ! [allow (clippy :: trivially_copy_pass_by_ref)] # [cfg (feature = "std")] extern crate core ; # [cfg (feature = "serde")] extern crate serde ; # [cfg (all (test , feature = "serde_test"))] extern crate serde_test ; mod ascii_char { use core :: mem ; use core :: cmp :: Ordering ; use core :: { fmt , char } ; # [cfg (feature = "std")] use std :: error :: Error ; # [allow (non_camel_case_types)] # [doc = " An ASCII character. It wraps a `u8`, with the highest bit always zero."] # [derive (Clone , PartialEq , PartialOrd , Ord , Eq , Hash , Copy)] # [repr (u8)] pub enum AsciiChar { # [doc = " `'\\0'`"] Null = 0 , # [doc = " [Start Of Heading](http://en.wikipedia.org/wiki/Start_of_Heading)"] SOH = 1 , # [doc = " [Start Of teXt](http://en.wikipedia.org/wiki/Start_of_Text)"] SOX = 2 , # [doc = " [End of TeXt](http://en.wikipedia.org/wiki/End-of-Text_character)"] ETX = 3 , # [doc = " [End Of Transmission](http://en.wikipedia.org/wiki/End-of-Transmission_character)"] EOT = 4 , # [doc = " [Enquiry](http://en.wikipedia.org/wiki/Enquiry_character)"] ENQ = 5 , # [doc = " [Acknowledgement](http://en.wikipedia.org/wiki/Acknowledge_character)"] ACK = 6 , # [doc = " [bell / alarm / audible](http://en.wikipedia.org/wiki/Bell_character)"] # [doc = ""] # [doc = " `'\\a'` is not recognized by Rust."] Bell = 7 , # [doc = " [Backspace](http://en.wikipedia.org/wiki/Backspace)"] # [doc = ""] # [doc = " `'\\b'` is not recognized by Rust."] BackSpace = 8 , # [doc = " `'\\t'`"] Tab = 9 , # [doc = " `'\\n'`"] LineFeed = 10 , # [doc = " [Vertical tab](http://en.wikipedia.org/wiki/Vertical_Tab)"] # [doc = ""] # [doc = " `'\\v'` is not recognized by Rust."] VT = 11 , # [doc = " [Form Feed](http://en.wikipedia.org/wiki/Form_Feed)"] # [doc = ""] # [doc = " `'\\f'` is not recognized by Rust."] FF = 12 , # [doc = " `'\\r'`"] CarriageReturn = 13 , # [doc = " [Shift In](http://en.wikipedia.org/wiki/Shift_Out_and_Shift_In_characters)"] SI = 14 , # [doc = " [Shift Out](http://en.wikipedia.org/wiki/Shift_Out_and_Shift_In_characters)"] SO = 15 , # [doc = " [Data Link Escape](http://en.wikipedia.org/wiki/Data_Link_Escape)"] DLE = 16 , # [doc = " [Device control 1, often XON](http://en.wikipedia.org/wiki/Device_Control_1)"] DC1 = 17 , # [doc = " Device control 2"] DC2 = 18 , # [doc = " Device control 3, Often XOFF"] DC3 = 19 , # [doc = " Device control 4"] DC4 = 20 , # [doc = " [Negative AcKnowledgement](http://en.wikipedia.org/wiki/Negative-acknowledge_character)"] NAK = 21 , # [doc = " [Synchronous idle](http://en.wikipedia.org/wiki/Synchronous_Idle)"] SYN = 22 , # [doc = " [End of Transmission Block](http://en.wikipedia.org/wiki/End-of-Transmission-Block_character)"] ETB = 23 , # [doc = " [Cancel](http://en.wikipedia.org/wiki/Cancel_character)"] CAN = 24 , # [doc = " [End of Medium](http://en.wikipedia.org/wiki/End_of_Medium)"] EM = 25 , # [doc = " [Substitute](http://en.wikipedia.org/wiki/Substitute_character)"] SUB = 26 , # [doc = " [Escape](http://en.wikipedia.org/wiki/Escape_character)"] # [doc = ""] # [doc = " `'\\e'` is not recognized by Rust."] ESC = 27 , # [doc = " [File Separator](http://en.wikipedia.org/wiki/File_separator)"] FS = 28 , # [doc = " [Group Separator](http://en.wikipedia.org/wiki/Group_separator)"] GS = 29 , # [doc = " [Record Separator](http://en.wikipedia.org/wiki/Record_separator)"] RS = 30 , # [doc = " [Unit Separator](http://en.wikipedia.org/wiki/Unit_separator)"] US = 31 , # [doc = " `' '`"] Space = 32 , # [doc = " `'!'`"] Exclamation = 33 , # [doc = " `'\"'`"] Quotation = 34 , # [doc = " `'#'`"] Hash = 35 , # [doc = " `'$'`"] Dollar = 36 , # [doc = " `'%'`"] Percent = 37 , # [doc = " `'&'`"] Ampersand = 38 , # [doc = " `'\\''`"] Apostrophe = 39 , # [doc = " `'('`"] ParenOpen = 40 , # [doc = " `')'`"] ParenClose = 41 , # [doc = " `'*'`"] Asterisk = 42 , # [doc = " `'+'`"] Plus = 43 , # [doc = " `','`"] Comma = 44 , # [doc = " `'-'`"] Minus = 45 , # [doc = " `'.'`"] Dot = 46 , # [doc = " `'/'`"] Slash = 47 , # [doc = " `'0'`"] _0 = 48 , # [doc = " `'1'`"] _1 = 49 , # [doc = " `'2'`"] _2 = 50 , # [doc = " `'3'`"] _3 = 51 , # [doc = " `'4'`"] _4 = 52 , # [doc = " `'5'`"] _5 = 53 , # [doc = " `'6'`"] _6 = 54 , # [doc = " `'7'`"] _7 = 55 , # [doc = " `'8'`"] _8 = 56 , # [doc = " `'9'`"] _9 = 57 , # [doc = " `':'`"] Colon = 58 , # [doc = " `';'`"] Semicolon = 59 , # [doc = " `'<'`"] LessThan = 60 , # [doc = " `'='`"] Equal = 61 , # [doc = " `'>'`"] GreaterThan = 62 , # [doc = " `'?'`"] Question = 63 , # [doc = " `'@'`"] At = 64 , # [doc = " `'A'`"] A = 65 , # [doc = " `'B'`"] B = 66 , # [doc = " `'C'`"] C = 67 , # [doc = " `'D'`"] D = 68 , # [doc = " `'E'`"] E = 69 , # [doc = " `'F'`"] F = 70 , # [doc = " `'G'`"] G = 71 , # [doc = " `'H'`"] H = 72 , # [doc = " `'I'`"] I = 73 , # [doc = " `'J'`"] J = 74 , # [doc = " `'K'`"] K = 75 , # [doc = " `'L'`"] L = 76 , # [doc = " `'M'`"] M = 77 , # [doc = " `'N'`"] N = 78 , # [doc = " `'O'`"] O = 79 , # [doc = " `'P'`"] P = 80 , # [doc = " `'Q'`"] Q = 81 , # [doc = " `'R'`"] R = 82 , # [doc = " `'S'`"] S = 83 , # [doc = " `'T'`"] T = 84 , # [doc = " `'U'`"] U = 85 , # [doc = " `'V'`"] V = 86 , # [doc = " `'W'`"] W = 87 , # [doc = " `'X'`"] X = 88 , # [doc = " `'Y'`"] Y = 89 , # [doc = " `'Z'`"] Z = 90 , # [doc = " `'['`"] BracketOpen = 91 , # [doc = " `'\\'`"] BackSlash = 92 , # [doc = " `']'`"] BracketClose = 93 , # [doc = " `'_'`"] Caret = 94 , # [doc = " `'_'`"] UnderScore = 95 , # [doc = " `'`'`"] Grave = 96 , # [doc = " `'a'`"] a = 97 , # [doc = " `'b'`"] b = 98 , # [doc = " `'c'`"] c = 99 , # [doc = " `'d'`"] d = 100 , # [doc = " `'e'`"] e = 101 , # [doc = " `'f'`"] f = 102 , # [doc = " `'g'`"] g = 103 , # [doc = " `'h'`"] h = 104 , # [doc = " `'i'`"] i = 105 , # [doc = " `'j'`"] j = 106 , # [doc = " `'k'`"] k = 107 , # [doc = " `'l'`"] l = 108 , # [doc = " `'m'`"] m = 109 , # [doc = " `'n'`"] n = 110 , # [doc = " `'o'`"] o = 111 , # [doc = " `'p'`"] p = 112 , # [doc = " `'q'`"] q = 113 , # [doc = " `'r'`"] r = 114 , # [doc = " `'s'`"] s = 115 , # [doc = " `'t'`"] t = 116 , # [doc = " `'u'`"] u = 117 , # [doc = " `'v'`"] v = 118 , # [doc = " `'w'`"] w = 119 , # [doc = " `'x'`"] x = 120 , # [doc = " `'y'`"] y = 121 , # [doc = " `'z'`"] z = 122 , # [doc = " `'{'`"] CurlyBraceOpen = 123 , # [doc = " `'|'`"] VerticalBar = 124 , # [doc = " `'}'`"] CurlyBraceClose = 125 , # [doc = " `'~'`"] Tilde = 126 , # [doc = " [Delete](http://en.wikipedia.org/wiki/Delete_character)"] DEL = 127 , } impl AsciiChar { # [doc = " Constructs an ASCII character from a `u8`, `char` or other character type."] # [doc = ""] # [doc = " # Failure"] # [doc = " Returns `Err(())` if the character can't be ASCII encoded."] # [doc = ""] # [doc = " # Example"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " let a = AsciiChar::from_ascii('g').unwrap();"] # [doc = " assert_eq!(a.as_char(), 'g');"] # [doc = " ```"] # [inline] pub fn from_ascii < C : ToAsciiChar > (ch : C) -> Result < Self , ToAsciiCharError > { ch . to_ascii_char () } # [doc = " Create an `AsciiChar` from a `char`, panicking if it's not ASCII."] # [doc = ""] # [doc = " This function is intended for creating `AsciiChar` values from"] # [doc = " hardcoded known-good character literals such as `'K'`, `'-'` or `'\\0'`,"] # [doc = " and for use in `const` contexts."] # [doc = " Use [`from_ascii()`](#method.from_ascii) instead when you're not"] # [doc = " certain the character is ASCII."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('@'), AsciiChar::At);"] # [doc = " assert_eq!(AsciiChar::new('C').as_char(), 'C');"] # [doc = " ```"] # [doc = ""] # [doc = " In a constant:"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " const SPLIT_ON: AsciiChar = AsciiChar::new(',');"] # [doc = " ```"] # [doc = ""] # [doc = " This will not compile:"] # [doc = " ```compile_fail"] # [doc = " # use ascii::AsciiChar;"] # [doc = " const BAD: AsciiChar = AsciiChar::new('');"] # [doc = " ```"] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This function will panic if passed a non-ASCII character."] # [doc = ""] # [doc = " The panic message might not be the most descriptive due to the"] # [doc = " current limitations of `const fn`."] pub const fn new (ch : char) -> AsciiChar { use AsciiChar :: * ; const ALL : [AsciiChar ; 128] = [Null , SOH , SOX , ETX , EOT , ENQ , ACK , Bell , BackSpace , Tab , LineFeed , VT , FF , CarriageReturn , SI , SO , DLE , DC1 , DC2 , DC3 , DC4 , NAK , SYN , ETB , CAN , EM , SUB , ESC , FS , GS , RS , US , Space , Exclamation , Quotation , Hash , Dollar , Percent , Ampersand , Apostrophe , ParenOpen , ParenClose , Asterisk , Plus , Comma , Minus , Dot , Slash , _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , Colon , Semicolon , LessThan , Equal , GreaterThan , Question , At , A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z , BracketOpen , BackSlash , BracketClose , Caret , UnderScore , Grave , a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z , CurlyBraceOpen , VerticalBar , CurlyBraceClose , Tilde , DEL ,] ; ALL [ch as usize] } # [doc = " Constructs an ASCII character from a `u8`, `char` or other character"] # [doc = " type without any checks."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " This function is very unsafe as it can create invalid enum"] # [doc = " discriminants, which instantly creates undefined behavior."] # [doc = " (`let _ = AsciiChar::from_ascii_unchecked(200);` alone is UB)."] # [doc = ""] # [doc = " The undefined behavior is not just theoretical either:"] # [doc = " For example, `[0; 128][AsciiChar::from_ascii_unchecked(255) as u8 as usize] = 0`"] # [doc = " might not panic, creating a buffer overflow,"] # [doc = " and `Some(AsciiChar::from_ascii_unchecked(128))` might be `None`."] # [inline] pub unsafe fn from_ascii_unchecked (ch : u8) -> Self { ch . to_ascii_char_unchecked () } # [doc = " Converts an ASCII character into a `u8`."] # [inline] pub const fn as_byte (self) -> u8 { self as u8 } # [doc = " Converts an ASCII character into a `char`."] # [inline] pub const fn as_char (self) -> char { self as u8 as char } # [doc = " Turns uppercase into lowercase, but also modifies '@' and '<'..='_'"] const fn to_not_upper (self) -> u8 { self as u8 | 0b010_0000 } # [doc = " Check if the character is a letter (a-z, A-Z)"] # [inline] pub const fn is_alphabetic (self) -> bool { (self . to_not_upper () >= b'a') & (self . to_not_upper () <= b'z') } # [doc = " Check if the character is a letter (a-z, A-Z)."] # [doc = ""] # [doc = " This method is identical to [`is_alphabetic()`](#method.is_alphabetic)"] # [inline] pub const fn is_ascii_alphabetic (& self) -> bool { self . is_alphabetic () } # [doc = " Check if the character is a digit in the given radix."] # [doc = ""] # [doc = " If the radix is always 10 or 16,"] # [doc = " [`is_ascii_digit()`](#method.is_ascii_digit) and"] # [doc = " [`is_ascii_hexdigit()`](#method.is_ascii_hexdigit()) will be faster."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " Radixes greater than 36 are not supported and will result in a panic."] pub fn is_digit (self , radix : u32) -> bool { match (self as u8 , radix) { (b'0' ..= b'9' , 0 ..= 36) => u32 :: from (self as u8 - b'0') < radix , (b'a' ..= b'z' , 11 ..= 36) => u32 :: from (self as u8 - b'a') < radix - 10 , (b'A' ..= b'Z' , 11 ..= 36) => u32 :: from (self as u8 - b'A') < radix - 10 , (_ , 0 ..= 36) => false , (_ , _) => panic ! ("radixes greater than 36 are not supported") , } } # [doc = " Check if the character is a number (0-9)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('0').is_ascii_digit(), true);"] # [doc = " assert_eq!(AsciiChar::new('9').is_ascii_digit(), true);"] # [doc = " assert_eq!(AsciiChar::new('a').is_ascii_digit(), false);"] # [doc = " assert_eq!(AsciiChar::new('A').is_ascii_digit(), false);"] # [doc = " assert_eq!(AsciiChar::new('/').is_ascii_digit(), false);"] # [doc = " ```"] # [inline] pub const fn is_ascii_digit (& self) -> bool { (* self as u8 >= b'0') & (* self as u8 <= b'9') } # [doc = " Check if the character is a letter or number"] # [inline] pub const fn is_alphanumeric (self) -> bool { self . is_alphabetic () | self . is_ascii_digit () } # [doc = " Check if the character is a letter or number"] # [doc = ""] # [doc = " This method is identical to [`is_alphanumeric()`](#method.is_alphanumeric)"] # [inline] pub const fn is_ascii_alphanumeric (& self) -> bool { self . is_alphanumeric () } # [doc = " Check if the character is a space or horizontal tab"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert!(AsciiChar::Space.is_ascii_blank());"] # [doc = " assert!(AsciiChar::Tab.is_ascii_blank());"] # [doc = " assert!(!AsciiChar::VT.is_ascii_blank());"] # [doc = " assert!(!AsciiChar::LineFeed.is_ascii_blank());"] # [doc = " assert!(!AsciiChar::CarriageReturn.is_ascii_blank());"] # [doc = " assert!(!AsciiChar::FF.is_ascii_blank());"] # [doc = " ```"] # [inline] pub const fn is_ascii_blank (& self) -> bool { (* self as u8 == b' ') | (* self as u8 == b'\t') } # [doc = " Check if the character one of ' ', '\\t', '\\n', '\\r',"] # [doc = " '\\0xb' (vertical tab) or '\\0xc' (form feed)."] # [inline] pub const fn is_whitespace (self) -> bool { let b = self as u8 ; self . is_ascii_blank () | (b == b'\n') | (b == b'\r') | (b == 0x0b) | (b == 0x0c) } # [doc = " Check if the character is a ' ', '\\t', '\\n', '\\r' or '\\0xc' (form feed)."] # [doc = ""] # [doc = " This method is NOT identical to `is_whitespace()`."] # [inline] pub const fn is_ascii_whitespace (& self) -> bool { self . is_ascii_blank () | (* self as u8 == b'\n') | (* self as u8 == b'\r') | (* self as u8 == 0x0c) } # [doc = " Check if the character is a control character"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('\\0').is_ascii_control(), true);"] # [doc = " assert_eq!(AsciiChar::new('n').is_ascii_control(), false);"] # [doc = " assert_eq!(AsciiChar::new(' ').is_ascii_control(), false);"] # [doc = " assert_eq!(AsciiChar::new('\\n').is_ascii_control(), true);"] # [doc = " assert_eq!(AsciiChar::new('\\t').is_ascii_control(), true);"] # [doc = " assert_eq!(AsciiChar::EOT.is_ascii_control(), true);"] # [doc = " ```"] # [inline] pub const fn is_ascii_control (& self) -> bool { ((* self as u8) < b' ') | (* self as u8 == 127) } # [doc = " Checks if the character is printable (except space)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('n').is_ascii_graphic(), true);"] # [doc = " assert_eq!(AsciiChar::new(' ').is_ascii_graphic(), false);"] # [doc = " assert_eq!(AsciiChar::new('\\n').is_ascii_graphic(), false);"] # [doc = " ```"] # [inline] pub const fn is_ascii_graphic (& self) -> bool { self . as_byte () . wrapping_sub (b' ' + 1) < 0x5E } # [doc = " Checks if the character is printable (including space)"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('n').is_ascii_printable(), true);"] # [doc = " assert_eq!(AsciiChar::new(' ').is_ascii_printable(), true);"] # [doc = " assert_eq!(AsciiChar::new('\\n').is_ascii_printable(), false);"] # [doc = " ```"] # [inline] pub const fn is_ascii_printable (& self) -> bool { self . as_byte () . wrapping_sub (b' ') < 0x5F } # [doc = " Checks if the character is alphabetic and lowercase (a-z)."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('a').is_lowercase(), true);"] # [doc = " assert_eq!(AsciiChar::new('A').is_lowercase(), false);"] # [doc = " assert_eq!(AsciiChar::new('@').is_lowercase(), false);"] # [doc = " ```"] # [inline] pub const fn is_lowercase (self) -> bool { self . as_byte () . wrapping_sub (b'a') < 26 } # [doc = " Checks if the character is alphabetic and lowercase (a-z)."] # [doc = ""] # [doc = " This method is identical to [`is_lowercase()`](#method.is_lowercase)"] # [inline] pub const fn is_ascii_lowercase (& self) -> bool { self . is_lowercase () } # [doc = " Checks if the character is alphabetic and uppercase (A-Z)."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('A').is_uppercase(), true);"] # [doc = " assert_eq!(AsciiChar::new('a').is_uppercase(), false);"] # [doc = " assert_eq!(AsciiChar::new('@').is_uppercase(), false);"] # [doc = " ```"] # [inline] pub const fn is_uppercase (self) -> bool { self . as_byte () . wrapping_sub (b'A') < 26 } # [doc = " Checks if the character is alphabetic and uppercase (A-Z)."] # [doc = ""] # [doc = " This method is identical to [`is_uppercase()`](#method.is_uppercase)"] # [inline] pub const fn is_ascii_uppercase (& self) -> bool { self . is_uppercase () } # [doc = " Checks if the character is punctuation"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('n').is_ascii_punctuation(), false);"] # [doc = " assert_eq!(AsciiChar::new(' ').is_ascii_punctuation(), false);"] # [doc = " assert_eq!(AsciiChar::new('_').is_ascii_punctuation(), true);"] # [doc = " assert_eq!(AsciiChar::new('~').is_ascii_punctuation(), true);"] # [doc = " ```"] # [inline] pub const fn is_ascii_punctuation (& self) -> bool { self . is_ascii_graphic () & ! self . is_alphanumeric () } # [doc = " Checks if the character is a valid hex digit"] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('5').is_ascii_hexdigit(), true);"] # [doc = " assert_eq!(AsciiChar::new('a').is_ascii_hexdigit(), true);"] # [doc = " assert_eq!(AsciiChar::new('F').is_ascii_hexdigit(), true);"] # [doc = " assert_eq!(AsciiChar::new('G').is_ascii_hexdigit(), false);"] # [doc = " assert_eq!(AsciiChar::new(' ').is_ascii_hexdigit(), false);"] # [doc = " ```"] # [inline] pub const fn is_ascii_hexdigit (& self) -> bool { self . is_ascii_digit () | ((* self as u8 | 0x20u8) . wrapping_sub (b'a') < 6) } # [doc = " Unicode has printable versions of the ASCII control codes, like ''."] # [doc = ""] # [doc = " This function is identical with `.as_char()`"] # [doc = " for all values `.is_printable()` returns true for,"] # [doc = " but replaces the control codes with those unicodes printable versions."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('\\0').as_printable_char(), '');"] # [doc = " assert_eq!(AsciiChar::new('\\n').as_printable_char(), '');"] # [doc = " assert_eq!(AsciiChar::new(' ').as_printable_char(), ' ');"] # [doc = " assert_eq!(AsciiChar::new('p').as_printable_char(), 'p');"] # [doc = " ```"] pub fn as_printable_char (self) -> char { unsafe { match self as u8 { b' ' ..= b'~' => self . as_char () , 127 => '' , _ => char :: from_u32_unchecked (self as u32 + '' as u32) , } } } # [doc = " Replaces letters `a` to `z` with `A` to `Z`"] pub fn make_ascii_uppercase (& mut self) { * self = self . to_ascii_uppercase () } # [doc = " Replaces letters `A` to `Z` with `a` to `z`"] pub fn make_ascii_lowercase (& mut self) { * self = self . to_ascii_lowercase () } # [doc = " Maps letters a-z to A-Z and returns any other character unchanged."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('u').to_ascii_uppercase().as_char(), 'U');"] # [doc = " assert_eq!(AsciiChar::new('U').to_ascii_uppercase().as_char(), 'U');"] # [doc = " assert_eq!(AsciiChar::new('2').to_ascii_uppercase().as_char(), '2');"] # [doc = " assert_eq!(AsciiChar::new('=').to_ascii_uppercase().as_char(), '=');"] # [doc = " assert_eq!(AsciiChar::new('[').to_ascii_uppercase().as_char(), '[');"] # [doc = " ```"] # [inline] pub const fn to_ascii_uppercase (& self) -> Self { [* self , AsciiChar :: new ((* self as u8 & 0b101_1111) as char)] [self . is_lowercase () as usize] } # [doc = " Maps letters A-Z to a-z and returns any other character unchanged."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiChar;"] # [doc = " assert_eq!(AsciiChar::new('U').to_ascii_lowercase().as_char(), 'u');"] # [doc = " assert_eq!(AsciiChar::new('u').to_ascii_lowercase().as_char(), 'u');"] # [doc = " assert_eq!(AsciiChar::new('2').to_ascii_lowercase().as_char(), '2');"] # [doc = " assert_eq!(AsciiChar::new('^').to_ascii_lowercase().as_char(), '^');"] # [doc = " assert_eq!(AsciiChar::new('\\x7f').to_ascii_lowercase().as_char(), '\\x7f');"] # [doc = " ```"] # [inline] pub const fn to_ascii_lowercase (& self) -> Self { [* self , AsciiChar :: new (self . to_not_upper () as char)] [self . is_uppercase () as usize] } # [doc = " Compares two characters case-insensitively."] # [inline] pub const fn eq_ignore_ascii_case (& self , other : & Self) -> bool { (self . as_byte () == other . as_byte ()) | (self . is_alphabetic () & (self . to_not_upper () == other . to_not_upper ())) } } impl fmt :: Display for AsciiChar { # [inline] fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { self . as_char () . fmt (f) } } impl fmt :: Debug for AsciiChar { # [inline] fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { self . as_char () . fmt (f) } } impl Default for AsciiChar { fn default () -> AsciiChar { AsciiChar :: Null } } macro_rules ! impl_into_partial_eq_ord { ($ wider : ty , $ to_wider : expr) => { impl From < AsciiChar > for $ wider { # [inline] fn from (a : AsciiChar) -> $ wider { $ to_wider (a) } } impl PartialEq <$ wider > for AsciiChar { # [inline] fn eq (& self , rhs : &$ wider) -> bool { $ to_wider (* self) == * rhs } } impl PartialEq < AsciiChar > for $ wider { # [inline] fn eq (& self , rhs : & AsciiChar) -> bool { * self == $ to_wider (* rhs) } } impl PartialOrd <$ wider > for AsciiChar { # [inline] fn partial_cmp (& self , rhs : &$ wider) -> Option < Ordering > { $ to_wider (* self) . partial_cmp (rhs) } } impl PartialOrd < AsciiChar > for $ wider { # [inline] fn partial_cmp (& self , rhs : & AsciiChar) -> Option < Ordering > { self . partial_cmp (&$ to_wider (* rhs)) } } } } impl_into_partial_eq_ord ! { u8 , AsciiChar :: as_byte } impl_into_partial_eq_ord ! { char , AsciiChar :: as_char } # [doc = " Error returned by `ToAsciiChar`."] # [derive (Clone , Copy , PartialEq , Eq)] pub struct ToAsciiCharError (()) ; const ERRORMSG_CHAR : & str = "not an ASCII character" ; # [cfg (not (feature = "std"))] impl ToAsciiCharError { # [doc = " Returns a description for this error, like `std::error::Error::description`."] # [inline] pub const fn description (& self) -> & 'static str { ERRORMSG_CHAR } } impl fmt :: Debug for ToAsciiCharError { fn fmt (& self , fmtr : & mut fmt :: Formatter) -> fmt :: Result { write ! (fmtr , "{}" , ERRORMSG_CHAR) } } impl fmt :: Display for ToAsciiCharError { fn fmt (& self , fmtr : & mut fmt :: Formatter) -> fmt :: Result { write ! (fmtr , "{}" , ERRORMSG_CHAR) } } # [cfg (feature = "std")] impl Error for ToAsciiCharError { # [inline] fn description (& self) -> & 'static str { ERRORMSG_CHAR } } # [doc = " Convert `char`, `u8` and other character types to `AsciiChar`."] pub trait ToAsciiChar { # [doc = " Convert to `AsciiChar` without checking that it is an ASCII character."] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar ; # [doc = " Convert to `AsciiChar`."] fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > ; } impl ToAsciiChar for AsciiChar { # [inline] fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > { Ok (self) } # [inline] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar { self } } impl ToAsciiChar for u8 { # [inline] fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > { u32 :: from (self) . to_ascii_char () } # [inline] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar { mem :: transmute (self) } } impl ToAsciiChar for i8 { # [inline] fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > { (self as u32) . to_ascii_char () } # [inline] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar { mem :: transmute (self) } } impl ToAsciiChar for char { # [inline] fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > { (self as u32) . to_ascii_char () } # [inline] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar { (self as u32) . to_ascii_char_unchecked () } } impl ToAsciiChar for u32 { fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > { unsafe { match self { 0 ..= 127 => Ok (self . to_ascii_char_unchecked ()) , _ => Err (ToAsciiCharError (())) } } } # [inline] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar { (self as u8) . to_ascii_char_unchecked () } } impl ToAsciiChar for u16 { fn to_ascii_char (self) -> Result < AsciiChar , ToAsciiCharError > { u32 :: from (self) . to_ascii_char () } # [inline] unsafe fn to_ascii_char_unchecked (self) -> AsciiChar { (self as u8) . to_ascii_char_unchecked () } } # [cfg (test)] mod tests { use super :: { AsciiChar , ToAsciiChar , ToAsciiCharError } ; use AsciiChar :: * ; # [test] fn to_ascii_char () { fn generic < C : ToAsciiChar > (ch : C) -> Result < AsciiChar , ToAsciiCharError > { ch . to_ascii_char () } assert_eq ! (generic (A) , Ok (A)) ; assert_eq ! (generic (b'A') , Ok (A)) ; assert_eq ! (generic ('A') , Ok (A)) ; assert ! (generic (200u16) . is_err ()) ; assert ! (generic ('') . is_err ()) ; } # [test] fn as_byte_and_char () { assert_eq ! (A . as_byte () , b'A') ; assert_eq ! (A . as_char () , 'A') ; } # [test] fn new_array_is_correct () { for byte in 0 .. 128u8 { assert_eq ! (AsciiChar :: new (byte as char) . as_byte () , byte) ; } } # [test] fn is_all () { for byte in 0 .. 128u8 { let ch = byte as char ; let ascii = AsciiChar :: new (ch) ; assert_eq ! (ascii . is_alphabetic () , ch . is_alphabetic ()) ; assert_eq ! (ascii . is_ascii_alphabetic () , ch . is_ascii_alphabetic ()) ; assert_eq ! (ascii . is_alphanumeric () , ch . is_alphanumeric ()) ; assert_eq ! (ascii . is_ascii_alphanumeric () , ch . is_ascii_alphanumeric ()) ; assert_eq ! (ascii . is_digit (8) , ch . is_digit (8) , "is_digit(8) {:?}" , ch) ; assert_eq ! (ascii . is_digit (10) , ch . is_digit (10) , "is_digit(10) {:?}" , ch) ; assert_eq ! (ascii . is_digit (16) , ch . is_digit (16) , "is_digit(16) {:?}" , ch) ; assert_eq ! (ascii . is_digit (36) , ch . is_digit (36) , "is_digit(36) {:?}" , ch) ; assert_eq ! (ascii . is_ascii_digit () , ch . is_ascii_digit ()) ; assert_eq ! (ascii . is_ascii_hexdigit () , ch . is_ascii_hexdigit ()) ; assert_eq ! (ascii . is_ascii_control () , ch . is_ascii_control ()) ; assert_eq ! (ascii . is_ascii_graphic () , ch . is_ascii_graphic ()) ; assert_eq ! (ascii . is_ascii_punctuation () , ch . is_ascii_punctuation ()) ; assert_eq ! (ascii . is_whitespace () , ch . is_whitespace () , "{:?} ({:#04x})" , ch , byte) ; assert_eq ! (ascii . is_ascii_whitespace () , ch . is_ascii_whitespace () , "{:?} ({:#04x})" , ch , byte) ; assert_eq ! (ascii . is_uppercase () , ch . is_uppercase ()) ; assert_eq ! (ascii . is_ascii_uppercase () , ch . is_ascii_uppercase ()) ; assert_eq ! (ascii . is_lowercase () , ch . is_lowercase ()) ; assert_eq ! (ascii . is_ascii_lowercase () , ch . is_ascii_lowercase ()) ; assert_eq ! (ascii . to_ascii_uppercase () , ch . to_ascii_uppercase ()) ; assert_eq ! (ascii . to_ascii_lowercase () , ch . to_ascii_lowercase ()) ; } } # [test] fn is_digit_strange_radixes () { assert_eq ! (AsciiChar :: _0 . is_digit (0) , '0' . is_digit (0)) ; assert_eq ! (AsciiChar :: _0 . is_digit (1) , '0' . is_digit (1)) ; assert_eq ! (AsciiChar :: _5 . is_digit (5) , '5' . is_digit (5)) ; assert_eq ! (AsciiChar :: z . is_digit (35) , 'z' . is_digit (35)) ; } # [test] # [should_panic] fn is_digit_bad_radix () { AsciiChar :: _7 . is_digit (37) ; } # [test] fn cmp_wider () { assert_eq ! (A , 'A') ; assert_eq ! (b'b' , b) ; assert ! (a < 'z') ; } # [test] fn ascii_case () { assert_eq ! (At . to_ascii_lowercase () , At) ; assert_eq ! (At . to_ascii_uppercase () , At) ; assert_eq ! (A . to_ascii_lowercase () , a) ; assert_eq ! (A . to_ascii_uppercase () , A) ; assert_eq ! (a . to_ascii_lowercase () , a) ; assert_eq ! (a . to_ascii_uppercase () , A) ; let mut mutable = (A , a) ; mutable . 0 . make_ascii_lowercase () ; mutable . 1 . make_ascii_uppercase () ; assert_eq ! (mutable . 0 , a) ; assert_eq ! (mutable . 1 , A) ; assert ! (LineFeed . eq_ignore_ascii_case (& LineFeed)) ; assert ! (! LineFeed . eq_ignore_ascii_case (& CarriageReturn)) ; assert ! (z . eq_ignore_ascii_case (& Z)) ; assert ! (Z . eq_ignore_ascii_case (& z)) ; assert ! (A . eq_ignore_ascii_case (& a)) ; assert ! (! K . eq_ignore_ascii_case (& C)) ; assert ! (! Z . eq_ignore_ascii_case (& DEL)) ; assert ! (! BracketOpen . eq_ignore_ascii_case (& CurlyBraceOpen)) ; assert ! (! Grave . eq_ignore_ascii_case (& At)) ; assert ! (! Grave . eq_ignore_ascii_case (& DEL)) ; } # [test] # [cfg (feature = "std")] fn fmt_ascii () { assert_eq ! (format ! ("{}" , t) , "t") ; assert_eq ! (format ! ("{:?}" , t) , "'t'") ; assert_eq ! (format ! ("{}" , LineFeed) , "\n") ; assert_eq ! (format ! ("{:?}" , LineFeed) , "'\\n'") ; } } } mod ascii_str { use core :: fmt ; use core :: ops :: { Index , IndexMut } ; use core :: ops :: { Range , RangeTo , RangeFrom , RangeFull , RangeInclusive , RangeToInclusive } ; use core :: slice :: { self , Iter , IterMut , SliceIndex } ; # [cfg (feature = "std")] use std :: error :: Error ; # [cfg (feature = "std")] use std :: ffi :: CStr ; use ascii_char :: AsciiChar ; # [cfg (feature = "std")] use ascii_string :: AsciiString ; # [doc = " AsciiStr represents a byte or string slice that only contains ASCII characters."] # [doc = ""] # [doc = " It wraps an `[AsciiChar]` and implements many of `str`s methods and traits."] # [doc = ""] # [doc = " It can be created by a checked conversion from a `str` or `[u8]`, or borrowed from an"] # [doc = " `AsciiString`."] # [derive (PartialEq , Eq , PartialOrd , Ord , Hash)] # [repr (transparent)] pub struct AsciiStr { slice : [AsciiChar] , } impl AsciiStr { # [doc = " Converts `&self` to a `&str` slice."] # [inline] pub fn as_str (& self) -> & str { unsafe { & * (self as * const AsciiStr as * const str) } } # [doc = " Converts `&self` into a byte slice."] # [inline] pub fn as_bytes (& self) -> & [u8] { unsafe { & * (self as * const AsciiStr as * const [u8]) } } # [doc = " Returns the entire string as slice of `AsciiChar`s."] # [inline] pub const fn as_slice (& self) -> & [AsciiChar] { & self . slice } # [doc = " Returns the entire string as mutable slice of `AsciiChar`s."] # [inline] pub fn as_mut_slice (& mut self) -> & mut [AsciiChar] { & mut self . slice } # [doc = " Returns a raw pointer to the `AsciiStr`'s buffer."] # [doc = ""] # [doc = " The caller must ensure that the slice outlives the pointer this function returns, or else it"] # [doc = " will end up pointing to garbage. Modifying the `AsciiStr` may cause it's buffer to be"] # [doc = " reallocated, which would also make any pointers to it invalid."] # [inline] pub const fn as_ptr (& self) -> * const AsciiChar { self . as_slice () . as_ptr () } # [doc = " Returns an unsafe mutable pointer to the `AsciiStr`'s buffer."] # [doc = ""] # [doc = " The caller must ensure that the slice outlives the pointer this function returns, or else it"] # [doc = " will end up pointing to garbage. Modifying the `AsciiStr` may cause it's buffer to be"] # [doc = " reallocated, which would also make any pointers to it invalid."] # [inline] pub fn as_mut_ptr (& mut self) -> * mut AsciiChar { self . as_mut_slice () . as_mut_ptr () } # [doc = " Copies the content of this `AsciiStr` into an owned `AsciiString`."] # [cfg (feature = "std")] pub fn to_ascii_string (& self) -> AsciiString { AsciiString :: from (self . slice . to_vec ()) } # [doc = " Converts anything that can represent a byte slice into an `AsciiStr`."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let foo = AsciiStr::from_ascii(b\"foo\");"] # [doc = " let err = AsciiStr::from_ascii(\"\");"] # [doc = " assert_eq!(foo.unwrap().as_str(), \"foo\");"] # [doc = " assert_eq!(err.unwrap_err().valid_up_to(), 0);"] # [doc = " ```"] # [inline] pub fn from_ascii < B : ? Sized > (bytes : & B) -> Result < & AsciiStr , AsAsciiStrError > where B : AsRef < [u8] > , { bytes . as_ref () . as_ascii_str () } # [doc = " Converts anything that can be represented as a byte slice to an `AsciiStr` without checking"] # [doc = " for non-ASCII characters.."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let foo = unsafe { AsciiStr::from_ascii_unchecked(&b\"foo\"[..]) };"] # [doc = " assert_eq!(foo.as_str(), \"foo\");"] # [doc = " ```"] # [inline] pub unsafe fn from_ascii_unchecked (bytes : & [u8]) -> & AsciiStr { bytes . as_ascii_str_unchecked () } # [doc = " Returns the number of characters / bytes in this ASCII sequence."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let s = AsciiStr::from_ascii(\"foo\").unwrap();"] # [doc = " assert_eq!(s.len(), 3);"] # [doc = " ```"] # [inline] pub fn len (& self) -> usize { self . slice . len () } # [doc = " Returns true if the ASCII slice contains zero bytes."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let mut empty = AsciiStr::from_ascii(\"\").unwrap();"] # [doc = " let mut full = AsciiStr::from_ascii(\"foo\").unwrap();"] # [doc = " assert!(empty.is_empty());"] # [doc = " assert!(!full.is_empty());"] # [doc = " ```"] # [inline] pub fn is_empty (& self) -> bool { self . len () == 0 } # [doc = " Returns an iterator over the characters of the `AsciiStr`."] # [inline] pub fn chars (& self) -> Chars { Chars (self . slice . iter ()) } # [doc = " Returns an iterator over the characters of the `AsciiStr` which allows you to modify the"] # [doc = " value of each `AsciiChar`."] # [inline] pub fn chars_mut (& mut self) -> CharsMut { CharsMut (self . slice . iter_mut ()) } # [doc = " Returns an iterator over parts of the `AsciiStr` separated by a character."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::{AsciiStr, AsciiChar};"] # [doc = " let words = AsciiStr::from_ascii(\"apple banana lemon\").unwrap()"] # [doc = "     .split(AsciiChar::Space)"] # [doc = "     .map(|a| a.as_str())"] # [doc = "     .collect::<Vec<_>>();"] # [doc = " assert_eq!(words, [\"apple\", \"banana\", \"lemon\"]);"] # [doc = " ```"] pub fn split (& self , on : AsciiChar) -> impl DoubleEndedIterator < Item = & AsciiStr > { Split { on , ended : false , chars : self . chars () , } } # [doc = " Returns an iterator over the lines of the `AsciiStr`, which are themselves `AsciiStr`s."] # [doc = ""] # [doc = " Lines are ended with either `LineFeed` (`\\n`), or `CarriageReturn` then `LineFeed` (`\\r\\n`)."] # [doc = ""] # [doc = " The final line ending is optional."] # [inline] pub fn lines (& self) -> impl DoubleEndedIterator < Item = & AsciiStr > { Lines { string : self , } } # [doc = " Returns an ASCII string slice with leading and trailing whitespace removed."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let example = AsciiStr::from_ascii(\"  \\twhite \\tspace  \\t\").unwrap();"] # [doc = " assert_eq!(\"white \\tspace\", example.trim());"] # [doc = " ```"] pub fn trim (& self) -> & Self { self . trim_start () . trim_end () } # [doc = " Returns an ASCII string slice with leading whitespace removed."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let example = AsciiStr::from_ascii(\"  \\twhite \\tspace  \\t\").unwrap();"] # [doc = " assert_eq!(\"white \\tspace  \\t\", example.trim_start());"] # [doc = " ```"] pub fn trim_start (& self) -> & Self { & self [self . chars () . take_while (| a | a . is_whitespace ()) . count () ..] } # [doc = " Returns an ASCII string slice with trailing whitespace removed."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiStr;"] # [doc = " let example = AsciiStr::from_ascii(\"  \\twhite \\tspace  \\t\").unwrap();"] # [doc = " assert_eq!(\"  \\twhite \\tspace\", example.trim_end());"] # [doc = " ```"] pub fn trim_end (& self) -> & Self { let trimmed = self . chars () . rev () . take_while (| a | a . is_whitespace ()) . count () ; & self [.. self . len () - trimmed] } # [doc = " Compares two strings case-insensitively."] pub fn eq_ignore_ascii_case (& self , other : & Self) -> bool { self . len () == other . len () && self . chars () . zip (other . chars ()) . all (| (a , b) | { a . eq_ignore_ascii_case (& b) }) } # [doc = " Replaces lowercase letters with their uppercase equivalent."] pub fn make_ascii_uppercase (& mut self) { for a in self . chars_mut () { * a = a . to_ascii_uppercase () ; } } # [doc = " Replaces uppercase letters with their lowercase equivalent."] pub fn make_ascii_lowercase (& mut self) { for a in self . chars_mut () { * a = a . to_ascii_lowercase () ; } } # [doc = " Returns a copy of this string where letters 'a' to 'z' are mapped to 'A' to 'Z'."] # [cfg (feature = "std")] pub fn to_ascii_uppercase (& self) -> AsciiString { let mut ascii_string = self . to_ascii_string () ; ascii_string . make_ascii_uppercase () ; ascii_string } # [doc = " Returns a copy of this string where letters 'A' to 'Z' are mapped to 'a' to 'z'."] # [cfg (feature = "std")] pub fn to_ascii_lowercase (& self) -> AsciiString { let mut ascii_string = self . to_ascii_string () ; ascii_string . make_ascii_lowercase () ; ascii_string } # [doc = " Returns the first character if the string is not empty."] # [inline] pub fn first (& self) -> Option < AsciiChar > { self . slice . first () . cloned () } # [doc = " Returns the last character if the string is not empty."] # [inline] pub fn last (& self) -> Option < AsciiChar > { self . slice . last () . cloned () } } macro_rules ! impl_partial_eq { ($ wider : ty) => { impl PartialEq <$ wider > for AsciiStr { # [inline] fn eq (& self , other : &$ wider) -> bool { < AsciiStr as AsRef <$ wider >>:: as_ref (self) == other } } impl PartialEq < AsciiStr > for $ wider { # [inline] fn eq (& self , other : & AsciiStr) -> bool { self == < AsciiStr as AsRef <$ wider >>:: as_ref (other) } } } ; } impl_partial_eq ! { str } impl_partial_eq ! { [u8] } impl_partial_eq ! { [AsciiChar] } # [cfg (feature = "std")] impl ToOwned for AsciiStr { type Owned = AsciiString ; # [inline] fn to_owned (& self) -> AsciiString { self . to_ascii_string () } } impl AsRef < [u8] > for AsciiStr { # [inline] fn as_ref (& self) -> & [u8] { self . as_bytes () } } impl AsRef < str > for AsciiStr { # [inline] fn as_ref (& self) -> & str { self . as_str () } } impl AsRef < [AsciiChar] > for AsciiStr { # [inline] fn as_ref (& self) -> & [AsciiChar] { & self . slice } } impl AsMut < [AsciiChar] > for AsciiStr { # [inline] fn as_mut (& mut self) -> & mut [AsciiChar] { & mut self . slice } } impl Default for & 'static AsciiStr { # [inline] fn default () -> & 'static AsciiStr { From :: from (& [] as & [AsciiChar]) } } impl < 'a > From < & 'a [AsciiChar] > for & 'a AsciiStr { # [inline] fn from (slice : & [AsciiChar]) -> & AsciiStr { let ptr = slice as * const [AsciiChar] as * const AsciiStr ; unsafe { & * ptr } } } impl < 'a > From < & 'a mut [AsciiChar] > for & 'a mut AsciiStr { # [inline] fn from (slice : & mut [AsciiChar]) -> & mut AsciiStr { let ptr = slice as * mut [AsciiChar] as * mut AsciiStr ; unsafe { & mut * ptr } } } # [cfg (feature = "std")] impl From < Box < [AsciiChar] > > for Box < AsciiStr > { # [inline] fn from (owned : Box < [AsciiChar] >) -> Box < AsciiStr > { let ptr = Box :: into_raw (owned) as * mut AsciiStr ; unsafe { Box :: from_raw (ptr) } } } impl AsRef < AsciiStr > for AsciiStr { # [inline] fn as_ref (& self) -> & AsciiStr { self } } impl AsMut < AsciiStr > for AsciiStr { # [inline] fn as_mut (& mut self) -> & mut AsciiStr { self } } impl AsRef < AsciiStr > for [AsciiChar] { # [inline] fn as_ref (& self) -> & AsciiStr { self . into () } } impl AsMut < AsciiStr > for [AsciiChar] { # [inline] fn as_mut (& mut self) -> & mut AsciiStr { self . into () } } impl < 'a > From < & 'a AsciiStr > for & 'a [AsciiChar] { # [inline] fn from (astr : & AsciiStr) -> & [AsciiChar] { & astr . slice } } impl < 'a > From < & 'a mut AsciiStr > for & 'a mut [AsciiChar] { # [inline] fn from (astr : & mut AsciiStr) -> & mut [AsciiChar] { & mut astr . slice } } impl < 'a > From < & 'a AsciiStr > for & 'a [u8] { # [inline] fn from (astr : & AsciiStr) -> & [u8] { astr . as_bytes () } } impl < 'a > From < & 'a AsciiStr > for & 'a str { # [inline] fn from (astr : & AsciiStr) -> & str { astr . as_str () } } macro_rules ! widen_box { ($ wider : ty) => { # [cfg (feature = "std")] impl From < Box < AsciiStr >> for Box <$ wider > { # [inline] fn from (owned : Box < AsciiStr >) -> Box <$ wider > { let ptr = Box :: into_raw (owned) as * mut $ wider ; unsafe { Box :: from_raw (ptr) } } } } } widen_box ! { [AsciiChar] } widen_box ! { [u8] } widen_box ! { str } impl AsRef < AsciiStr > for AsciiChar { fn as_ref (& self) -> & AsciiStr { slice :: from_ref (self) . into () } } impl fmt :: Display for AsciiStr { # [inline] fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Display :: fmt (self . as_str () , f) } } impl fmt :: Debug for AsciiStr { # [inline] fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Debug :: fmt (self . as_str () , f) } } macro_rules ! impl_index { ($ idx : ty) => { impl Index <$ idx > for AsciiStr { type Output = AsciiStr ; # [inline] fn index (& self , index : $ idx) -> & AsciiStr { self . slice [index] . as_ref () } } impl IndexMut <$ idx > for AsciiStr { # [inline] fn index_mut (& mut self , index : $ idx) -> & mut AsciiStr { self . slice [index] . as_mut () } } } } impl_index ! { Range < usize > } impl_index ! { RangeTo < usize > } impl_index ! { RangeFrom < usize > } impl_index ! { RangeFull } impl_index ! { RangeInclusive < usize > } impl_index ! { RangeToInclusive < usize > } impl Index < usize > for AsciiStr { type Output = AsciiChar ; # [inline] fn index (& self , index : usize) -> & AsciiChar { & self . slice [index] } } impl IndexMut < usize > for AsciiStr { # [inline] fn index_mut (& mut self , index : usize) -> & mut AsciiChar { & mut self . slice [index] } } # [doc = " Produces references for compatibility with `[u8]`."] # [doc = ""] # [doc = " (`str` doesn't implement `IntoIterator` for its references,"] # [doc = "  so there is no compatibility to lose.)"] impl < 'a > IntoIterator for & 'a AsciiStr { type Item = & 'a AsciiChar ; type IntoIter = CharsRef < 'a > ; # [inline] fn into_iter (self) -> Self :: IntoIter { CharsRef (self . as_slice () . iter ()) } } impl < 'a > IntoIterator for & 'a mut AsciiStr { type Item = & 'a mut AsciiChar ; type IntoIter = CharsMut < 'a > ; # [inline] fn into_iter (self) -> Self :: IntoIter { self . chars_mut () } } # [doc = " A copying iterator over the characters of an `AsciiStr`."] # [derive (Clone , Debug)] pub struct Chars < 'a > (Iter < 'a , AsciiChar >) ; impl < 'a > Chars < 'a > { # [doc = " Returns the ascii string slice with the remaining characters."] pub fn as_str (& self) -> & 'a AsciiStr { self . 0 . as_slice () . into () } } impl < 'a > Iterator for Chars < 'a > { type Item = AsciiChar ; # [inline] fn next (& mut self) -> Option < AsciiChar > { self . 0 . next () . cloned () } fn size_hint (& self) -> (usize , Option < usize >) { self . 0 . size_hint () } } impl < 'a > DoubleEndedIterator for Chars < 'a > { # [inline] fn next_back (& mut self) -> Option < AsciiChar > { self . 0 . next_back () . cloned () } } impl < 'a > ExactSizeIterator for Chars < 'a > { fn len (& self) -> usize { self . 0 . len () } } # [doc = " A mutable iterator over the characters of an `AsciiStr`."] # [derive (Debug)] pub struct CharsMut < 'a > (IterMut < 'a , AsciiChar >) ; impl < 'a > CharsMut < 'a > { # [doc = " Returns the ascii string slice with the remaining characters."] pub fn into_str (self) -> & 'a mut AsciiStr { self . 0 . into_slice () . into () } } impl < 'a > Iterator for CharsMut < 'a > { type Item = & 'a mut AsciiChar ; # [inline] fn next (& mut self) -> Option < & 'a mut AsciiChar > { self . 0 . next () } fn size_hint (& self) -> (usize , Option < usize >) { self . 0 . size_hint () } } impl < 'a > DoubleEndedIterator for CharsMut < 'a > { # [inline] fn next_back (& mut self) -> Option < & 'a mut AsciiChar > { self . 0 . next_back () } } impl < 'a > ExactSizeIterator for CharsMut < 'a > { fn len (& self) -> usize { self . 0 . len () } } # [doc = " An immutable iterator over the characters of an `AsciiStr`."] # [derive (Clone , Debug)] pub struct CharsRef < 'a > (Iter < 'a , AsciiChar >) ; impl < 'a > CharsRef < 'a > { # [doc = " Returns the ascii string slice with the remaining characters."] pub fn as_str (& self) -> & 'a AsciiStr { self . 0 . as_slice () . into () } } impl < 'a > Iterator for CharsRef < 'a > { type Item = & 'a AsciiChar ; # [inline] fn next (& mut self) -> Option < & 'a AsciiChar > { self . 0 . next () } fn size_hint (& self) -> (usize , Option < usize >) { self . 0 . size_hint () } } impl < 'a > DoubleEndedIterator for CharsRef < 'a > { # [inline] fn next_back (& mut self) -> Option < & 'a AsciiChar > { self . 0 . next_back () } } # [doc = " An iterator over parts of an `AsciiStr` separated by an `AsciiChar`."] # [doc = ""] # [doc = " This type is created by [`AsciiChar::split()`](struct.AsciiChar.html#method.split)."] # [derive (Clone , Debug)] struct Split < 'a > { on : AsciiChar , ended : bool , chars : Chars < 'a > } impl < 'a > Iterator for Split < 'a > { type Item = & 'a AsciiStr ; fn next (& mut self) -> Option < & 'a AsciiStr > { if ! self . ended { let start : & AsciiStr = self . chars . as_str () ; let split_on = self . on ; if let Some (at) = self . chars . position (| c | c == split_on) { Some (& start [.. at]) } else { self . ended = true ; Some (start) } } else { None } } } impl < 'a > DoubleEndedIterator for Split < 'a > { fn next_back (& mut self) -> Option < & 'a AsciiStr > { if ! self . ended { let start : & AsciiStr = self . chars . as_str () ; let split_on = self . on ; if let Some (at) = self . chars . rposition (| c | c == split_on) { Some (& start [at + 1 ..]) } else { self . ended = true ; Some (start) } } else { None } } } # [doc = " An iterator over the lines of the internal character array."] # [derive (Clone , Debug)] struct Lines < 'a > { string : & 'a AsciiStr , } impl < 'a > Iterator for Lines < 'a > { type Item = & 'a AsciiStr ; fn next (& mut self) -> Option < & 'a AsciiStr > { if let Some (idx) = self . string . chars () . position (| chr | chr == AsciiChar :: LineFeed) { let line = if idx > 0 && self . string [idx - 1] == AsciiChar :: CarriageReturn { & self . string [.. idx - 1] } else { & self . string [.. idx] } ; self . string = & self . string [idx + 1 ..] ; Some (line) } else if self . string . is_empty () { None } else { let line = self . string ; self . string = & self . string [.. 0] ; Some (line) } } } impl < 'a > DoubleEndedIterator for Lines < 'a > { fn next_back (& mut self) -> Option < & 'a AsciiStr > { if self . string . is_empty () { return None ; } let mut i = self . string . len () ; if self . string [i - 1] == AsciiChar :: LineFeed { i -= 1 ; if i > 0 && self . string [i - 1] == AsciiChar :: CarriageReturn { i -= 1 ; } } self . string = & self . string [.. i] ; while i > 0 && self . string [i - 1] != AsciiChar :: LineFeed { i -= 1 ; } let line = & self . string [i ..] ; self . string = & self . string [.. i] ; Some (line) } } # [doc = " Error that is returned when a sequence of `u8` are not all ASCII."] # [doc = ""] # [doc = " Is used by `As[Mut]AsciiStr` and the `from_ascii` method on `AsciiStr` and `AsciiString`."] # [derive (Clone , Copy , PartialEq , Eq , Debug)] pub struct AsAsciiStrError (usize) ; const ERRORMSG_STR : & str = "one or more bytes are not ASCII" ; impl AsAsciiStrError { # [doc = " Returns the index of the first non-ASCII byte."] # [doc = ""] # [doc = " It is the maximum index such that `from_ascii(input[..index])` would return `Ok(_)`."] # [inline] pub const fn valid_up_to (self) -> usize { self . 0 } # [cfg (not (feature = "std"))] # [doc = " Returns a description for this error, like `std::error::Error::description`."] # [inline] pub const fn description (& self) -> & 'static str { ERRORMSG_STR } } impl fmt :: Display for AsAsciiStrError { fn fmt (& self , fmtr : & mut fmt :: Formatter) -> fmt :: Result { write ! (fmtr , "the byte at index {} is not ASCII" , self . 0) } } # [cfg (feature = "std")] impl Error for AsAsciiStrError { # [inline] fn description (& self) -> & 'static str { ERRORMSG_STR } } # [doc = " Convert slices of bytes or AsciiChar to `AsciiStr`."] pub trait AsAsciiStr { # [doc = " Used to constrain `SliceIndex`"] # [doc (hidden)] type Inner ; # [doc = " Convert a subslice to an ASCII slice."] # [doc = ""] # [doc = " Returns `Err` if the range is out of bounds or if not all bytes in the"] # [doc = " slice are ASCII. The value in the error will be the index of the first"] # [doc = " non-ASCII byte or the end of the slice."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use ascii::AsAsciiStr;"] # [doc = " assert!(\"'zo'\".slice_ascii(..3).is_ok());"] # [doc = " assert!(\"'zo'\".slice_ascii(0..4).is_err());"] # [doc = " assert!(\"'zo'\".slice_ascii(5..=5).is_ok());"] # [doc = " assert!(\"'zo'\".slice_ascii(4..).is_err());"] # [doc = " assert!(b\"\\r\\n\".slice_ascii(..).is_ok());"] # [doc = " ```"] fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [Self :: Inner] , Output = [Self :: Inner] > ; # [doc = " Convert to an ASCII slice."] # [doc = ""] # [doc = " # Example"] # [doc = " ```"] # [doc = " use ascii::{AsAsciiStr, AsciiChar};"] # [doc = " assert!(\"ASCII\".as_ascii_str().is_ok());"] # [doc = " assert!(b\"\\r\\n\".as_ascii_str().is_ok());"] # [doc = " assert!(\"'zo'\".as_ascii_str().is_err());"] # [doc = " assert!(b\"\\xff\".as_ascii_str().is_err());"] # [doc = " assert!([AsciiChar::C][..].as_ascii_str().is_ok()); // infallible"] # [doc = " ```"] fn as_ascii_str (& self) -> Result < & AsciiStr , AsAsciiStrError > { self . slice_ascii (..) } # [doc = " Get a single ASCII character from the slice."] # [doc = ""] # [doc = " Returns `None` if the index is out of bounds or the byte is not ASCII."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use ascii::{AsAsciiStr, AsciiChar};"] # [doc = " assert_eq!(\"'zo'\".get_ascii(4), None);"] # [doc = " assert_eq!(\"'zo'\".get_ascii(5), Some(AsciiChar::Apostrophe));"] # [doc = " assert_eq!(\"'zo'\".get_ascii(6), None);"] # [doc = " ```"] fn get_ascii (& self , index : usize) -> Option < AsciiChar > { self . slice_ascii (index ..= index) . ok () . and_then (| str | str . first ()) } # [doc = " Convert to an ASCII slice without checking for non-ASCII characters."] # [doc = ""] # [doc = " # Examples"] # [doc = " "] unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr ; } # [doc = " Convert mutable slices of bytes or AsciiChar to `AsciiStr`."] pub trait AsMutAsciiStr : AsAsciiStr { # [doc = " Convert a subslice to an ASCII slice."] fn slice_ascii_mut < R > (& mut self , range : R) -> Result < & mut AsciiStr , AsAsciiStrError > where R : SliceIndex < [Self :: Inner] , Output = [Self :: Inner] > ; # [doc = " Convert to a mutable ASCII slice."] fn as_mut_ascii_str (& mut self) -> Result < & mut AsciiStr , AsAsciiStrError > { self . slice_ascii_mut (..) } # [doc = " Convert to a mutable ASCII slice without checking for non-ASCII characters."] unsafe fn as_mut_ascii_str_unchecked (& mut self) -> & mut AsciiStr ; } impl < 'a , T : ? Sized > AsAsciiStr for & 'a T where T : AsAsciiStr { type Inner = < T as AsAsciiStr > :: Inner ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [Self :: Inner] , Output = [Self :: Inner] > { < T as AsAsciiStr > :: slice_ascii (* self , range) } unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { < T as AsAsciiStr > :: as_ascii_str_unchecked (* self) } } impl < 'a , T : ? Sized > AsAsciiStr for & 'a mut T where T : AsAsciiStr { type Inner = < T as AsAsciiStr > :: Inner ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [Self :: Inner] , Output = [Self :: Inner] > { < T as AsAsciiStr > :: slice_ascii (* self , range) } unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { < T as AsAsciiStr > :: as_ascii_str_unchecked (* self) } } impl < 'a , T : ? Sized > AsMutAsciiStr for & 'a mut T where T : AsMutAsciiStr { fn slice_ascii_mut < R > (& mut self , range : R) -> Result < & mut AsciiStr , AsAsciiStrError > where R : SliceIndex < [Self :: Inner] , Output = [Self :: Inner] > { < T as AsMutAsciiStr > :: slice_ascii_mut (* self , range) } unsafe fn as_mut_ascii_str_unchecked (& mut self) -> & mut AsciiStr { < T as AsMutAsciiStr > :: as_mut_ascii_str_unchecked (* self) } } impl AsAsciiStr for AsciiStr { type Inner = AsciiChar ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [AsciiChar] , Output = [AsciiChar] > { self . slice . slice_ascii (range) } # [inline] fn as_ascii_str (& self) -> Result < & AsciiStr , AsAsciiStrError > { Ok (self) } # [inline] unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { self } # [inline] fn get_ascii (& self , index : usize) -> Option < AsciiChar > { self . slice . get_ascii (index) } } impl AsMutAsciiStr for AsciiStr { fn slice_ascii_mut < R > (& mut self , range : R) -> Result < & mut AsciiStr , AsAsciiStrError > where R : SliceIndex < [AsciiChar] , Output = [AsciiChar] > { self . slice . slice_ascii_mut (range) } # [inline] unsafe fn as_mut_ascii_str_unchecked (& mut self) -> & mut AsciiStr { self } } impl AsAsciiStr for [AsciiChar] { type Inner = AsciiChar ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [AsciiChar] , Output = [AsciiChar] > { match self . get (range) { Some (slice) => Ok (slice . into ()) , None => Err (AsAsciiStrError (self . len ())) , } } # [inline] fn as_ascii_str (& self) -> Result < & AsciiStr , AsAsciiStrError > { Ok (self . into ()) } # [inline] unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { self . into () } # [inline] fn get_ascii (& self , index : usize) -> Option < AsciiChar > { self . get (index) . cloned () } } impl AsMutAsciiStr for [AsciiChar] { fn slice_ascii_mut < R > (& mut self , range : R) -> Result < & mut AsciiStr , AsAsciiStrError > where R : SliceIndex < [AsciiChar] , Output = [AsciiChar] > { let len = self . len () ; match self . get_mut (range) { Some (slice) => Ok (slice . into ()) , None => Err (AsAsciiStrError (len)) , } } # [inline] unsafe fn as_mut_ascii_str_unchecked (& mut self) -> & mut AsciiStr { self . into () } } impl AsAsciiStr for [u8] { type Inner = u8 ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [u8] , Output = [u8] > { if let Some (slice) = self . get (range) { slice . as_ascii_str () . map_err (| AsAsciiStrError (not_ascii) | { let offset = slice . as_ptr () as usize - self . as_ptr () as usize ; AsAsciiStrError (offset + not_ascii) }) } else { Err (AsAsciiStrError (self . len ())) } } fn as_ascii_str (& self) -> Result < & AsciiStr , AsAsciiStrError > { if self . is_ascii () { unsafe { Ok (self . as_ascii_str_unchecked ()) } } else { Err (AsAsciiStrError (self . iter () . take_while (| & b | b . is_ascii ()) . count ())) } } # [inline] unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { let ptr = self as * const [u8] as * const AsciiStr ; & * ptr } } impl AsMutAsciiStr for [u8] { fn slice_ascii_mut < R > (& mut self , range : R) -> Result < & mut AsciiStr , AsAsciiStrError > where R : SliceIndex < [u8] , Output = [u8] > { let (ptr , len) = (self . as_ptr () , self . len ()) ; if let Some (slice) = self . get_mut (range) { let slice_ptr = slice . as_ptr () ; slice . as_mut_ascii_str () . map_err (| AsAsciiStrError (not_ascii) | { let offset = slice_ptr as usize - ptr as usize ; AsAsciiStrError (offset + not_ascii) }) } else { Err (AsAsciiStrError (len)) } } fn as_mut_ascii_str (& mut self) -> Result < & mut AsciiStr , AsAsciiStrError > { if self . is_ascii () { unsafe { Ok (self . as_mut_ascii_str_unchecked ()) } } else { Err (AsAsciiStrError (self . iter () . take_while (| & b | b . is_ascii ()) . count ())) } } # [inline] unsafe fn as_mut_ascii_str_unchecked (& mut self) -> & mut AsciiStr { let ptr = self as * mut [u8] as * mut AsciiStr ; & mut * ptr } } impl AsAsciiStr for str { type Inner = u8 ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [u8] , Output = [u8] > { self . as_bytes () . slice_ascii (range) } fn as_ascii_str (& self) -> Result < & AsciiStr , AsAsciiStrError > { self . as_bytes () . as_ascii_str () } # [inline] unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { self . as_bytes () . as_ascii_str_unchecked () } } impl AsMutAsciiStr for str { fn slice_ascii_mut < R > (& mut self , range : R) -> Result < & mut AsciiStr , AsAsciiStrError > where R : SliceIndex < [u8] , Output = [u8] > { let (ptr , len) = if let Some (slice) = self . as_bytes () . get (range) { if ! slice . is_ascii () { let offset = slice . as_ptr () as usize - self . as_ptr () as usize ; let not_ascii = slice . iter () . take_while (| & b | b . is_ascii ()) . count () ; return Err (AsAsciiStrError (offset + not_ascii)) ; } (slice . as_ptr () , slice . len ()) } else { return Err (AsAsciiStrError (self . len ())) ; } ; unsafe { let ptr = ptr as * const AsciiChar as * mut AsciiChar ; let slice = core :: slice :: from_raw_parts_mut (ptr , len) ; Ok (slice . into ()) } } fn as_mut_ascii_str (& mut self) -> Result < & mut AsciiStr , AsAsciiStrError > { match self . bytes () . position (| b | b > 127) { Some (index) => Err (AsAsciiStrError (index)) , None => unsafe { Ok (self . as_mut_ascii_str_unchecked ()) } , } } # [inline] unsafe fn as_mut_ascii_str_unchecked (& mut self) -> & mut AsciiStr { let ptr = self as * mut str as * mut AsciiStr ; & mut * ptr } } # [doc = " Note that the trailing null byte will be removed in the conversion."] # [cfg (feature = "std")] impl AsAsciiStr for CStr { type Inner = u8 ; fn slice_ascii < R > (& self , range : R) -> Result < & AsciiStr , AsAsciiStrError > where R : SliceIndex < [u8] , Output = [u8] > { self . to_bytes () . slice_ascii (range) } # [inline] fn as_ascii_str (& self) -> Result < & AsciiStr , AsAsciiStrError > { self . to_bytes () . as_ascii_str () } # [inline] unsafe fn as_ascii_str_unchecked (& self) -> & AsciiStr { self . to_bytes () . as_ascii_str_unchecked () } } # [cfg (test)] mod tests { use AsciiChar ; use super :: { AsciiStr , AsAsciiStr , AsMutAsciiStr , AsAsciiStrError } ; # [test] fn generic_as_ascii_str () { fn generic < C : AsAsciiStr + ? Sized > (c : & C) -> Result < & AsciiStr , AsAsciiStrError > { c . as_ascii_str () } let arr = [AsciiChar :: A] ; let ascii_str : & AsciiStr = arr . as_ref () . into () ; assert_eq ! (generic ("A") , Ok (ascii_str)) ; assert_eq ! (generic (& b"A" [..]) , Ok (ascii_str)) ; assert_eq ! (generic (ascii_str) , Ok (ascii_str)) ; assert_eq ! (generic (& "A") , Ok (ascii_str)) ; assert_eq ! (generic (& ascii_str) , Ok (ascii_str)) ; assert_eq ! (generic (& mut "A") , Ok (ascii_str)) ; } # [cfg (feature = "std")] # [test] fn cstring_as_ascii_str () { use std :: ffi :: CString ; fn generic < C : AsAsciiStr + ? Sized > (c : & C) -> Result < & AsciiStr , AsAsciiStrError > { c . as_ascii_str () } let arr = [AsciiChar :: A] ; let ascii_str : & AsciiStr = arr . as_ref () . into () ; let cstr = CString :: new ("A") . unwrap () ; assert_eq ! (generic (&* cstr) , Ok (ascii_str)) ; } # [test] fn generic_as_mut_ascii_str () { fn generic_mut < C : AsMutAsciiStr + ? Sized > (c : & mut C ,) -> Result < & mut AsciiStr , AsAsciiStrError > { c . as_mut_ascii_str () } let mut arr_mut = [AsciiChar :: B] ; let mut ascii_str_mut : & mut AsciiStr = arr_mut . as_mut () . into () ; let mut arr_mut_2 = [AsciiChar :: B] ; let ascii_str_mut_2 : & mut AsciiStr = arr_mut_2 . as_mut () . into () ; assert_eq ! (generic_mut (& mut ascii_str_mut) , Ok (& mut * ascii_str_mut_2)) ; assert_eq ! (generic_mut (ascii_str_mut) , Ok (& mut * ascii_str_mut_2)) ; } # [test] fn as_ascii_str () { macro_rules ! err { { $ i : expr } => { Err (AsAsciiStrError ($ i)) } } let s = "abd" ; let b = s . as_bytes () ; assert_eq ! (s . as_ascii_str () , err ! (2)) ; assert_eq ! (b . as_ascii_str () , err ! (2)) ; let a : & AsciiStr = [AsciiChar :: a , AsciiChar :: b] [..] . as_ref () ; assert_eq ! (s [.. 2] . as_ascii_str () , Ok (a)) ; assert_eq ! (b [.. 2] . as_ascii_str () , Ok (a)) ; assert_eq ! (s . slice_ascii (.. 2) , Ok (a)) ; assert_eq ! (b . slice_ascii (.. 2) , Ok (a)) ; assert_eq ! (s . slice_ascii (..= 2) , err ! (2)) ; assert_eq ! (b . slice_ascii (..= 2) , err ! (2)) ; assert_eq ! (s . get_ascii (4) , Some (AsciiChar :: d)) ; assert_eq ! (b . get_ascii (4) , Some (AsciiChar :: d)) ; assert_eq ! (s . get_ascii (3) , None) ; assert_eq ! (b . get_ascii (3) , None) ; assert_eq ! (s . get_ascii (b . len ()) , None) ; assert_eq ! (b . get_ascii (b . len ()) , None) ; assert_eq ! (a . get_ascii (0) , Some (AsciiChar :: a)) ; assert_eq ! (a . get_ascii (a . len ()) , None) ; } # [test] # [cfg (feature = "std")] fn cstr_as_ascii_str () { use std :: ffi :: CStr ; macro_rules ! err { { $ i : expr } => { Err (AsAsciiStrError ($ i)) } } let cstr = CStr :: from_bytes_with_nul (b"a\xbbcde\xffg\0") . unwrap () ; assert_eq ! (cstr . as_ascii_str () , err ! (1)) ; assert_eq ! (cstr . slice_ascii (2 ..) , err ! (5)) ; assert_eq ! (cstr . get_ascii (5) , None) ; assert_eq ! (cstr . get_ascii (6) , Some (AsciiChar :: g)) ; assert_eq ! (cstr . get_ascii (7) , None) ; let aslice = & [AsciiChar :: X , AsciiChar :: Y , AsciiChar :: Z , AsciiChar :: Null] [..] ; let astr : & AsciiStr = aslice . as_ref () ; let cstr = CStr :: from_bytes_with_nul (astr . as_bytes ()) . unwrap () ; assert_eq ! (cstr . slice_ascii (.. 2) , Ok (& astr [.. 2])) ; assert_eq ! (cstr . as_ascii_str () , Ok (& astr [.. 3])) ; } # [test] # [cfg (feature = "std")] fn as_mut_ascii_str () { macro_rules ! err { { $ i : expr } => { Err (AsAsciiStrError ($ i)) } } let mut s : String = "abd" . to_string () ; let mut b : Vec < u8 > = s . clone () . into () ; let mut first = [AsciiChar :: a , AsciiChar :: b] ; let mut second = [AsciiChar :: d] ; assert_eq ! (s . as_mut_ascii_str () , err ! (2)) ; assert_eq ! (b . as_mut_ascii_str () , err ! (2)) ; assert_eq ! (s . slice_ascii_mut (..) , err ! (2)) ; assert_eq ! (b . slice_ascii_mut (..) , err ! (2)) ; assert_eq ! (s [.. 2] . as_mut_ascii_str () , Ok ((& mut first [..]) . into ())) ; assert_eq ! (b [.. 2] . as_mut_ascii_str () , Ok ((& mut first [..]) . into ())) ; assert_eq ! (s . slice_ascii_mut (0 .. 2) , Ok ((& mut first [..]) . into ())) ; assert_eq ! (b . slice_ascii_mut (0 .. 2) , Ok ((& mut first [..]) . into ())) ; assert_eq ! (s . slice_ascii_mut (4 ..) , Ok ((& mut second [..]) . into ())) ; assert_eq ! (b . slice_ascii_mut (4 ..) , Ok ((& mut second [..]) . into ())) ; assert_eq ! (s . slice_ascii_mut (4 ..= 10) , err ! (5)) ; assert_eq ! (b . slice_ascii_mut (4 ..= 10) , err ! (5)) ; } # [test] fn default () { let default : & 'static AsciiStr = Default :: default () ; assert ! (default . is_empty ()) ; } # [test] fn index () { let mut arr = [AsciiChar :: A , AsciiChar :: B , AsciiChar :: C , AsciiChar :: D] ; { let a : & AsciiStr = arr [..] . into () ; assert_eq ! (a [..] . as_slice () , & a . as_slice () [..]) ; assert_eq ! (a [.. 4] . as_slice () , & a . as_slice () [.. 4]) ; assert_eq ! (a [4 ..] . as_slice () , & a . as_slice () [4 ..]) ; assert_eq ! (a [2 .. 3] . as_slice () , & a . as_slice () [2 .. 3]) ; assert_eq ! (a [..= 3] . as_slice () , & a . as_slice () [..= 3]) ; assert_eq ! (a [1 ..= 1] . as_slice () , & a . as_slice () [1 ..= 1]) ; } let mut copy = arr ; let a_mut : & mut AsciiStr = { & mut arr [..] } . into () ; assert_eq ! (a_mut [..] . as_mut_slice () , & mut copy [..]) ; assert_eq ! (a_mut [.. 2] . as_mut_slice () , & mut copy [.. 2]) ; assert_eq ! (a_mut [3 ..] . as_mut_slice () , & mut copy [3 ..]) ; assert_eq ! (a_mut [4 .. 4] . as_mut_slice () , & mut copy [4 .. 4]) ; assert_eq ! (a_mut [..= 0] . as_mut_slice () , & mut copy [..= 0]) ; assert_eq ! (a_mut [0 ..= 2] . as_mut_slice () , & mut copy [0 ..= 2]) ; } # [test] fn as_str () { let b = b"( ;" ; let v = AsciiStr :: from_ascii (b) . unwrap () ; assert_eq ! (v . as_str () , "( ;") ; assert_eq ! (AsRef ::< str >:: as_ref (v) , "( ;") ; } # [test] fn as_bytes () { let b = b"( ;" ; let v = AsciiStr :: from_ascii (b) . unwrap () ; assert_eq ! (v . as_bytes () , b"( ;") ; assert_eq ! (AsRef ::< [u8] >:: as_ref (v) , b"( ;") ; } # [test] fn make_ascii_case () { let mut bytes = ([b'a' , b'@' , b'A'] , [b'A' , b'@' , b'a']) ; let a = bytes . 0 . as_mut_ascii_str () . unwrap () ; let b = bytes . 1 . as_mut_ascii_str () . unwrap () ; assert ! (a . eq_ignore_ascii_case (b)) ; assert ! (b . eq_ignore_ascii_case (a)) ; a . make_ascii_lowercase () ; b . make_ascii_uppercase () ; assert_eq ! (a , "a@a") ; assert_eq ! (b , "A@A") ; } # [test] # [cfg (feature = "std")] fn to_ascii_case () { let bytes = ([b'a' , b'@' , b'A'] , [b'A' , b'@' , b'a']) ; let a = bytes . 0 . as_ascii_str () . unwrap () ; let b = bytes . 1 . as_ascii_str () . unwrap () ; assert_eq ! (a . to_ascii_lowercase () . as_str () , "a@a") ; assert_eq ! (a . to_ascii_uppercase () . as_str () , "A@A") ; assert_eq ! (b . to_ascii_lowercase () . as_str () , "a@a") ; assert_eq ! (b . to_ascii_uppercase () . as_str () , "A@A") ; } # [test] fn chars_iter () { let chars = & [b'h' , b'e' , b'l' , b'l' , b'o' , b' ' , b'w' , b'o' , b'r' , b'l' , b'd' , b'\0'] ; let ascii = AsciiStr :: from_ascii (chars) . unwrap () ; for (achar , byte) in ascii . chars () . zip (chars . iter () . cloned ()) { assert_eq ! (achar , byte) ; } } # [test] fn chars_iter_mut () { let chars = & mut [b'h' , b'e' , b'l' , b'l' , b'o' , b' ' , b'w' , b'o' , b'r' , b'l' , b'd' , b'\0'] ; let ascii = chars . as_mut_ascii_str () . unwrap () ; * ascii . chars_mut () . next () . unwrap () = AsciiChar :: H ; assert_eq ! (ascii [0] , b'H') ; } # [test] fn lines_iter () { use core :: iter :: Iterator ; let lines : [& str ; 4] = ["foo" , "bar" , "" , "baz"] ; let joined = "foo\r\nbar\n\nbaz\n" ; let ascii = AsciiStr :: from_ascii (joined . as_bytes ()) . unwrap () ; for (asciiline , line) in ascii . lines () . zip (& lines) { assert_eq ! (asciiline , * line) ; } assert_eq ! (ascii . lines () . count () , lines . len ()) ; let lines : [& str ; 4] = ["foo" , "bar" , "" , "baz"] ; let joined = "foo\r\nbar\n\nbaz" ; let ascii = AsciiStr :: from_ascii (joined . as_bytes ()) . unwrap () ; for (asciiline , line) in ascii . lines () . zip (& lines) { assert_eq ! (asciiline , * line) ; } assert_eq ! (ascii . lines () . count () , lines . len ()) ; let trailing_line_break = b"\n" ; let ascii = AsciiStr :: from_ascii (& trailing_line_break) . unwrap () ; let mut line_iter = ascii . lines () ; assert_eq ! (line_iter . next () , Some (AsciiStr :: from_ascii ("") . unwrap ())) ; assert_eq ! (line_iter . next () , None) ; let empty_lines = b"\n\r\n\n\r\n" ; let mut iter_count = 0 ; let ascii = AsciiStr :: from_ascii (& empty_lines) . unwrap () ; for line in ascii . lines () { iter_count += 1 ; assert ! (line . is_empty ()) ; } assert_eq ! (4 , iter_count) ; } # [test] fn lines_iter_rev () { let joined = "foo\r\nbar\n\nbaz\n" ; let ascii = AsciiStr :: from_ascii (joined . as_bytes ()) . unwrap () ; assert_eq ! (ascii . lines () . rev () . count () , 4) ; assert_eq ! (ascii . lines () . rev () . count () , joined . lines () . rev () . count ()) ; for (asciiline , line) in ascii . lines () . rev () . zip (joined . lines () . rev ()) { assert_eq ! (asciiline , line) ; } let mut iter = ascii . lines () ; assert_eq ! (iter . next () , Some ("foo" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next_back () , Some ("baz" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next_back () , Some ("" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next () , Some ("bar" . as_ascii_str () . unwrap ())) ; } # [test] fn lines_iter_empty () { assert_eq ! ("" . as_ascii_str () . unwrap () . lines () . next () , None) ; assert_eq ! ("" . as_ascii_str () . unwrap () . lines () . next_back () , None) ; assert_eq ! ("" . lines () . next () , None) ; } # [test] fn split_str () { fn split_equals_str (haystack : & str , needle : char) { let mut strs = haystack . split (needle) ; let mut asciis = haystack . as_ascii_str () . unwrap () . split (AsciiChar :: from_ascii (needle) . unwrap ()) . map (| a | a . as_str ()) ; loop { assert_eq ! (asciis . size_hint () , strs . size_hint ()) ; let (a , s) = (asciis . next () , strs . next ()) ; assert_eq ! (a , s) ; if a == None { break ; } } if strs . next () == None { assert_eq ! (asciis . next () , None) ; } } split_equals_str ("" , '=') ; split_equals_str ("1,2,3" , ',') ; split_equals_str ("foo;bar;baz;" , ';') ; split_equals_str ("|||" , '|') ; split_equals_str (" a  b  c " , ' ') ; } # [test] fn split_str_rev () { let words = " foo  bar baz " ; let ascii = words . as_ascii_str () . unwrap () ; for (word , asciiword) in words . split (' ') . rev () . zip (ascii . split (AsciiChar :: Space) . rev ()) { assert_eq ! (asciiword , word) ; } let mut iter = ascii . split (AsciiChar :: Space) ; assert_eq ! (iter . next () , Some ("" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next_back () , Some ("" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next () , Some ("foo" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next_back () , Some ("baz" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next_back () , Some ("bar" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next () , Some ("" . as_ascii_str () . unwrap ())) ; assert_eq ! (iter . next_back () , None) ; } # [test] fn split_str_empty () { let empty = < & AsciiStr > :: default () ; let mut iter = empty . split (AsciiChar :: NAK) ; assert_eq ! (iter . next () , Some (empty)) ; assert_eq ! (iter . next () , None) ; let mut iter = empty . split (AsciiChar :: NAK) ; assert_eq ! (iter . next_back () , Some (empty)) ; assert_eq ! (iter . next_back () , None) ; assert_eq ! ("" . split ('s') . next () , Some ("")) ; } # [test] # [cfg (feature = "std")] fn fmt_ascii_str () { let s = "abc" . as_ascii_str () . unwrap () ; assert_eq ! (format ! ("{}" , s) , "abc" . to_string ()) ; assert_eq ! (format ! ("{:?}" , s) , "\"abc\"" . to_string ()) ; } } } # [cfg (feature = "std")] mod ascii_string { use std :: { fmt , mem } ; use std :: borrow :: { Borrow , BorrowMut , Cow } ; use std :: error :: Error ; use std :: ffi :: { CStr , CString } ; use std :: any :: Any ; use std :: str :: FromStr ; use std :: ops :: { Deref , DerefMut , Add , AddAssign , Index , IndexMut } ; use std :: iter :: FromIterator ; use ascii_char :: AsciiChar ; use ascii_str :: { AsciiStr , AsAsciiStr , AsAsciiStrError } ; # [doc = " A growable string stored as an ASCII encoded buffer."] # [derive (Clone , Default , PartialEq , Eq , PartialOrd , Ord , Hash)] # [repr (transparent)] pub struct AsciiString { vec : Vec < AsciiChar > , } impl AsciiString { # [doc = " Creates a new, empty ASCII string buffer without allocating."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::new();"] # [doc = " ```"] # [inline] pub fn new () -> Self { AsciiString { vec : Vec :: new () } } # [doc = " Creates a new ASCII string buffer with the given capacity."] # [doc = " The string will be able to hold exactly `capacity` bytes without reallocating."] # [doc = " If `capacity` is 0, the ASCII string will not allocate."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::with_capacity(10);"] # [doc = " ```"] # [inline] pub fn with_capacity (capacity : usize) -> Self { AsciiString { vec : Vec :: with_capacity (capacity) } } # [doc = " Creates a new `AsciiString` from a length, capacity and pointer."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " This is highly unsafe, due to the number of invariants that aren't checked:"] # [doc = ""] # [doc = " * The memory at `ptr` need to have been previously allocated by the same allocator this"] # [doc = "   library uses."] # [doc = " * `length` needs to be less than or equal to `capacity`."] # [doc = " * `capacity` needs to be the correct value."] # [doc = ""] # [doc = " Violating these may cause problems like corrupting the allocator's internal datastructures."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " use std::mem;"] # [doc = ""] # [doc = " unsafe {"] # [doc = "    let s = AsciiString::from_ascii(\"hello\").unwrap();"] # [doc = "    let ptr = s.as_ptr();"] # [doc = "    let len = s.len();"] # [doc = "    let capacity = s.capacity();"] # [doc = ""] # [doc = "    mem::forget(s);"] # [doc = ""] # [doc = "    let s = AsciiString::from_raw_parts(ptr as *mut _, len, capacity);"] # [doc = ""] # [doc = "    assert_eq!(AsciiString::from_ascii(\"hello\").unwrap(), s);"] # [doc = " }"] # [doc = " ```"] # [inline] pub unsafe fn from_raw_parts (buf : * mut AsciiChar , length : usize , capacity : usize) -> Self { AsciiString { vec : Vec :: from_raw_parts (buf , length , capacity) } } # [doc = " Converts a vector of bytes to an `AsciiString` without checking for non-ASCII characters."] # [doc = ""] # [doc = " # Safety"] # [doc = " This function is unsafe because it does not check that the bytes passed to it are valid"] # [doc = " ASCII characters. If this constraint is violated, it may cause memory unsafety issues with"] # [doc = " future of the `AsciiString`, as the rest of this library assumes that `AsciiString`s are"] # [doc = " ASCII encoded."] # [inline] pub unsafe fn from_ascii_unchecked < B > (bytes : B) -> Self where B : Into < Vec < u8 > > , { let mut bytes = bytes . into () ; let vec = Vec :: from_raw_parts (bytes . as_mut_ptr () as * mut AsciiChar , bytes . len () , bytes . capacity () ,) ; mem :: forget (bytes) ; AsciiString { vec } } # [doc = " Converts anything that can represent a byte buffer into an `AsciiString`."] # [doc = ""] # [doc = " # Failure"] # [doc = " Returns the byte buffer if not all of the bytes are ASCII characters."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let foo = AsciiString::from_ascii(\"foo\".to_string()).unwrap();"] # [doc = " let err = AsciiString::from_ascii(\"\".to_string()).unwrap_err();"] # [doc = " assert_eq!(foo.as_str(), \"foo\");"] # [doc = " assert_eq!(err.into_source(), \"\");"] # [doc = " ```"] pub fn from_ascii < B > (bytes : B) -> Result < AsciiString , FromAsciiError < B > > where B : Into < Vec < u8 > > + AsRef < [u8] > , { unsafe { match bytes . as_ref () . as_ascii_str () { Ok (_) => Ok (AsciiString :: from_ascii_unchecked (bytes)) , Err (e) => Err (FromAsciiError { error : e , owner : bytes , }) , } } } # [doc = " Pushes the given ASCII string onto this ASCII string buffer."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::{AsciiString, AsAsciiStr};"] # [doc = " use std::str::FromStr;"] # [doc = " let mut s = AsciiString::from_str(\"foo\").unwrap();"] # [doc = " s.push_str(\"bar\".as_ascii_str().unwrap());"] # [doc = " assert_eq!(s, \"foobar\".as_ascii_str().unwrap());"] # [doc = " ```"] # [inline] pub fn push_str (& mut self , string : & AsciiStr) { self . vec . extend (string . chars ()) } # [doc = " Returns the number of bytes that this ASCII string buffer can hold without reallocating."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let s = String::with_capacity(10);"] # [doc = " assert!(s.capacity() >= 10);"] # [doc = " ```"] # [inline] pub fn capacity (& self) -> usize { self . vec . capacity () } # [doc = " Reserves capacity for at least `additional` more bytes to be inserted in the given"] # [doc = " `AsciiString`. The collection may reserve more space to avoid frequent reallocations."] # [doc = ""] # [doc = " # Panics"] # [doc = " Panics if the new capacity overflows `usize`."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::new();"] # [doc = " s.reserve(10);"] # [doc = " assert!(s.capacity() >= 10);"] # [doc = " ```"] # [inline] pub fn reserve (& mut self , additional : usize) { self . vec . reserve (additional) } # [doc = " Reserves the minimum capacity for exactly `additional` more bytes to be inserted in the"] # [doc = " given `AsciiString`. Does nothing if the capacity is already sufficient."] # [doc = ""] # [doc = " Note that the allocator may give the collection more space than it requests. Therefore"] # [doc = " capacity can not be relied upon to be precisely minimal. Prefer `reserve` if future"] # [doc = " insertions are expected."] # [doc = ""] # [doc = " # Panics"] # [doc = " Panics if the new capacity overflows `usize`."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::new();"] # [doc = " s.reserve_exact(10);"] # [doc = " assert!(s.capacity() >= 10);"] # [doc = " ```"] # [inline] pub fn reserve_exact (& mut self , additional : usize) { self . vec . reserve_exact (additional) } # [doc = " Shrinks the capacity of this ASCII string buffer to match it's length."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " use std::str::FromStr;"] # [doc = " let mut s = AsciiString::from_str(\"foo\").unwrap();"] # [doc = " s.reserve(100);"] # [doc = " assert!(s.capacity() >= 100);"] # [doc = " s.shrink_to_fit();"] # [doc = " assert_eq!(s.capacity(), 3);"] # [doc = " ```"] # [inline] pub fn shrink_to_fit (& mut self) { self . vec . shrink_to_fit () } # [doc = " Adds the given ASCII character to the end of the ASCII string."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::{ AsciiChar, AsciiString};"] # [doc = " let mut s = AsciiString::from_ascii(\"abc\").unwrap();"] # [doc = " s.push(AsciiChar::from_ascii('1').unwrap());"] # [doc = " s.push(AsciiChar::from_ascii('2').unwrap());"] # [doc = " s.push(AsciiChar::from_ascii('3').unwrap());"] # [doc = " assert_eq!(s, \"abc123\");"] # [doc = " ```"] # [inline] pub fn push (& mut self , ch : AsciiChar) { self . vec . push (ch) } # [doc = " Shortens a ASCII string to the specified length."] # [doc = ""] # [doc = " # Panics"] # [doc = " Panics if `new_len` > current length."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::from_ascii(\"hello\").unwrap();"] # [doc = " s.truncate(2);"] # [doc = " assert_eq!(s, \"he\");"] # [doc = " ```"] # [inline] pub fn truncate (& mut self , new_len : usize) { self . vec . truncate (new_len) } # [doc = " Removes the last character from the ASCII string buffer and returns it."] # [doc = " Returns `None` if this string buffer is empty."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::from_ascii(\"foo\").unwrap();"] # [doc = " assert_eq!(s.pop().map(|c| c.as_char()), Some('o'));"] # [doc = " assert_eq!(s.pop().map(|c| c.as_char()), Some('o'));"] # [doc = " assert_eq!(s.pop().map(|c| c.as_char()), Some('f'));"] # [doc = " assert_eq!(s.pop(), None);"] # [doc = " ```"] # [inline] pub fn pop (& mut self) -> Option < AsciiChar > { self . vec . pop () } # [doc = " Removes the ASCII character at position `idx` from the buffer and returns it."] # [doc = ""] # [doc = " # Warning"] # [doc = " This is an O(n) operation as it requires copying every element in the buffer."] # [doc = ""] # [doc = " # Panics"] # [doc = " If `idx` is out of bounds this function will panic."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::from_ascii(\"foo\").unwrap();"] # [doc = " assert_eq!(s.remove(0).as_char(), 'f');"] # [doc = " assert_eq!(s.remove(1).as_char(), 'o');"] # [doc = " assert_eq!(s.remove(0).as_char(), 'o');"] # [doc = " ```"] # [inline] pub fn remove (& mut self , idx : usize) -> AsciiChar { self . vec . remove (idx) } # [doc = " Inserts an ASCII character into the buffer at position `idx`."] # [doc = ""] # [doc = " # Warning"] # [doc = " This is an O(n) operation as it requires copying every element in the buffer."] # [doc = ""] # [doc = " # Panics"] # [doc = " If `idx` is out of bounds this function will panic."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::{AsciiString,AsciiChar};"] # [doc = " let mut s = AsciiString::from_ascii(\"foo\").unwrap();"] # [doc = " s.insert(2, AsciiChar::b);"] # [doc = " assert_eq!(s, \"fobo\");"] # [doc = " ```"] # [inline] pub fn insert (& mut self , idx : usize , ch : AsciiChar) { self . vec . insert (idx , ch) } # [doc = " Returns the number of bytes in this ASCII string."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let s = AsciiString::from_ascii(\"foo\").unwrap();"] # [doc = " assert_eq!(s.len(), 3);"] # [doc = " ```"] # [inline] pub fn len (& self) -> usize { self . vec . len () } # [doc = " Returns true if the ASCII string contains zero bytes."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::{AsciiChar, AsciiString};"] # [doc = " let mut s = AsciiString::new();"] # [doc = " assert!(s.is_empty());"] # [doc = " s.push(AsciiChar::from_ascii('a').unwrap());"] # [doc = " assert!(!s.is_empty());"] # [doc = " ```"] # [inline] pub fn is_empty (& self) -> bool { self . len () == 0 } # [doc = " Truncates the ASCII string, setting length (but not capacity) to zero."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::AsciiString;"] # [doc = " let mut s = AsciiString::from_ascii(\"foo\").unwrap();"] # [doc = " s.clear();"] # [doc = " assert!(s.is_empty());"] # [doc = " ```"] # [inline] pub fn clear (& mut self) { self . vec . clear () } } impl Deref for AsciiString { type Target = AsciiStr ; # [inline] fn deref (& self) -> & AsciiStr { self . vec . as_slice () . as_ref () } } impl DerefMut for AsciiString { # [inline] fn deref_mut (& mut self) -> & mut AsciiStr { self . vec . as_mut_slice () . as_mut () } } impl PartialEq < str > for AsciiString { # [inline] fn eq (& self , other : & str) -> bool { * * self == * other } } impl PartialEq < AsciiString > for str { # [inline] fn eq (& self , other : & AsciiString) -> bool { * * other == * self } } macro_rules ! impl_eq { ($ lhs : ty , $ rhs : ty) => { impl <'a > PartialEq <$ rhs > for $ lhs { # [inline] fn eq (& self , other : &$ rhs) -> bool { PartialEq :: eq (&** self , &** other) } } } } impl_eq ! { AsciiString , String } impl_eq ! { String , AsciiString } impl_eq ! { &'a AsciiStr , String } impl_eq ! { String , &'a AsciiStr } impl_eq ! { &'a AsciiStr , AsciiString } impl_eq ! { AsciiString , &'a AsciiStr } impl_eq ! { &'a str , AsciiString } impl_eq ! { AsciiString , &'a str } impl Borrow < AsciiStr > for AsciiString { # [inline] fn borrow (& self) -> & AsciiStr { & * self } } impl BorrowMut < AsciiStr > for AsciiString { # [inline] fn borrow_mut (& mut self) -> & mut AsciiStr { & mut * self } } impl From < Vec < AsciiChar > > for AsciiString { # [inline] fn from (vec : Vec < AsciiChar >) -> Self { AsciiString { vec } } } impl Into < Vec < u8 > > for AsciiString { fn into (self) -> Vec < u8 > { unsafe { let v = Vec :: from_raw_parts (self . vec . as_ptr () as * mut u8 , self . vec . len () , self . vec . capacity () ,) ; mem :: forget (self) ; v } } } impl < 'a > From < & 'a AsciiStr > for AsciiString { # [inline] fn from (s : & 'a AsciiStr) -> Self { s . to_ascii_string () } } impl < 'a > From < & 'a [AsciiChar] > for AsciiString { # [inline] fn from (s : & 'a [AsciiChar]) -> AsciiString { s . iter () . cloned () . collect () } } impl Into < String > for AsciiString { # [inline] fn into (self) -> String { unsafe { String :: from_utf8_unchecked (self . into ()) } } } impl < 'a > From < Cow < 'a , AsciiStr > > for AsciiString { fn from (cow : Cow < 'a , AsciiStr >) -> AsciiString { cow . into_owned () } } impl From < AsciiString > for Cow < 'static , AsciiStr > { fn from (string : AsciiString) -> Cow < 'static , AsciiStr > { Cow :: Owned (string) } } impl < 'a > From < & 'a AsciiStr > for Cow < 'a , AsciiStr > { fn from (s : & 'a AsciiStr) -> Cow < 'a , AsciiStr > { Cow :: Borrowed (s) } } impl AsRef < AsciiStr > for AsciiString { # [inline] fn as_ref (& self) -> & AsciiStr { & * self } } impl AsRef < [AsciiChar] > for AsciiString { # [inline] fn as_ref (& self) -> & [AsciiChar] { & self . vec } } impl AsRef < [u8] > for AsciiString { # [inline] fn as_ref (& self) -> & [u8] { self . as_bytes () } } impl AsRef < str > for AsciiString { # [inline] fn as_ref (& self) -> & str { self . as_str () } } impl AsMut < AsciiStr > for AsciiString { # [inline] fn as_mut (& mut self) -> & mut AsciiStr { & mut * self } } impl AsMut < [AsciiChar] > for AsciiString { # [inline] fn as_mut (& mut self) -> & mut [AsciiChar] { & mut self . vec } } impl FromStr for AsciiString { type Err = AsAsciiStrError ; fn from_str (s : & str) -> Result < AsciiString , AsAsciiStrError > { s . as_ascii_str () . map (AsciiStr :: to_ascii_string) } } impl fmt :: Display for AsciiString { # [inline] fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Display :: fmt (& * * self , f) } } impl fmt :: Debug for AsciiString { # [inline] fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Debug :: fmt (& * * self , f) } } # [doc = " Please note that the `std::fmt::Result` returned by these methods does not support"] # [doc = " transmission of an error other than that an error occurred."] impl fmt :: Write for AsciiString { fn write_str (& mut self , s : & str) -> fmt :: Result { if let Ok (astr) = AsciiStr :: from_ascii (s) { self . push_str (astr) ; Ok (()) } else { Err (fmt :: Error) } } fn write_char (& mut self , c : char) -> fmt :: Result { if let Ok (achar) = AsciiChar :: from_ascii (c) { self . push (achar) ; Ok (()) } else { Err (fmt :: Error) } } } impl < A : AsRef < AsciiStr > > FromIterator < A > for AsciiString { fn from_iter < I : IntoIterator < Item = A > > (iter : I) -> AsciiString { let mut buf = AsciiString :: new () ; buf . extend (iter) ; buf } } impl < A : AsRef < AsciiStr > > Extend < A > for AsciiString { fn extend < I : IntoIterator < Item = A > > (& mut self , iterable : I) { let iterator = iterable . into_iter () ; let (lower_bound , _) = iterator . size_hint () ; self . reserve (lower_bound) ; for item in iterator { self . push_str (item . as_ref ()) } } } impl < 'a > Add < & 'a AsciiStr > for AsciiString { type Output = AsciiString ; # [inline] fn add (mut self , other : & AsciiStr) -> AsciiString { self . push_str (other) ; self } } impl < 'a > AddAssign < & 'a AsciiStr > for AsciiString { # [inline] fn add_assign (& mut self , other : & AsciiStr) { self . push_str (other) ; } } impl < T > Index < T > for AsciiString where AsciiStr : Index < T > , { type Output = < AsciiStr as Index < T > > :: Output ; # [inline] fn index (& self , index : T) -> & < AsciiStr as Index < T > > :: Output { & (* * self) [index] } } impl < T > IndexMut < T > for AsciiString where AsciiStr : IndexMut < T > , { # [inline] fn index_mut (& mut self , index : T) -> & mut < AsciiStr as Index < T > > :: Output { & mut (* * self) [index] } } # [doc = " A possible error value when converting an `AsciiString` from a byte vector or string."] # [doc = " It wraps an `AsAsciiStrError` which you can get through the `ascii_error()` method."] # [doc = ""] # [doc = " This is the error type for `AsciiString::from_ascii()` and"] # [doc = " `IntoAsciiString::into_ascii_string()`. They will never clone or touch the content of the"] # [doc = " original type; It can be extracted by the `into_source` method."] # [doc = ""] # [doc = " #Examples"] # [doc = " ```"] # [doc = " # use ascii::IntoAsciiString;"] # [doc = " let err = \"b!\".to_string().into_ascii_string().unwrap_err();"] # [doc = " assert_eq!(err.ascii_error().valid_up_to(), 1);"] # [doc = " assert_eq!(err.into_source(), \"b!\".to_string());"] # [doc = " ```"] # [derive (Clone , Copy , PartialEq , Eq)] pub struct FromAsciiError < O > { error : AsAsciiStrError , owner : O , } impl < O > FromAsciiError < O > { # [doc = " Get the position of the first non-ASCII byte or character."] # [inline] pub fn ascii_error (& self) -> AsAsciiStrError { self . error } # [doc = " Get back the original, unmodified type."] # [inline] pub fn into_source (self) -> O { self . owner } } impl < O > fmt :: Debug for FromAsciiError < O > { # [inline] fn fmt (& self , fmtr : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Debug :: fmt (& self . error , fmtr) } } impl < O > fmt :: Display for FromAsciiError < O > { # [inline] fn fmt (& self , fmtr : & mut fmt :: Formatter) -> fmt :: Result { fmt :: Display :: fmt (& self . error , fmtr) } } impl < O : Any > Error for FromAsciiError < O > { # [inline] fn description (& self) -> & str { self . error . description () } # [doc = " Always returns an `AsAsciiStrError`"] fn cause (& self) -> Option < & dyn Error > { Some (& self . error as & dyn Error) } } # [doc = " Convert vectors into `AsciiString`."] pub trait IntoAsciiString : Sized { # [doc = " Convert to `AsciiString` without checking for non-ASCII characters."] unsafe fn into_ascii_string_unchecked (self) -> AsciiString ; # [doc = " Convert to `AsciiString`."] fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > ; } impl IntoAsciiString for Vec < AsciiChar > { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from (self) } # [inline] fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > { Ok (AsciiString :: from (self)) } } impl < 'a > IntoAsciiString for & 'a [AsciiChar] { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from (self) } # [inline] fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > { Ok (AsciiString :: from (self)) } } impl < 'a > IntoAsciiString for & 'a AsciiStr { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from (self) } # [inline] fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > { Ok (AsciiString :: from (self)) } } macro_rules ! impl_into_ascii_string { ('a , $ wider : ty) => { impl <'a > IntoAsciiString for $ wider { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from_ascii_unchecked (self) } # [inline] fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self >> { AsciiString :: from_ascii (self) } } } ; ($ wider : ty) => { impl IntoAsciiString for $ wider { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from_ascii_unchecked (self) } # [inline] fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self >> { AsciiString :: from_ascii (self) } } } ; } impl_into_ascii_string ! { AsciiString } impl_into_ascii_string ! { Vec < u8 > } impl_into_ascii_string ! { 'a , &'a [u8] } impl_into_ascii_string ! { String } impl_into_ascii_string ! { 'a , &'a str } # [doc = " Note that the trailing null byte will be removed in the conversion."] impl IntoAsciiString for CString { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from_ascii_unchecked (self . into_bytes ()) } fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > { AsciiString :: from_ascii (self . into_bytes_with_nul ()) . map_err (| FromAsciiError { error , owner } | { FromAsciiError { owner : unsafe { CString :: from_vec_unchecked (owner) } , error , } }) . map (| mut s | { let _nul = s . pop () ; debug_assert_eq ! (_nul , Some (AsciiChar :: Null)) ; s }) } } # [doc = " Note that the trailing null byte will be removed in the conversion."] impl < 'a > IntoAsciiString for & 'a CStr { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { AsciiString :: from_ascii_unchecked (self . to_bytes ()) } fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > { AsciiString :: from_ascii (self . to_bytes_with_nul ()) . map_err (| FromAsciiError { error , owner } | { FromAsciiError { owner : unsafe { CStr :: from_ptr (owner . as_ptr () as * const _) } , error , } }) . map (| mut s | { let _nul = s . pop () ; debug_assert_eq ! (_nul , Some (AsciiChar :: Null)) ; s }) } } impl < 'a , B : ? Sized > IntoAsciiString for Cow < 'a , B > where B : 'a + ToOwned , & 'a B : IntoAsciiString , < B as ToOwned > :: Owned : IntoAsciiString , { # [inline] unsafe fn into_ascii_string_unchecked (self) -> AsciiString { IntoAsciiString :: into_ascii_string_unchecked (self . into_owned ()) } fn into_ascii_string (self) -> Result < AsciiString , FromAsciiError < Self > > { match self { Cow :: Owned (b) => { IntoAsciiString :: into_ascii_string (b) . map_err (| FromAsciiError { error , owner } | { FromAsciiError { owner : Cow :: Owned (owner) , error , } }) } Cow :: Borrowed (b) => { IntoAsciiString :: into_ascii_string (b) . map_err (| FromAsciiError { error , owner } | { FromAsciiError { owner : Cow :: Borrowed (owner) , error , } }) } } } } # [cfg (test)] mod tests { use std :: str :: FromStr ; use std :: ffi :: CString ; use AsciiChar ; use super :: { AsciiString , IntoAsciiString } ; # [test] fn into_string () { let v = AsciiString :: from_ascii (& [40_u8 , 32 , 59] [..]) . unwrap () ; assert_eq ! (Into ::< String >:: into (v) , "( ;" . to_string ()) ; } # [test] fn into_bytes () { let v = AsciiString :: from_ascii (& [40_u8 , 32 , 59] [..]) . unwrap () ; assert_eq ! (Into ::< Vec < u8 >>:: into (v) , vec ! [40_u8 , 32 , 59]) } # [test] fn from_ascii_vec () { let vec = vec ! [AsciiChar :: from_ascii ('A') . unwrap () , AsciiChar :: from_ascii ('B') . unwrap ()] ; assert_eq ! (AsciiString :: from (vec) , AsciiString :: from_str ("AB") . unwrap ()) ; } # [test] fn from_cstring () { let cstring = CString :: new ("baz") . unwrap () ; let ascii_str = cstring . clone () . into_ascii_string () . unwrap () ; let expected_chars = & [AsciiChar :: b , AsciiChar :: a , AsciiChar :: z] ; assert_eq ! (ascii_str . len () , 3) ; assert_eq ! (ascii_str . as_slice () , expected_chars) ; let ascii_str_unchecked = unsafe { cstring . into_ascii_string_unchecked () } ; assert_eq ! (ascii_str_unchecked . len () , 3) ; assert_eq ! (ascii_str_unchecked . as_slice () , expected_chars) ; let sparkle_heart_bytes = vec ! [240u8 , 159 , 146 , 150] ; let cstring = CString :: new (sparkle_heart_bytes) . unwrap () ; let cstr = & * cstring ; let ascii_err = cstr . into_ascii_string () . unwrap_err () ; assert_eq ! (ascii_err . into_source () , &* cstring) ; } # [test] fn fmt_ascii_string () { let s = "abc" . to_string () . into_ascii_string () . unwrap () ; assert_eq ! (format ! ("{}" , s) , "abc" . to_string ()) ; assert_eq ! (format ! ("{:?}" , s) , "\"abc\"" . to_string ()) ; } # [test] fn write_fmt () { use std :: { fmt , str } ; let mut s0 = AsciiString :: new () ; fmt :: write (& mut s0 , format_args ! ("Hello World")) . unwrap () ; assert_eq ! (s0 , "Hello World") ; let mut s1 = AsciiString :: new () ; fmt :: write (& mut s1 , format_args ! ("{}" , 9)) . unwrap () ; assert_eq ! (s1 , "9") ; let mut s2 = AsciiString :: new () ; let sparkle_heart_bytes = [240 , 159 , 146 , 150] ; let sparkle_heart = str :: from_utf8 (& sparkle_heart_bytes) . unwrap () ; assert ! (fmt :: write (& mut s2 , format_args ! ("{}" , sparkle_heart)) . is_err ()) ; } } } mod free_functions { use ascii_char :: { AsciiChar , ToAsciiChar } ; # [doc = " Terminals use [caret notation](https://en.wikipedia.org/wiki/Caret_notation)"] # [doc = " to display some typed control codes, such as ^D for EOT and ^Z for SUB."] # [doc = ""] # [doc = " This function returns the caret notation letter for control codes,"] # [doc = " or `None` for printable characters."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " # use ascii::{AsciiChar, caret_encode};"] # [doc = " assert_eq!(caret_encode(b'\\0'), Some(AsciiChar::At));"] # [doc = " assert_eq!(caret_encode(AsciiChar::DEL), Some(AsciiChar::Question));"] # [doc = " assert_eq!(caret_encode(b'E'), None);"] # [doc = " assert_eq!(caret_encode(b'\\n'), Some(AsciiChar::J));"] # [doc = " ```"] pub fn caret_encode < C : Copy + Into < u8 > > (c : C) -> Option < AsciiChar > { let c = c . into () ^ 0b0100_0000 ; unsafe { if c >= b'?' && c <= b'_' { Some (c . to_ascii_char_unchecked ()) } else { None } } } # [doc = " Returns the control code represented by a [caret notation](https://en.wikipedia.org/wiki/Caret_notation)"] # [doc = " letter, or `None` if the letter is not used in caret notation."] # [doc = ""] # [doc = " This function is the inverse of `caret_encode()`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " # use ascii::{AsciiChar, caret_decode};"] # [doc = " assert_eq!(caret_decode(b'?'), Some(AsciiChar::DEL));"] # [doc = " assert_eq!(caret_decode(AsciiChar::D), Some(AsciiChar::EOT));"] # [doc = " assert_eq!(caret_decode(b'\\0'), None);"] # [doc = " ```"] # [doc = ""] # [doc = " Symmetry:"] # [doc = ""] # [doc = " ```"] # [doc = " # use ascii::{AsciiChar, caret_encode, caret_decode};"] # [doc = " assert_eq!(caret_encode(AsciiChar::US).and_then(caret_decode), Some(AsciiChar::US));"] # [doc = " assert_eq!(caret_decode(b'@').and_then(caret_encode), Some(AsciiChar::At));"] # [doc = " ```"] pub fn caret_decode < C : Copy + Into < u8 > > (c : C) -> Option < AsciiChar > { unsafe { match c . into () { b'?' ..= b'_' => Some (AsciiChar :: from_ascii_unchecked (c . into () ^ 0b0100_0000)) , _ => None , } } } } # [cfg (feature = "serde")] mod serialization { mod ascii_char { use std :: fmt ; use serde :: de :: { Error , Unexpected , Visitor } ; use serde :: { Deserialize , Deserializer , Serialize , Serializer } ; use ascii_char :: AsciiChar ; impl Serialize for AsciiChar { # [inline] fn serialize < S : Serializer > (& self , serializer : S) -> Result < S :: Ok , S :: Error > { serializer . serialize_char (self . as_char ()) } } struct AsciiCharVisitor ; impl < 'de > Visitor < 'de > for AsciiCharVisitor { type Value = AsciiChar ; fn expecting (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . write_str ("an ascii character") } # [inline] fn visit_char < E : Error > (self , v : char) -> Result < Self :: Value , E > { AsciiChar :: from_ascii (v) . map_err (| _ | Error :: invalid_value (Unexpected :: Char (v) , & self)) } # [inline] fn visit_str < E : Error > (self , v : & str) -> Result < Self :: Value , E > { if v . len () == 1 { let c = v . chars () . next () . unwrap () ; self . visit_char (c) } else { Err (Error :: invalid_value (Unexpected :: Str (v) , & self)) } } } impl < 'de > Deserialize < 'de > for AsciiChar { fn deserialize < D > (deserializer : D) -> Result < AsciiChar , D :: Error > where D : Deserializer < 'de > , { deserializer . deserialize_char (AsciiCharVisitor) } } # [cfg (test)] mod tests { use super :: * ; # [cfg (feature = "serde_test")] const ASCII_CHAR : char = 'e' ; # [cfg (feature = "serde_test")] const ASCII_STR : & str = "e" ; # [cfg (feature = "serde_test")] const UNICODE_CHAR : char = '' ; # [test] fn basic () { fn assert_serialize < T : Serialize > () { } assert_serialize :: < AsciiChar > () ; fn assert_deserialize < 'de , T : Deserialize < 'de > > () { } assert_deserialize :: < AsciiChar > () ; } # [test] # [cfg (feature = "serde_test")] fn serialize () { use serde_test :: { assert_tokens , Token } ; let ascii_char = AsciiChar :: from_ascii (ASCII_CHAR) . unwrap () ; assert_tokens (& ascii_char , & [Token :: Char (ASCII_CHAR)]) ; } # [test] # [cfg (feature = "serde_test")] fn deserialize () { use serde_test :: { assert_de_tokens , assert_de_tokens_error , Token } ; let ascii_char = AsciiChar :: from_ascii (ASCII_CHAR) . unwrap () ; assert_de_tokens (& ascii_char , & [Token :: String (ASCII_STR)]) ; assert_de_tokens (& ascii_char , & [Token :: Str (ASCII_STR)]) ; assert_de_tokens (& ascii_char , & [Token :: BorrowedStr (ASCII_STR)]) ; assert_de_tokens_error :: < AsciiChar > (& [Token :: Char (UNICODE_CHAR)] , "invalid value: character ``, expected an ascii character" ,) ; } } } mod ascii_str { use std :: fmt ; use serde :: de :: { Error , Unexpected , Visitor } ; use serde :: { Deserialize , Deserializer , Serialize , Serializer } ; use ascii_str :: AsciiStr ; impl Serialize for AsciiStr { # [inline] fn serialize < S : Serializer > (& self , serializer : S) -> Result < S :: Ok , S :: Error > { serializer . serialize_str (self . as_str ()) } } struct AsciiStrVisitor ; impl < 'a > Visitor < 'a > for AsciiStrVisitor { type Value = & 'a AsciiStr ; fn expecting (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . write_str ("a borrowed ascii string") } fn visit_borrowed_str < E : Error > (self , v : & 'a str) -> Result < Self :: Value , E > { AsciiStr :: from_ascii (v . as_bytes ()) . map_err (| _ | Error :: invalid_value (Unexpected :: Str (v) , & self)) } fn visit_borrowed_bytes < E : Error > (self , v : & 'a [u8]) -> Result < Self :: Value , E > { AsciiStr :: from_ascii (v) . map_err (| _ | Error :: invalid_value (Unexpected :: Bytes (v) , & self)) } } impl < 'de : 'a , 'a > Deserialize < 'de > for & 'a AsciiStr { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : Deserializer < 'de > , { deserializer . deserialize_str (AsciiStrVisitor) } } # [cfg (test)] mod tests { use super :: * ; # [cfg (feature = "serde_test")] const ASCII : & str = "Francais" ; # [cfg (feature = "serde_test")] const UNICODE : & str = "Franais" ; # [test] fn basic () { fn assert_serialize < T : Serialize > () { } assert_serialize :: < & AsciiStr > () ; fn assert_deserialize < 'de , T : Deserialize < 'de > > () { } assert_deserialize :: < & AsciiStr > () ; } # [test] # [cfg (feature = "serde_test")] fn serialize () { use serde_test :: { assert_tokens , Token } ; let ascii_str = AsciiStr :: from_ascii (ASCII) . unwrap () ; assert_tokens (& ascii_str , & [Token :: BorrowedStr (ASCII)]) ; } # [test] # [cfg (feature = "serde_test")] fn deserialize () { use serde_test :: { assert_de_tokens , assert_de_tokens_error , Token } ; let ascii_str = AsciiStr :: from_ascii (ASCII) . unwrap () ; assert_de_tokens (& ascii_str , & [Token :: BorrowedBytes (ASCII . as_bytes ())]) ; assert_de_tokens_error :: < & AsciiStr > (& [Token :: BorrowedStr (UNICODE)] , "invalid value: string \"Franais\", expected a borrowed ascii string" ,) ; } } } mod ascii_string { use std :: fmt ; use serde :: de :: { Error , Unexpected , Visitor } ; use serde :: { Deserialize , Deserializer , Serialize , Serializer } ; use ascii_str :: AsciiStr ; use ascii_string :: AsciiString ; impl Serialize for AsciiString { # [inline] fn serialize < S : Serializer > (& self , serializer : S) -> Result < S :: Ok , S :: Error > { serializer . serialize_str (self . as_str ()) } } struct AsciiStringVisitor ; impl < 'de > Visitor < 'de > for AsciiStringVisitor { type Value = AsciiString ; fn expecting (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . write_str ("an ascii string") } fn visit_str < E : Error > (self , v : & str) -> Result < Self :: Value , E > { AsciiString :: from_ascii (v) . map_err (| _ | Error :: invalid_value (Unexpected :: Str (v) , & self)) } fn visit_string < E : Error > (self , v : String) -> Result < Self :: Value , E > { AsciiString :: from_ascii (v . as_bytes ()) . map_err (| _ | Error :: invalid_value (Unexpected :: Str (& v) , & self)) } fn visit_bytes < E : Error > (self , v : & [u8]) -> Result < Self :: Value , E > { AsciiString :: from_ascii (v) . map_err (| _ | Error :: invalid_value (Unexpected :: Bytes (& v) , & self)) } fn visit_byte_buf < E : Error > (self , v : Vec < u8 >) -> Result < Self :: Value , E > { AsciiString :: from_ascii (v . as_slice ()) . map_err (| _ | Error :: invalid_value (Unexpected :: Bytes (& v) , & self)) } } struct AsciiStringInPlaceVisitor < 'a > (& 'a mut AsciiString) ; impl < 'a , 'de > Visitor < 'de > for AsciiStringInPlaceVisitor < 'a > { type Value = () ; fn expecting (& self , formatter : & mut fmt :: Formatter) -> fmt :: Result { formatter . write_str ("an ascii string") } fn visit_str < E : Error > (self , v : & str) -> Result < Self :: Value , E > { let ascii_str = match AsciiStr :: from_ascii (v . as_bytes ()) { Ok (ascii_str) => ascii_str , Err (_) => return Err (Error :: invalid_value (Unexpected :: Str (v) , & self)) , } ; self . 0 . clear () ; self . 0 . push_str (ascii_str) ; Ok (()) } fn visit_string < E : Error > (self , v : String) -> Result < Self :: Value , E > { let ascii_string = match AsciiString :: from_ascii (v . as_bytes ()) { Ok (ascii_string) => ascii_string , Err (_) => return Err (Error :: invalid_value (Unexpected :: Str (& v) , & self)) , } ; * self . 0 = ascii_string ; Ok (()) } fn visit_bytes < E : Error > (self , v : & [u8]) -> Result < Self :: Value , E > { let ascii_str = match AsciiStr :: from_ascii (v) { Ok (ascii_str) => ascii_str , Err (_) => return Err (Error :: invalid_value (Unexpected :: Bytes (v) , & self)) , } ; self . 0 . clear () ; self . 0 . push_str (ascii_str) ; Ok (()) } fn visit_byte_buf < E : Error > (self , v : Vec < u8 >) -> Result < Self :: Value , E > { let ascii_string = match AsciiString :: from_ascii (v . as_slice ()) { Ok (ascii_string) => ascii_string , Err (_) => return Err (Error :: invalid_value (Unexpected :: Bytes (& v) , & self)) , } ; * self . 0 = ascii_string ; Ok (()) } } impl < 'de > Deserialize < 'de > for AsciiString { fn deserialize < D > (deserializer : D) -> Result < AsciiString , D :: Error > where D : Deserializer < 'de > , { deserializer . deserialize_string (AsciiStringVisitor) } fn deserialize_in_place < D > (deserializer : D , place : & mut Self) -> Result < () , D :: Error > where D : Deserializer < 'de > , { deserializer . deserialize_string (AsciiStringInPlaceVisitor (place)) } } # [cfg (test)] mod tests { use super :: * ; # [cfg (feature = "serde_test")] const ASCII : & str = "Francais" ; # [cfg (feature = "serde_test")] const UNICODE : & str = "Franais" ; # [test] fn basic () { fn assert_serialize < T : Serialize > () { } assert_serialize :: < AsciiString > () ; fn assert_deserialize < 'de , T : Deserialize < 'de > > () { } assert_deserialize :: < AsciiString > () ; } # [test] # [cfg (feature = "serde_test")] fn serialize () { use serde_test :: { assert_tokens , Token } ; let ascii_string = AsciiString :: from_ascii (ASCII) . unwrap () ; assert_tokens (& ascii_string , & [Token :: String (ASCII)]) ; assert_tokens (& ascii_string , & [Token :: Str (ASCII)]) ; assert_tokens (& ascii_string , & [Token :: BorrowedStr (ASCII)]) ; } # [test] # [cfg (feature = "serde_test")] fn deserialize () { use serde_test :: { assert_de_tokens , assert_de_tokens_error , Token } ; let ascii_string = AsciiString :: from_ascii (ASCII) . unwrap () ; assert_de_tokens (& ascii_string , & [Token :: Bytes (ASCII . as_bytes ())]) ; assert_de_tokens (& ascii_string , & [Token :: BorrowedBytes (ASCII . as_bytes ())]) ; assert_de_tokens (& ascii_string , & [Token :: ByteBuf (ASCII . as_bytes ())]) ; assert_de_tokens_error :: < AsciiString > (& [Token :: String (UNICODE)] , "invalid value: string \"Franais\", expected an ascii string" ,) ; } } } } pub use ascii_char :: { AsciiChar , ToAsciiChar , ToAsciiCharError } ; pub use ascii_str :: { AsciiStr , AsAsciiStr , AsMutAsciiStr , AsAsciiStrError } ; pub use ascii_str :: { Chars , CharsMut , CharsRef } ; # [cfg (feature = "std")] pub use ascii_string :: { AsciiString , IntoAsciiString , FromAsciiError } ; pub use free_functions :: { caret_encode , caret_decode } ; }mod itertools { # ! [warn (missing_docs)] # ! [crate_name = "itertools"] # ! [cfg_attr (not (feature = "use_std") , no_std)] # ! [doc = " Extra iterator adaptors, functions and macros."] # ! [doc = ""] # ! [doc = " To extend [`Iterator`] with methods in this crate, import"] # ! [doc = " the [`Itertools` trait](./trait.Itertools.html):"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " use itertools::Itertools;"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " Now, new methods like [`interleave`](./trait.Itertools.html#method.interleave)"] # ! [doc = " are available on all iterators:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " use itertools::Itertools;"] # ! [doc = ""] # ! [doc = " let it = (1..3).interleave(vec![-1, -2]);"] # ! [doc = " itertools::assert_equal(it, vec![1, -1, 2, -2]);"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " Most iterator methods are also provided as functions (with the benefit"] # ! [doc = " that they convert parameters using [`IntoIterator`]):"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " use itertools::interleave;"] # ! [doc = ""] # ! [doc = " for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {"] # ! [doc = "     /* loop body */"] # ! [doc = " }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " ## Crate Features"] # ! [doc = ""] # ! [doc = " - `use_std`"] # ! [doc = "   - Enabled by default."] # ! [doc = "   - Disable to compile itertools using `#![no_std]`. This disables"] # ! [doc = "     any items that depend on collections (like `group_by`, `unique`,"] # ! [doc = "     `kmerge`, `join` and many more)."] # ! [doc = ""] # ! [doc = " ## Rust Version"] # ! [doc = ""] # ! [doc = " This version of itertools requires Rust 1.32 or later."] # ! [doc = ""] # ! [doc = " [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"] # ! [doc (html_root_url = "https://docs.rs/itertools/0.8/")] # [cfg (not (feature = "use_std"))] extern crate core as std ; pub use either :: Either ; # [cfg (feature = "use_std")] use std :: collections :: HashMap ; use std :: iter :: { IntoIterator , once } ; use std :: cmp :: Ordering ; use std :: fmt ; # [cfg (feature = "use_std")] use std :: hash :: Hash ; # [cfg (feature = "use_std")] use std :: fmt :: Write ; # [cfg (feature = "use_std")] type VecIntoIter < T > = :: std :: vec :: IntoIter < T > ; # [cfg (feature = "use_std")] use std :: iter :: FromIterator ; # [macro_use] mod impl_macros { macro_rules ! debug_fmt_fields { ($ tyname : ident , $ ($ ($ field : ident) .+) ,*) => { fn fmt (& self , f : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { f . debug_struct (stringify ! ($ tyname)) $ (. field (stringify ! ($ ($ field) .+) , & self .$ ($ field) .+)) * . finish () } } } macro_rules ! clone_fields { ($ ($ field : ident) ,*) => { fn clone (& self) -> Self { Self { $ ($ field : self .$ field . clone () ,) * } } } } } # [doc (hidden)] pub use std :: iter as __std_iter ; # [doc = " The concrete iterator types."] pub mod structs { pub use crate :: adaptors :: { Dedup , DedupBy , Interleave , InterleaveShortest , Product , PutBack , Batching , MapInto , MapResults , Merge , MergeBy , TakeWhileRef , WhileSome , Coalesce , TupleCombinations , Positions , Update , } ; # [allow (deprecated)] pub use crate :: adaptors :: Step ; # [cfg (feature = "use_std")] pub use crate :: adaptors :: MultiProduct ; # [cfg (feature = "use_std")] pub use crate :: combinations :: Combinations ; # [cfg (feature = "use_std")] pub use crate :: combinations_with_replacement :: CombinationsWithReplacement ; pub use crate :: cons_tuples_impl :: ConsTuples ; pub use crate :: exactly_one_err :: ExactlyOneError ; pub use crate :: format :: { Format , FormatWith } ; # [cfg (feature = "use_std")] pub use crate :: groupbylazy :: { IntoChunks , Chunk , Chunks , GroupBy , Group , Groups } ; pub use crate :: intersperse :: Intersperse ; # [cfg (feature = "use_std")] pub use crate :: kmerge_impl :: { KMerge , KMergeBy } ; pub use crate :: merge_join :: MergeJoinBy ; # [cfg (feature = "use_std")] pub use crate :: multipeek_impl :: MultiPeek ; pub use crate :: pad_tail :: PadUsing ; pub use crate :: peeking_take_while :: PeekingTakeWhile ; # [cfg (feature = "use_std")] pub use crate :: permutations :: Permutations ; pub use crate :: process_results_impl :: ProcessResults ; # [cfg (feature = "use_std")] pub use crate :: put_back_n_impl :: PutBackN ; # [cfg (feature = "use_std")] pub use crate :: rciter_impl :: RcIter ; pub use crate :: repeatn :: RepeatN ; # [allow (deprecated)] pub use crate :: sources :: { RepeatCall , Unfold , Iterate } ; # [cfg (feature = "use_std")] pub use crate :: tee :: Tee ; pub use crate :: tuple_impl :: { TupleBuffer , TupleWindows , Tuples } ; # [cfg (feature = "use_std")] pub use crate :: unique_impl :: { Unique , UniqueBy } ; pub use crate :: with_position :: WithPosition ; pub use crate :: zip_eq_impl :: ZipEq ; pub use crate :: zip_longest :: ZipLongest ; pub use crate :: ziptuple :: Zip ; } # [doc = " Traits helpful for using certain `Itertools` methods in generic contexts."] pub mod traits { pub use crate :: tuple_impl :: HomogeneousTuple ; } # [allow (deprecated)] pub use crate :: structs :: * ; pub use crate :: concat_impl :: concat ; pub use crate :: cons_tuples_impl :: cons_tuples ; pub use crate :: diff :: diff_with ; pub use crate :: diff :: Diff ; # [cfg (feature = "use_std")] pub use crate :: kmerge_impl :: { kmerge_by } ; pub use crate :: minmax :: MinMaxResult ; pub use crate :: peeking_take_while :: PeekingNext ; pub use crate :: process_results_impl :: process_results ; pub use crate :: repeatn :: repeat_n ; # [allow (deprecated)] pub use crate :: sources :: { repeat_call , unfold , iterate } ; pub use crate :: with_position :: Position ; pub use crate :: ziptuple :: multizip ; mod adaptors { mod multi_product { use crate :: size_hint ; use crate :: Itertools ; # [derive (Clone)] # [doc = " An iterator adaptor that iterates over the cartesian product of"] # [doc = " multiple iterators of type `I`."] # [doc = ""] # [doc = " An iterator element type is `Vec<I>`."] # [doc = ""] # [doc = " See [`.multi_cartesian_product()`](../trait.Itertools.html#method.multi_cartesian_product)"] # [doc = " for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct MultiProduct < I > (Vec < MultiProductIter < I > >) where I : Iterator + Clone , I :: Item : Clone ; # [doc = " Create a new cartesian product iterator over an arbitrary number"] # [doc = " of iterators of the same type."] # [doc = ""] # [doc = " Iterator element is of type `Vec<H::Item::Item>`."] pub fn multi_cartesian_product < H > (iters : H) -> MultiProduct < < H :: Item as IntoIterator > :: IntoIter > where H : Iterator , H :: Item : IntoIterator , < H :: Item as IntoIterator > :: IntoIter : Clone , < H :: Item as IntoIterator > :: Item : Clone { MultiProduct (iters . map (| i | MultiProductIter :: new (i . into_iter ())) . collect ()) } # [derive (Clone , Debug)] # [doc = " Holds the state of a single iterator within a MultiProduct."] struct MultiProductIter < I > where I : Iterator + Clone , I :: Item : Clone { cur : Option < I :: Item > , iter : I , iter_orig : I , } # [doc = " Holds the current state during an iteration of a MultiProduct."] # [derive (Debug)] enum MultiProductIterState { StartOfIter , MidIter { on_first_iter : bool } , } impl < I > MultiProduct < I > where I : Iterator + Clone , I :: Item : Clone { # [doc = " Iterates the rightmost iterator, then recursively iterates iterators"] # [doc = " to the left if necessary."] # [doc = ""] # [doc = " Returns true if the iteration succeeded, else false."] fn iterate_last (multi_iters : & mut [MultiProductIter < I >] , mut state : MultiProductIterState) -> bool { use self :: MultiProductIterState :: * ; if let Some ((last , rest)) = multi_iters . split_last_mut () { let on_first_iter = match state { StartOfIter => { let on_first_iter = ! last . in_progress () ; state = MidIter { on_first_iter } ; on_first_iter } , MidIter { on_first_iter } => on_first_iter } ; if ! on_first_iter { last . iterate () ; } if last . in_progress () { true } else if MultiProduct :: iterate_last (rest , state) { last . reset () ; last . iterate () ; last . in_progress () } else { false } } else { match state { StartOfIter => false , MidIter { on_first_iter } => on_first_iter } } } # [doc = " Returns the unwrapped value of the next iteration."] fn curr_iterator (& self) -> Vec < I :: Item > { self . 0 . iter () . map (| multi_iter | { multi_iter . cur . clone () . unwrap () }) . collect () } # [doc = " Returns true if iteration has started and has not yet finished; false"] # [doc = " otherwise."] fn in_progress (& self) -> bool { if let Some (last) = self . 0 . last () { last . in_progress () } else { false } } } impl < I > MultiProductIter < I > where I : Iterator + Clone , I :: Item : Clone { fn new (iter : I) -> Self { MultiProductIter { cur : None , iter : iter . clone () , iter_orig : iter } } # [doc = " Iterate the managed iterator."] fn iterate (& mut self) { self . cur = self . iter . next () ; } # [doc = " Reset the managed iterator."] fn reset (& mut self) { self . iter = self . iter_orig . clone () ; } # [doc = " Returns true if the current iterator has been started and has not yet"] # [doc = " finished; false otherwise."] fn in_progress (& self) -> bool { self . cur . is_some () } } impl < I > Iterator for MultiProduct < I > where I : Iterator + Clone , I :: Item : Clone { type Item = Vec < I :: Item > ; fn next (& mut self) -> Option < Self :: Item > { if MultiProduct :: iterate_last (& mut self . 0 , MultiProductIterState :: StartOfIter) { Some (self . curr_iterator ()) } else { None } } fn count (self) -> usize { if self . 0 . len () == 0 { return 0 ; } if ! self . in_progress () { return self . 0 . into_iter () . fold (1 , | acc , multi_iter | { acc * multi_iter . iter . count () }) ; } self . 0 . into_iter () . fold (0 , | acc , MultiProductIter { iter , iter_orig , cur : _ } | { let total_count = iter_orig . count () ; let cur_count = iter . count () ; acc * total_count + cur_count }) } fn size_hint (& self) -> (usize , Option < usize >) { if self . 0 . len () == 0 { return (0 , Some (0)) ; } if ! self . in_progress () { return self . 0 . iter () . fold ((1 , Some (1)) , | acc , multi_iter | { size_hint :: mul (acc , multi_iter . iter . size_hint ()) }) ; } self . 0 . iter () . fold ((0 , Some (0)) , | acc , & MultiProductIter { ref iter , ref iter_orig , cur : _ } | { let cur_size = iter . size_hint () ; let total_size = iter_orig . size_hint () ; size_hint :: add (size_hint :: mul (acc , total_size) , cur_size) }) } fn last (self) -> Option < Self :: Item > { let iter_count = self . 0 . len () ; let lasts : Self :: Item = self . 0 . into_iter () . map (| multi_iter | multi_iter . iter . last ()) . while_some () . collect () ; if lasts . len () == iter_count { Some (lasts) } else { None } } } } # [cfg (feature = "use_std")] pub use self :: multi_product :: * ; use std :: fmt ; use std :: mem :: replace ; use std :: iter :: { Fuse , Peekable , FromIterator } ; use std :: marker :: PhantomData ; use crate :: size_hint ; # [doc = " An iterator adaptor that alternates elements from two iterators until both"] # [doc = " run out."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " See [`.interleave()`](../trait.Itertools.html#method.interleave) for more information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Interleave < I , J > { a : Fuse < I > , b : Fuse < J > , flag : bool , } # [doc = " Create an iterator that interleaves elements in `i` and `j`."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.interleave(j)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::interleave;"] # [doc = ""] # [doc = " for elt in interleave(&[1, 2, 3], &[2, 3, 4]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn interleave < I , J > (i : I , j : J) -> Interleave < < I as IntoIterator > :: IntoIter , < J as IntoIterator > :: IntoIter > where I : IntoIterator , J : IntoIterator < Item = I :: Item > { Interleave { a : i . into_iter () . fuse () , b : j . into_iter () . fuse () , flag : false , } } impl < I , J > Iterator for Interleave < I , J > where I : Iterator , J : Iterator < Item = I :: Item > { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { self . flag = ! self . flag ; if self . flag { match self . a . next () { None => self . b . next () , r => r , } } else { match self . b . next () { None => self . a . next () , r => r , } } } fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: add (self . a . size_hint () , self . b . size_hint ()) } } # [doc = " An iterator adaptor that alternates elements from the two iterators until"] # [doc = " one of them runs out."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " See [`.interleave_shortest()`](../trait.Itertools.html#method.interleave_shortest)"] # [doc = " for more information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct InterleaveShortest < I , J > where I : Iterator , J : Iterator < Item = I :: Item > { it0 : I , it1 : J , phase : bool , } # [doc = " Create a new `InterleaveShortest` iterator."] pub fn interleave_shortest < I , J > (a : I , b : J) -> InterleaveShortest < I , J > where I : Iterator , J : Iterator < Item = I :: Item > { InterleaveShortest { it0 : a , it1 : b , phase : false , } } impl < I , J > Iterator for InterleaveShortest < I , J > where I : Iterator , J : Iterator < Item = I :: Item > { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { match self . phase { false => match self . it0 . next () { None => None , e => { self . phase = true ; e } } , true => match self . it1 . next () { None => None , e => { self . phase = false ; e } } , } } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { let (curr_hint , next_hint) = { let it0_hint = self . it0 . size_hint () ; let it1_hint = self . it1 . size_hint () ; if self . phase { (it1_hint , it0_hint) } else { (it0_hint , it1_hint) } } ; let (curr_lower , curr_upper) = curr_hint ; let (next_lower , next_upper) = next_hint ; let (combined_lower , combined_upper) = size_hint :: mul_scalar (size_hint :: min (curr_hint , next_hint) , 2) ; let lower = if curr_lower > next_lower { combined_lower + 1 } else { combined_lower } ; let upper = { let extra_elem = match (curr_upper , next_upper) { (_ , None) => false , (None , Some (_)) => true , (Some (curr_max) , Some (next_max)) => curr_max > next_max , } ; if extra_elem { combined_upper . and_then (| x | x . checked_add (1)) } else { combined_upper } } ; (lower , upper) } } # [derive (Clone , Debug)] # [doc = " An iterator adaptor that allows putting back a single"] # [doc = " item to the front of the iterator."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] pub struct PutBack < I > where I : Iterator { top : Option < I :: Item > , iter : I , } # [doc = " Create an iterator where you can put back a single item"] pub fn put_back < I > (iterable : I) -> PutBack < I :: IntoIter > where I : IntoIterator { PutBack { top : None , iter : iterable . into_iter () , } } impl < I > PutBack < I > where I : Iterator { # [doc = " put back value `value` (builder method)"] pub fn with_value (mut self , value : I :: Item) -> Self { self . put_back (value) ; self } # [doc = " Split the `PutBack` into its parts."] # [inline] pub fn into_parts (self) -> (Option < I :: Item > , I) { let PutBack { top , iter } = self ; (top , iter) } # [doc = " Put back a single value to the front of the iterator."] # [doc = ""] # [doc = " If a value is already in the put back slot, it is overwritten."] # [inline] pub fn put_back (& mut self , x : I :: Item) { self . top = Some (x) } } impl < I > Iterator for PutBack < I > where I : Iterator { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { match self . top { None => self . iter . next () , ref mut some => some . take () , } } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: add_scalar (self . iter . size_hint () , self . top . is_some () as usize) } fn count (self) -> usize { self . iter . count () + (self . top . is_some () as usize) } fn last (self) -> Option < Self :: Item > { self . iter . last () . or (self . top) } fn nth (& mut self , n : usize) -> Option < Self :: Item > { match self . top { None => self . iter . nth (n) , ref mut some => { if n == 0 { some . take () } else { * some = None ; self . iter . nth (n - 1) } } } } fn all < G > (& mut self , mut f : G) -> bool where G : FnMut (Self :: Item) -> bool { if let Some (elt) = self . top . take () { if ! f (elt) { return false ; } } self . iter . all (f) } fn fold < Acc , G > (mut self , init : Acc , mut f : G) -> Acc where G : FnMut (Acc , Self :: Item) -> Acc , { let mut accum = init ; if let Some (elt) = self . top . take () { accum = f (accum , elt) ; } self . iter . fold (accum , f) } } # [derive (Debug , Clone)] # [doc = " An iterator adaptor that iterates over the cartesian product of"] # [doc = " the element sets of two iterators `I` and `J`."] # [doc = ""] # [doc = " Iterator element type is `(I::Item, J::Item)`."] # [doc = ""] # [doc = " See [`.cartesian_product()`](../trait.Itertools.html#method.cartesian_product) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Product < I , J > where I : Iterator { a : I , a_cur : Option < I :: Item > , b : J , b_orig : J , } # [doc = " Create a new cartesian product iterator"] # [doc = ""] # [doc = " Iterator element type is `(I::Item, J::Item)`."] pub fn cartesian_product < I , J > (mut i : I , j : J) -> Product < I , J > where I : Iterator , J : Clone + Iterator , I :: Item : Clone { Product { a_cur : i . next () , a : i , b : j . clone () , b_orig : j , } } impl < I , J > Iterator for Product < I , J > where I : Iterator , J : Clone + Iterator , I :: Item : Clone { type Item = (I :: Item , J :: Item) ; fn next (& mut self) -> Option < (I :: Item , J :: Item) > { let elt_b = match self . b . next () { None => { self . b = self . b_orig . clone () ; match self . b . next () { None => return None , Some (x) => { self . a_cur = self . a . next () ; x } } } Some (x) => x } ; match self . a_cur { None => None , Some (ref a) => { Some ((a . clone () , elt_b)) } } } fn size_hint (& self) -> (usize , Option < usize >) { let has_cur = self . a_cur . is_some () as usize ; let (b_min , b_max) = self . b . size_hint () ; size_hint :: add (size_hint :: mul (self . a . size_hint () , self . b_orig . size_hint ()) , (b_min * has_cur , b_max . map (move | x | x * has_cur))) } fn fold < Acc , G > (mut self , mut accum : Acc , mut f : G) -> Acc where G : FnMut (Acc , Self :: Item) -> Acc , { if let Some (mut a) = self . a_cur . take () { let mut b = self . b ; loop { accum = b . fold (accum , | acc , elt | f (acc , (a . clone () , elt))) ; if let Some (next_a) = self . a . next () { b = self . b_orig . clone () ; a = next_a ; } else { break ; } } } accum } } # [doc = " A meta iterator adaptor. Its closure receives a reference to the iterator"] # [doc = " and may pick off as many elements as it likes, to produce the next iterator element."] # [doc = ""] # [doc = " Iterator element type is *X*, if the return type of `F` is *Option\\<X\\>*."] # [doc = ""] # [doc = " See [`.batching()`](../trait.Itertools.html#method.batching) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Batching < I , F > { f : F , iter : I , } impl < I , F > fmt :: Debug for Batching < I , F > where I : fmt :: Debug { debug_fmt_fields ! (Batching , iter) ; } # [doc = " Create a new Batching iterator."] pub fn batching < I , F > (iter : I , f : F) -> Batching < I , F > { Batching { f , iter } } impl < B , F , I > Iterator for Batching < I , F > where I : Iterator , F : FnMut (& mut I) -> Option < B > { type Item = B ; # [inline] fn next (& mut self) -> Option < B > { (self . f) (& mut self . iter) } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { (0 , None) } } # [doc = " An iterator adaptor that steps a number elements in the base iterator"] # [doc = " for each iteration."] # [doc = ""] # [doc = " The iterator steps by yielding the next element from the base iterator,"] # [doc = " then skipping forward *n-1* elements."] # [doc = ""] # [doc = " See [`.step()`](../trait.Itertools.html#method.step) for more information."] # [deprecated (note = "Use std .step_by() instead" , since = "0.8")] # [allow (deprecated)] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Step < I > { iter : Fuse < I > , skip : usize , } # [doc = " Create a `Step` iterator."] # [doc = ""] # [doc = " **Panics** if the step is 0."] # [allow (deprecated)] pub fn step < I > (iter : I , step : usize) -> Step < I > where I : Iterator { assert ! (step != 0) ; Step { iter : iter . fuse () , skip : step - 1 , } } # [allow (deprecated)] impl < I > Iterator for Step < I > where I : Iterator { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { let elt = self . iter . next () ; if self . skip > 0 { self . iter . nth (self . skip - 1) ; } elt } fn size_hint (& self) -> (usize , Option < usize >) { let (low , high) = self . iter . size_hint () ; let div = | x : usize | { if x == 0 { 0 } else { 1 + (x - 1) / (self . skip + 1) } } ; (div (low) , high . map (div)) } } # [allow (deprecated)] impl < I > ExactSizeIterator for Step < I > where I : ExactSizeIterator { } pub trait MergePredicate < T > { fn merge_pred (& mut self , a : & T , b : & T) -> bool ; } # [derive (Clone)] pub struct MergeLte ; impl < T : PartialOrd > MergePredicate < T > for MergeLte { fn merge_pred (& mut self , a : & T , b : & T) -> bool { a <= b } } # [doc = " An iterator adaptor that merges the two base iterators in ascending order."] # [doc = " If both base iterators are sorted (ascending), the result is sorted."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] # [doc = ""] # [doc = " See [`.merge()`](../trait.Itertools.html#method.merge_by) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub type Merge < I , J > = MergeBy < I , J , MergeLte > ; # [doc = " Create an iterator that merges elements in `i` and `j`."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.merge(j)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::merge;"] # [doc = ""] # [doc = " for elt in merge(&[1, 2, 3], &[2, 3, 4]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn merge < I , J > (i : I , j : J) -> Merge < < I as IntoIterator > :: IntoIter , < J as IntoIterator > :: IntoIter > where I : IntoIterator , J : IntoIterator < Item = I :: Item > , I :: Item : PartialOrd { merge_by_new (i , j , MergeLte) } # [doc = " An iterator adaptor that merges the two base iterators in ascending order."] # [doc = " If both base iterators are sorted (ascending), the result is sorted."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] # [doc = ""] # [doc = " See [`.merge_by()`](../trait.Itertools.html#method.merge_by) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct MergeBy < I , J , F > where I : Iterator , J : Iterator < Item = I :: Item > { a : Peekable < I > , b : Peekable < J > , fused : Option < bool > , cmp : F , } impl < I , J , F > fmt :: Debug for MergeBy < I , J , F > where I : Iterator + fmt :: Debug , J : Iterator < Item = I :: Item > + fmt :: Debug , I :: Item : fmt :: Debug , { debug_fmt_fields ! (MergeBy , a , b) ; } impl < T , F : FnMut (& T , & T) -> bool > MergePredicate < T > for F { fn merge_pred (& mut self , a : & T , b : & T) -> bool { self (a , b) } } # [doc = " Create a `MergeBy` iterator."] pub fn merge_by_new < I , J , F > (a : I , b : J , cmp : F) -> MergeBy < I :: IntoIter , J :: IntoIter , F > where I : IntoIterator , J : IntoIterator < Item = I :: Item > , F : MergePredicate < I :: Item > , { MergeBy { a : a . into_iter () . peekable () , b : b . into_iter () . peekable () , fused : None , cmp , } } impl < I , J , F > Clone for MergeBy < I , J , F > where I : Iterator , J : Iterator < Item = I :: Item > , Peekable < I > : Clone , Peekable < J > : Clone , F : Clone { clone_fields ! (a , b , fused , cmp) ; } impl < I , J , F > Iterator for MergeBy < I , J , F > where I : Iterator , J : Iterator < Item = I :: Item > , F : MergePredicate < I :: Item > { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { let less_than = match self . fused { Some (lt) => lt , None => match (self . a . peek () , self . b . peek ()) { (Some (a) , Some (b)) => self . cmp . merge_pred (a , b) , (Some (_) , None) => { self . fused = Some (true) ; true } (None , Some (_)) => { self . fused = Some (false) ; false } (None , None) => return None , } } ; if less_than { self . a . next () } else { self . b . next () } } fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: add (self . a . size_hint () , self . b . size_hint ()) } } # [derive (Clone , Debug)] pub struct CoalesceCore < I > where I : Iterator { iter : I , last : Option < I :: Item > , } impl < I > CoalesceCore < I > where I : Iterator { fn next_with < F > (& mut self , mut f : F) -> Option < I :: Item > where F : FnMut (I :: Item , I :: Item) -> Result < I :: Item , (I :: Item , I :: Item) > { let mut last = match self . last . take () { None => return None , Some (x) => x , } ; for next in & mut self . iter { match f (last , next) { Ok (joined) => last = joined , Err ((last_ , next_)) => { self . last = Some (next_) ; return Some (last_) ; } } } Some (last) } fn size_hint (& self) -> (usize , Option < usize >) { let (low , hi) = size_hint :: add_scalar (self . iter . size_hint () , self . last . is_some () as usize) ; ((low > 0) as usize , hi) } } # [doc = " An iterator adaptor that may join together adjacent elements."] # [doc = ""] # [doc = " See [`.coalesce()`](../trait.Itertools.html#method.coalesce) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Coalesce < I , F > where I : Iterator { iter : CoalesceCore < I > , f : F , } impl < I : Clone , F : Clone > Clone for Coalesce < I , F > where I : Iterator , I :: Item : Clone { clone_fields ! (iter , f) ; } impl < I , F > fmt :: Debug for Coalesce < I , F > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug , { debug_fmt_fields ! (Coalesce , iter) ; } # [doc = " Create a new `Coalesce`."] pub fn coalesce < I , F > (mut iter : I , f : F) -> Coalesce < I , F > where I : Iterator { Coalesce { iter : CoalesceCore { last : iter . next () , iter , } , f , } } impl < I , F > Iterator for Coalesce < I , F > where I : Iterator , F : FnMut (I :: Item , I :: Item) -> Result < I :: Item , (I :: Item , I :: Item) > { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { self . iter . next_with (& mut self . f) } fn size_hint (& self) -> (usize , Option < usize >) { self . iter . size_hint () } } # [doc = " An iterator adaptor that removes repeated duplicates, determining equality using a comparison function."] # [doc = ""] # [doc = " See [`.dedup_by()`](../trait.Itertools.html#method.dedup_by) or [`.dedup()`](../trait.Itertools.html#method.dedup) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct DedupBy < I , Pred > where I : Iterator { iter : CoalesceCore < I > , dedup_pred : Pred , } pub trait DedupPredicate < T > { fn dedup_pair (& mut self , a : & T , b : & T) -> bool ; } # [derive (Clone)] pub struct DedupEq ; impl < T : PartialEq > DedupPredicate < T > for DedupEq { fn dedup_pair (& mut self , a : & T , b : & T) -> bool { a == b } } impl < T , F : FnMut (& T , & T) -> bool > DedupPredicate < T > for F { fn dedup_pair (& mut self , a : & T , b : & T) -> bool { self (a , b) } } # [doc = " An iterator adaptor that removes repeated duplicates."] # [doc = ""] # [doc = " See [`.dedup()`](../trait.Itertools.html#method.dedup) for more information."] pub type Dedup < I > = DedupBy < I , DedupEq > ; impl < I : Clone , Pred : Clone > Clone for DedupBy < I , Pred > where I : Iterator , I :: Item : Clone , { clone_fields ! (iter , dedup_pred) ; } # [doc = " Create a new `DedupBy`."] pub fn dedup_by < I , Pred > (mut iter : I , dedup_pred : Pred) -> DedupBy < I , Pred > where I : Iterator , { DedupBy { iter : CoalesceCore { last : iter . next () , iter , } , dedup_pred , } } # [doc = " Create a new `Dedup`."] pub fn dedup < I > (iter : I) -> Dedup < I > where I : Iterator { dedup_by (iter , DedupEq) } impl < I , Pred > fmt :: Debug for DedupBy < I , Pred > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug , { debug_fmt_fields ! (Dedup , iter) ; } impl < I , Pred > Iterator for DedupBy < I , Pred > where I : Iterator , Pred : DedupPredicate < I :: Item > , { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { let ref mut dedup_pred = self . dedup_pred ; self . iter . next_with (| x , y | { if dedup_pred . dedup_pair (& x , & y) { Ok (x) } else { Err ((x , y)) } }) } fn size_hint (& self) -> (usize , Option < usize >) { self . iter . size_hint () } fn fold < Acc , G > (self , mut accum : Acc , mut f : G) -> Acc where G : FnMut (Acc , Self :: Item) -> Acc , { if let Some (mut last) = self . iter . last { let mut dedup_pred = self . dedup_pred ; accum = self . iter . iter . fold (accum , | acc , elt | { if dedup_pred . dedup_pair (& elt , & last) { acc } else { f (acc , replace (& mut last , elt)) } }) ; f (accum , last) } else { accum } } } # [doc = " An iterator adaptor that borrows from a `Clone`-able iterator"] # [doc = " to only pick off elements while the predicate returns `true`."] # [doc = ""] # [doc = " See [`.take_while_ref()`](../trait.Itertools.html#method.take_while_ref) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct TakeWhileRef < 'a , I : 'a , F > { iter : & 'a mut I , f : F , } impl < 'a , I , F > fmt :: Debug for TakeWhileRef < 'a , I , F > where I : Iterator + fmt :: Debug , { debug_fmt_fields ! (TakeWhileRef , iter) ; } # [doc = " Create a new `TakeWhileRef` from a reference to clonable iterator."] pub fn take_while_ref < I , F > (iter : & mut I , f : F) -> TakeWhileRef < I , F > where I : Iterator + Clone { TakeWhileRef { iter , f } } impl < 'a , I , F > Iterator for TakeWhileRef < 'a , I , F > where I : Iterator + Clone , F : FnMut (& I :: Item) -> bool { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { let old = self . iter . clone () ; match self . iter . next () { None => None , Some (elt) => { if (self . f) (& elt) { Some (elt) } else { * self . iter = old ; None } } } } fn size_hint (& self) -> (usize , Option < usize >) { let (_ , hi) = self . iter . size_hint () ; (0 , hi) } } # [doc = " An iterator adaptor that filters `Option<A>` iterator elements"] # [doc = " and produces `A`. Stops on the first `None` encountered."] # [doc = ""] # [doc = " See [`.while_some()`](../trait.Itertools.html#method.while_some) for more information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct WhileSome < I > { iter : I , } # [doc = " Create a new `WhileSome<I>`."] pub fn while_some < I > (iter : I) -> WhileSome < I > { WhileSome { iter } } impl < I , A > Iterator for WhileSome < I > where I : Iterator < Item = Option < A > > { type Item = A ; fn next (& mut self) -> Option < A > { match self . iter . next () { None | Some (None) => None , Some (elt) => elt , } } fn size_hint (& self) -> (usize , Option < usize >) { let sh = self . iter . size_hint () ; (0 , sh . 1) } } # [doc = " An iterator to iterate through all combinations in a `Clone`-able iterator that produces tuples"] # [doc = " of a specific size."] # [doc = ""] # [doc = " See [`.tuple_combinations()`](../trait.Itertools.html#method.tuple_combinations) for more"] # [doc = " information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct TupleCombinations < I , T > where I : Iterator , T : HasCombination < I > { iter : T :: Combination , _mi : PhantomData < I > , _mt : PhantomData < T > } pub trait HasCombination < I > : Sized { type Combination : From < I > + Iterator < Item = Self > ; } # [doc = " Create a new `TupleCombinations` from a clonable iterator."] pub fn tuple_combinations < T , I > (iter : I) -> TupleCombinations < I , T > where I : Iterator + Clone , I :: Item : Clone , T : HasCombination < I > , { TupleCombinations { iter : T :: Combination :: from (iter) , _mi : PhantomData , _mt : PhantomData , } } impl < I , T > Iterator for TupleCombinations < I , T > where I : Iterator , T : HasCombination < I > , { type Item = T ; fn next (& mut self) -> Option < Self :: Item > { self . iter . next () } } # [derive (Clone , Debug)] pub struct Tuple1Combination < I > { iter : I , } impl < I > From < I > for Tuple1Combination < I > { fn from (iter : I) -> Self { Tuple1Combination { iter } } } impl < I : Iterator > Iterator for Tuple1Combination < I > { type Item = (I :: Item ,) ; fn next (& mut self) -> Option < Self :: Item > { self . iter . next () . map (| x | (x ,)) } } impl < I : Iterator > HasCombination < I > for (I :: Item ,) { type Combination = Tuple1Combination < I > ; } macro_rules ! impl_tuple_combination { ($ C : ident $ P : ident ; $ A : ident , $ ($ I : ident) ,* ; $ ($ X : ident) *) => (# [derive (Clone , Debug)] pub struct $ C < I : Iterator > { item : Option < I :: Item >, iter : I , c : $ P < I >, } impl < I : Iterator + Clone > From < I > for $ C < I > { fn from (mut iter : I) -> Self { $ C { item : iter . next () , iter : iter . clone () , c : $ P :: from (iter) , } } } impl < I : Iterator + Clone > From < I > for $ C < Fuse < I >> { fn from (iter : I) -> Self { let mut iter = iter . fuse () ; $ C { item : iter . next () , iter : iter . clone () , c : $ P :: from (iter) , } } } impl < I , $ A > Iterator for $ C < I > where I : Iterator < Item = $ A > + Clone , I :: Item : Clone { type Item = ($ ($ I) ,*) ; fn next (& mut self) -> Option < Self :: Item > { if let Some (($ ($ X) ,*,)) = self . c . next () { let z = self . item . clone () . unwrap () ; Some ((z , $ ($ X) ,*)) } else { self . item = self . iter . next () ; self . item . clone () . and_then (| z | { self . c = $ P :: from (self . iter . clone ()) ; self . c . next () . map (| ($ ($ X) ,*,) | (z , $ ($ X) ,*)) }) } } } impl < I , $ A > HasCombination < I > for ($ ($ I) ,*) where I : Iterator < Item = $ A > + Clone , I :: Item : Clone { type Combination = $ C < Fuse < I >>; }) } impl_tuple_combination ! (Tuple2Combination Tuple1Combination ; A , A , A ; a) ; impl_tuple_combination ! (Tuple3Combination Tuple2Combination ; A , A , A , A ; a b) ; impl_tuple_combination ! (Tuple4Combination Tuple3Combination ; A , A , A , A , A ; a b c) ; # [doc = " An iterator adapter to apply `Into` conversion to each element."] # [doc = ""] # [doc = " See [`.map_into()`](../trait.Itertools.html#method.map_into) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct MapInto < I , R > { iter : I , _res : PhantomData < fn () -> R > , } # [doc = " Create a new [`MapInto`](struct.MapInto.html) iterator."] pub fn map_into < I , R > (iter : I) -> MapInto < I , R > { MapInto { iter , _res : PhantomData , } } impl < I , R > Iterator for MapInto < I , R > where I : Iterator , I :: Item : Into < R > , { type Item = R ; fn next (& mut self) -> Option < R > { self . iter . next () . map (| i | i . into ()) } fn size_hint (& self) -> (usize , Option < usize >) { self . iter . size_hint () } fn fold < Acc , Fold > (self , init : Acc , mut fold_f : Fold) -> Acc where Fold : FnMut (Acc , Self :: Item) -> Acc , { self . iter . fold (init , move | acc , v | fold_f (acc , v . into ())) } } impl < I , R > DoubleEndedIterator for MapInto < I , R > where I : DoubleEndedIterator , I :: Item : Into < R > , { fn next_back (& mut self) -> Option < Self :: Item > { self . iter . next_back () . map (| i | i . into ()) } } impl < I , R > ExactSizeIterator for MapInto < I , R > where I : ExactSizeIterator , I :: Item : Into < R > , { } # [doc = " An iterator adapter to apply a transformation within a nested `Result`."] # [doc = ""] # [doc = " See [`.map_results()`](../trait.Itertools.html#method.map_results) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct MapResults < I , F > { iter : I , f : F } # [doc = " Create a new `MapResults` iterator."] pub fn map_results < I , F , T , U , E > (iter : I , f : F) -> MapResults < I , F > where I : Iterator < Item = Result < T , E > > , F : FnMut (T) -> U , { MapResults { iter , f , } } impl < I , F , T , U , E > Iterator for MapResults < I , F > where I : Iterator < Item = Result < T , E > > , F : FnMut (T) -> U , { type Item = Result < U , E > ; fn next (& mut self) -> Option < Self :: Item > { self . iter . next () . map (| v | v . map (& mut self . f)) } fn size_hint (& self) -> (usize , Option < usize >) { self . iter . size_hint () } fn fold < Acc , Fold > (self , init : Acc , mut fold_f : Fold) -> Acc where Fold : FnMut (Acc , Self :: Item) -> Acc , { let mut f = self . f ; self . iter . fold (init , move | acc , v | fold_f (acc , v . map (& mut f))) } fn collect < C > (self) -> C where C : FromIterator < Self :: Item > { let mut f = self . f ; self . iter . map (move | v | v . map (& mut f)) . collect () } } # [doc = " An iterator adapter to get the positions of each element that matches a predicate."] # [doc = ""] # [doc = " See [`.positions()`](../trait.Itertools.html#method.positions) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Positions < I , F > { iter : I , f : F , count : usize , } # [doc = " Create a new `Positions` iterator."] pub fn positions < I , F > (iter : I , f : F) -> Positions < I , F > where I : Iterator , F : FnMut (I :: Item) -> bool , { Positions { iter , f , count : 0 } } impl < I , F > Iterator for Positions < I , F > where I : Iterator , F : FnMut (I :: Item) -> bool , { type Item = usize ; fn next (& mut self) -> Option < Self :: Item > { while let Some (v) = self . iter . next () { let i = self . count ; self . count = i + 1 ; if (self . f) (v) { return Some (i) ; } } None } fn size_hint (& self) -> (usize , Option < usize >) { (0 , self . iter . size_hint () . 1) } } impl < I , F > DoubleEndedIterator for Positions < I , F > where I : DoubleEndedIterator + ExactSizeIterator , F : FnMut (I :: Item) -> bool , { fn next_back (& mut self) -> Option < Self :: Item > { while let Some (v) = self . iter . next_back () { if (self . f) (v) { return Some (self . count + self . iter . len ()) } } None } } # [doc = " An iterator adapter to apply a mutating function to each element before yielding it."] # [doc = ""] # [doc = " See [`.update()`](../trait.Itertools.html#method.update) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Update < I , F > { iter : I , f : F , } # [doc = " Create a new `Update` iterator."] pub fn update < I , F > (iter : I , f : F) -> Update < I , F > where I : Iterator , F : FnMut (& mut I :: Item) , { Update { iter , f } } impl < I , F > Iterator for Update < I , F > where I : Iterator , F : FnMut (& mut I :: Item) , { type Item = I :: Item ; fn next (& mut self) -> Option < Self :: Item > { if let Some (mut v) = self . iter . next () { (self . f) (& mut v) ; Some (v) } else { None } } fn size_hint (& self) -> (usize , Option < usize >) { self . iter . size_hint () } fn fold < Acc , G > (self , init : Acc , mut g : G) -> Acc where G : FnMut (Acc , Self :: Item) -> Acc , { let mut f = self . f ; self . iter . fold (init , move | acc , mut v | { f (& mut v) ; g (acc , v) }) } fn collect < C > (self) -> C where C : FromIterator < Self :: Item > { let mut f = self . f ; self . iter . map (move | mut v | { f (& mut v) ; v }) . collect () } } impl < I , F > ExactSizeIterator for Update < I , F > where I : ExactSizeIterator , F : FnMut (& mut I :: Item) , { } impl < I , F > DoubleEndedIterator for Update < I , F > where I : DoubleEndedIterator , F : FnMut (& mut I :: Item) , { fn next_back (& mut self) -> Option < Self :: Item > { if let Some (mut v) = self . iter . next_back () { (self . f) (& mut v) ; Some (v) } else { None } } } } mod either_or_both { use crate :: EitherOrBoth :: * ; use either :: Either ; # [doc = " Value that either holds a single A or B, or both."] # [derive (Clone , PartialEq , Eq , Hash , Debug)] pub enum EitherOrBoth < A , B > { # [doc = " Both values are present."] Both (A , B) , # [doc = " Only the left value of type `A` is present."] Left (A) , # [doc = " Only the right value of type `B` is present."] Right (B) , } impl < A , B > EitherOrBoth < A , B > { # [doc = " If `Left`, or `Both`, return true, otherwise, return false."] pub fn has_left (& self) -> bool { self . as_ref () . left () . is_some () } # [doc = " If `Right`, or `Both`, return true, otherwise, return false."] pub fn has_right (& self) -> bool { self . as_ref () . right () . is_some () } # [doc = " If Left, return true otherwise, return false."] # [doc = " Exclusive version of [`has_left`]."] pub fn is_left (& self) -> bool { match * self { Left (_) => true , _ => false , } } # [doc = " If Right, return true otherwise, return false."] # [doc = " Exclusive version of [`has_right`]."] pub fn is_right (& self) -> bool { match * self { Right (_) => true , _ => false , } } # [doc = " If Right, return true otherwise, return false."] # [doc = " Equivalent to `self.as_ref().both().is_some()`."] pub fn is_both (& self) -> bool { self . as_ref () . both () . is_some () } # [doc = " If `Left`, or `Both`, return `Some` with the left value, otherwise, return `None`."] pub fn left (self) -> Option < A > { match self { Left (left) | Both (left , _) => Some (left) , _ => None , } } # [doc = " If `Right`, or `Both`, return `Some` with the right value, otherwise, return `None`."] pub fn right (self) -> Option < B > { match self { Right (right) | Both (_ , right) => Some (right) , _ => None , } } # [doc = " If Both, return `Some` tuple containing left and right."] pub fn both (self) -> Option < (A , B) > { match self { Both (a , b) => Some ((a , b)) , _ => None , } } # [doc = " Converts from `&EitherOrBoth<A, B>` to `EitherOrBoth<&A, &B>`."] pub fn as_ref (& self) -> EitherOrBoth < & A , & B > { match * self { Left (ref left) => Left (left) , Right (ref right) => Right (right) , Both (ref left , ref right) => Both (left , right) , } } # [doc = " Converts from `&mut EitherOrBoth<A, B>` to `EitherOrBoth<&mut A, &mut B>`."] pub fn as_mut (& mut self) -> EitherOrBoth < & mut A , & mut B > { match * self { Left (ref mut left) => Left (left) , Right (ref mut right) => Right (right) , Both (ref mut left , ref mut right) => Both (left , right) , } } # [doc = " Convert `EitherOrBoth<A, B>` to `EitherOrBoth<B, A>`."] pub fn flip (self) -> EitherOrBoth < B , A > { match self { Left (a) => Right (a) , Right (b) => Left (b) , Both (a , b) => Both (b , a) , } } # [doc = " Apply the function `f` on the value `a` in `Left(a)` or `Both(a, b)` variants. If it is"] # [doc = " present rewrapping the result in `self`'s original variant."] pub fn map_left < F , M > (self , f : F) -> EitherOrBoth < M , B > where F : FnOnce (A) -> M , { match self { Both (a , b) => Both (f (a) , b) , Left (a) => Left (f (a)) , Right (b) => Right (b) , } } # [doc = " Apply the function `f` on the value `b` in `Right(b)` or `Both(a, b)` variants."] # [doc = " If it is present rewrapping the result in `self`'s original variant."] pub fn map_right < F , M > (self , f : F) -> EitherOrBoth < A , M > where F : FnOnce (B) -> M , { match self { Left (a) => Left (a) , Right (b) => Right (f (b)) , Both (a , b) => Both (a , f (b)) , } } # [doc = " Apply the functions `f` and `g` on the value `a` and `b` respectively;"] # [doc = " found in `Left(a)`, `Right(b)`, or `Both(a, b)` variants."] # [doc = " The Result is rewrapped `self`'s original variant."] pub fn map_any < F , L , G , R > (self , f : F , g : G) -> EitherOrBoth < L , R > where F : FnOnce (A) -> L , G : FnOnce (B) -> R , { match self { Left (a) => Left (f (a)) , Right (b) => Right (g (b)) , Both (a , b) => Both (f (a) , g (b)) , } } # [doc = " Apply the function `f` on the value `b` in `Right(b)` or `Both(a, _)` variants if it is"] # [doc = " present."] pub fn left_and_then < F , L > (self , f : F) -> EitherOrBoth < L , B > where F : FnOnce (A) -> EitherOrBoth < L , B > , { match self { Left (a) | Both (a , _) => f (a) , Right (b) => Right (b) , } } # [doc = " Apply the function `f` on the value `a`"] # [doc = " in `Left(a)` or `Both(a, _)` variants if it is present."] pub fn right_and_then < F , R > (self , f : F) -> EitherOrBoth < A , R > where F : FnOnce (B) -> EitherOrBoth < A , R > , { match self { Left (a) => Left (a) , Right (b) | Both (_ , b) => f (b) , } } } impl < T > EitherOrBoth < T , T > { # [doc = " Return either value of left, right, or the product of `f` applied where `Both` are present."] pub fn reduce < F > (self , f : F) -> T where F : FnOnce (T , T) -> T , { match self { Left (a) => a , Right (b) => b , Both (a , b) => f (a , b) , } } } impl < A , B > Into < Option < Either < A , B > > > for EitherOrBoth < A , B > { fn into (self) -> Option < Either < A , B > > { match self { EitherOrBoth :: Left (l) => Some (Either :: Left (l)) , EitherOrBoth :: Right (r) => Some (Either :: Right (r)) , _ => None , } } } } pub use crate :: either_or_both :: EitherOrBoth ; # [doc (hidden)] pub mod free { # [cfg (feature = "use_std")] use std :: fmt :: Display ; use std :: iter :: { self , Zip } ; # [cfg (feature = "use_std")] type VecIntoIter < T > = :: std :: vec :: IntoIter < T > ; # [cfg (feature = "use_std")] use crate :: Itertools ; pub use crate :: adaptors :: { interleave , merge , put_back , } ; # [cfg (feature = "use_std")] pub use crate :: put_back_n_impl :: put_back_n ; # [cfg (feature = "use_std")] pub use crate :: multipeek_impl :: multipeek ; # [cfg (feature = "use_std")] pub use crate :: kmerge_impl :: kmerge ; pub use crate :: zip_eq_impl :: zip_eq ; pub use crate :: merge_join :: merge_join_by ; # [cfg (feature = "use_std")] pub use crate :: rciter_impl :: rciter ; # [doc = " Iterate `iterable` with a running index."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `.enumerate()`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::enumerate;"] # [doc = ""] # [doc = " for (i, elt) in enumerate(&[1, 2, 3]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn enumerate < I > (iterable : I) -> iter :: Enumerate < I :: IntoIter > where I : IntoIterator { iterable . into_iter () . enumerate () } # [doc = " Iterate `iterable` in reverse."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `.rev()`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::rev;"] # [doc = ""] # [doc = " for elt in rev(&[1, 2, 3]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn rev < I > (iterable : I) -> iter :: Rev < I :: IntoIter > where I : IntoIterator , I :: IntoIter : DoubleEndedIterator { iterable . into_iter () . rev () } # [doc = " Iterate `i` and `j` in lock step."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.zip(j)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::zip;"] # [doc = ""] # [doc = " let data = [1, 2, 3, 4, 5];"] # [doc = " for (a, b) in zip(&data, &data[1..]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn zip < I , J > (i : I , j : J) -> Zip < I :: IntoIter , J :: IntoIter > where I : IntoIterator , J : IntoIterator { i . into_iter () . zip (j) } # [doc = " Create an iterator that first iterates `i` and then `j`."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.chain(j)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::chain;"] # [doc = ""] # [doc = " for elt in chain(&[1, 2, 3], &[4]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn chain < I , J > (i : I , j : J) -> iter :: Chain < < I as IntoIterator > :: IntoIter , < J as IntoIterator > :: IntoIter > where I : IntoIterator , J : IntoIterator < Item = I :: Item > { i . into_iter () . chain (j) } # [doc = " Create an iterator that clones each element from &T to T"] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.cloned()`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::cloned;"] # [doc = ""] # [doc = " assert_eq!(cloned(b\"abc\").next(), Some(b'a'));"] # [doc = " ```"] pub fn cloned < 'a , I , T : 'a > (iterable : I) -> iter :: Cloned < I :: IntoIter > where I : IntoIterator < Item = & 'a T > , T : Clone , { iterable . into_iter () . cloned () } # [doc = " Perform a fold operation over the iterable."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.fold(init, f)`"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::fold;"] # [doc = ""] # [doc = " assert_eq!(fold(&[1., 2., 3.], 0., |a, &b| f32::max(a, b)), 3.);"] # [doc = " ```"] pub fn fold < I , B , F > (iterable : I , init : B , f : F) -> B where I : IntoIterator , F : FnMut (B , I :: Item) -> B { iterable . into_iter () . fold (init , f) } # [doc = " Test whether the predicate holds for all elements in the iterable."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.all(f)`"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::all;"] # [doc = ""] # [doc = " assert!(all(&[1, 2, 3], |elt| *elt > 0));"] # [doc = " ```"] pub fn all < I , F > (iterable : I , f : F) -> bool where I : IntoIterator , F : FnMut (I :: Item) -> bool { iterable . into_iter () . all (f) } # [doc = " Test whether the predicate holds for any elements in the iterable."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.any(f)`"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::any;"] # [doc = ""] # [doc = " assert!(any(&[0, -1, 2], |elt| *elt > 0));"] # [doc = " ```"] pub fn any < I , F > (iterable : I , f : F) -> bool where I : IntoIterator , F : FnMut (I :: Item) -> bool { iterable . into_iter () . any (f) } # [doc = " Return the maximum value of the iterable."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.max()`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::max;"] # [doc = ""] # [doc = " assert_eq!(max(0..10), Some(9));"] # [doc = " ```"] pub fn max < I > (iterable : I) -> Option < I :: Item > where I : IntoIterator , I :: Item : Ord { iterable . into_iter () . max () } # [doc = " Return the minimum value of the iterable."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.min()`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::min;"] # [doc = ""] # [doc = " assert_eq!(min(0..10), Some(0));"] # [doc = " ```"] pub fn min < I > (iterable : I) -> Option < I :: Item > where I : IntoIterator , I :: Item : Ord { iterable . into_iter () . min () } # [doc = " Combine all iterator elements into one String, seperated by `sep`."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `iterable.join(sep)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::join;"] # [doc = ""] # [doc = " assert_eq!(join(&[1, 2, 3], \", \"), \"1, 2, 3\");"] # [doc = " ```"] # [cfg (feature = "use_std")] pub fn join < I > (iterable : I , sep : & str) -> String where I : IntoIterator , I :: Item : Display { iterable . into_iter () . join (sep) } # [doc = " Sort all iterator elements into a new iterator in ascending order."] # [doc = ""] # [doc = " `IntoIterator` enabled version of [`iterable.sorted()`][1]."] # [doc = ""] # [doc = " [1]: trait.Itertools.html#method.sorted"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::sorted;"] # [doc = " use itertools::assert_equal;"] # [doc = ""] # [doc = " assert_equal(sorted(\"rust\".chars()), \"rstu\".chars());"] # [doc = " ```"] # [cfg (feature = "use_std")] pub fn sorted < I > (iterable : I) -> VecIntoIter < I :: Item > where I : IntoIterator , I :: Item : Ord { iterable . into_iter () . sorted () } } # [doc (inline)] pub use crate :: free :: * ; mod concat_impl { use crate :: Itertools ; # [doc = " Combine all an iterator's elements into one element by using `Extend`."] # [doc = ""] # [doc = " `IntoIterator`-enabled version of `.concat()`"] # [doc = ""] # [doc = " This combinator will extend the first item with each of the rest of the"] # [doc = " items of the iterator. If the iterator is empty, the default value of"] # [doc = " `I::Item` is returned."] # [doc = ""] # [doc = " ```rust"] # [doc = " use itertools::concat;"] # [doc = " "] # [doc = " let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];"] # [doc = " assert_eq!(concat(input), vec![1, 2, 3, 4, 5, 6]);"] # [doc = " ```"] pub fn concat < I > (iterable : I) -> I :: Item where I : IntoIterator , I :: Item : Extend < < < I as IntoIterator > :: Item as IntoIterator > :: Item > + IntoIterator + Default { iterable . into_iter () . fold1 (| mut a , b | { a . extend (b) ; a }) . unwrap_or_else (| | < _ > :: default ()) } } mod cons_tuples_impl { macro_rules ! impl_cons_iter (($ _A : ident , $ _B : ident ,) => () ; ($ A : ident , $ ($ B : ident ,) *) => (impl_cons_iter ! ($ ($ B ,) *) ; # [allow (non_snake_case)] impl < X , Iter , $ ($ B) ,*> Iterator for ConsTuples < Iter , (($ ($ B ,) *) , X) > where Iter : Iterator < Item = (($ ($ B ,) *) , X) >, { type Item = ($ ($ B ,) * X ,) ; fn next (& mut self) -> Option < Self :: Item > { self . iter . next () . map (| (($ ($ B ,) *) , x) | ($ ($ B ,) * x ,)) } fn size_hint (& self) -> (usize , Option < usize >) { self . iter . size_hint () } fn fold < Acc , Fold > (self , accum : Acc , mut f : Fold) -> Acc where Fold : FnMut (Acc , Self :: Item) -> Acc , { self . iter . fold (accum , move | acc , (($ ($ B ,) *) , x) | f (acc , ($ ($ B ,) * x ,))) } } # [allow (non_snake_case)] impl < X , Iter , $ ($ B) ,*> DoubleEndedIterator for ConsTuples < Iter , (($ ($ B ,) *) , X) > where Iter : DoubleEndedIterator < Item = (($ ($ B ,) *) , X) >, { fn next_back (& mut self) -> Option < Self :: Item > { self . iter . next () . map (| (($ ($ B ,) *) , x) | ($ ($ B ,) * x ,)) } }) ;) ; impl_cons_iter ! (A , B , C , D , E , F , G , H ,) ; # [doc = " An iterator that maps an iterator of tuples like"] # [doc = " `((A, B), C)` to an iterator of `(A, B, C)`."] # [doc = ""] # [doc = " Used by the `iproduct!()` macro."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] # [derive (Debug)] pub struct ConsTuples < I , J > where I : Iterator < Item = J > , { iter : I , } impl < I , J > Clone for ConsTuples < I , J > where I : Clone + Iterator < Item = J > , { clone_fields ! (iter) ; } # [doc = " Create an iterator that maps for example iterators of"] # [doc = " `((A, B), C)` to `(A, B, C)`."] pub fn cons_tuples < I , J > (iterable : I) -> ConsTuples < I , J > where I : Iterator < Item = J > { ConsTuples { iter : iterable . into_iter () } } } # [cfg (feature = "use_std")] mod combinations { use std :: fmt ; use super :: lazy_buffer :: LazyBuffer ; # [doc = " An iterator to iterate through all the `k`-length combinations in an iterator."] # [doc = ""] # [doc = " See [`.combinations()`](../trait.Itertools.html#method.combinations) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Combinations < I : Iterator > { indices : Vec < usize > , pool : LazyBuffer < I > , first : bool , } impl < I > Clone for Combinations < I > where I : Clone + Iterator , I :: Item : Clone , { clone_fields ! (indices , pool , first) ; } impl < I > fmt :: Debug for Combinations < I > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug , { debug_fmt_fields ! (Combinations , indices , pool , first) ; } # [doc = " Create a new `Combinations` from a clonable iterator."] pub fn combinations < I > (iter : I , k : usize) -> Combinations < I > where I : Iterator { let mut pool : LazyBuffer < I > = LazyBuffer :: new (iter) ; for _ in 0 .. k { if ! pool . get_next () { break ; } } Combinations { indices : (0 .. k) . collect () , pool , first : true , } } impl < I > Iterator for Combinations < I > where I : Iterator , I :: Item : Clone { type Item = Vec < I :: Item > ; fn next (& mut self) -> Option < Self :: Item > { if self . first { if self . pool . is_done () { return None ; } self . first = false ; } else if self . indices . len () == 0 { return None ; } else { let mut i : usize = self . indices . len () - 1 ; if self . indices [i] == self . pool . len () - 1 { self . pool . get_next () ; } while self . indices [i] == i + self . pool . len () - self . indices . len () { if i > 0 { i -= 1 ; } else { return None ; } } self . indices [i] += 1 ; for j in i + 1 .. self . indices . len () { self . indices [j] = self . indices [j - 1] + 1 ; } } Some (self . indices . iter () . map (| i | self . pool [* i] . clone ()) . collect ()) } } } # [cfg (feature = "use_std")] mod combinations_with_replacement { use std :: fmt ; use super :: lazy_buffer :: LazyBuffer ; # [doc = " An iterator to iterate through all the `n`-length combinations in an iterator, with replacement."] # [doc = ""] # [doc = " See [`.combinations_with_replacement()`](../trait.Itertools.html#method.combinations_with_replacement) for more information."] # [derive (Clone)] pub struct CombinationsWithReplacement < I > where I : Iterator , I :: Item : Clone , { k : usize , indices : Vec < usize > , max_index : usize , pool : LazyBuffer < I > , first : bool , } impl < I > fmt :: Debug for CombinationsWithReplacement < I > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug + Clone , { debug_fmt_fields ! (Combinations , k , indices , max_index , pool , first) ; } impl < I > CombinationsWithReplacement < I > where I : Iterator , I :: Item : Clone , { # [doc = " Map the current mask over the pool to get an output combination"] fn current (& self) -> Vec < I :: Item > { self . indices . iter () . map (| i | self . pool [* i] . clone ()) . collect () } } # [doc = " Create a new `CombinationsWithReplacement` from a clonable iterator."] pub fn combinations_with_replacement < I > (iter : I , k : usize) -> CombinationsWithReplacement < I > where I : Iterator , I :: Item : Clone , { let indices : Vec < usize > = vec ! [0 ; k] ; let pool : LazyBuffer < I > = LazyBuffer :: new (iter) ; CombinationsWithReplacement { k , indices , max_index : 0 , pool , first : true , } } impl < I > Iterator for CombinationsWithReplacement < I > where I : Iterator , I :: Item : Clone , { type Item = Vec < I :: Item > ; fn next (& mut self) -> Option < Self :: Item > { if self . first { return if self . k != 0 && ! self . pool . get_next () { None } else { self . first = false ; Some (self . current ()) } ; } if self . pool . get_next () { self . max_index = self . pool . len () - 1 ; } let mut increment : Option < (usize , usize) > = None ; for (i , indices_int) in self . indices . iter () . enumerate () . rev () { if indices_int < & self . max_index { increment = Some ((i , indices_int + 1)) ; break ; } } match increment { Some ((increment_from , increment_value)) => { for indices_index in increment_from .. self . indices . len () { self . indices [indices_index] = increment_value } Some (self . current ()) } None => None , } } } } mod exactly_one_err { use std :: iter :: ExactSizeIterator ; use crate :: size_hint ; # [doc = " Iterator returned for the error case of `IterTools::exactly_one()`"] # [doc = " This iterator yields exactly the same elements as the input iterator."] # [doc = ""] # [doc = " During the execution of exactly_one the iterator must be mutated.  This wrapper"] # [doc = " effectively \"restores\" the state of the input iterator when it's handed back."] # [doc = ""] # [doc = " This is very similar to PutBackN except this iterator only supports 0-2 elements and does not"] # [doc = " use a `Vec`."] # [derive (Debug , Clone)] pub struct ExactlyOneError < I > where I : Iterator , { first_two : (Option < I :: Item > , Option < I :: Item >) , inner : I , } impl < I > ExactlyOneError < I > where I : Iterator , { # [doc = " Creates a new `ExactlyOneErr` iterator."] pub (crate) fn new (first_two : (Option < I :: Item > , Option < I :: Item >) , inner : I) -> Self { Self { first_two , inner } } } impl < I > Iterator for ExactlyOneError < I > where I : Iterator , { type Item = I :: Item ; fn next (& mut self) -> Option < Self :: Item > { self . first_two . 0 . take () . or_else (| | self . first_two . 1 . take ()) . or_else (| | self . inner . next ()) } fn size_hint (& self) -> (usize , Option < usize >) { let mut additional_len = 0 ; if self . first_two . 0 . is_some () { additional_len += 1 ; } if self . first_two . 1 . is_some () { additional_len += 1 ; } size_hint :: add_scalar (self . inner . size_hint () , additional_len) } } impl < I > ExactSizeIterator for ExactlyOneError < I > where I : ExactSizeIterator { } } mod diff { use crate :: free :: put_back ; use crate :: structs :: PutBack ; # [doc = " A type returned by the [`diff_with`](./fn.diff_with.html) function."] # [doc = ""] # [doc = " `Diff` represents the way in which the elements yielded by the iterator `I` differ to some"] # [doc = " iterator `J`."] pub enum Diff < I , J > where I : Iterator , J : Iterator { # [doc = " The index of the first non-matching element along with both iterator's remaining elements"] # [doc = " starting with the first mis-match."] FirstMismatch (usize , PutBack < I > , PutBack < J >) , # [doc = " The total number of elements that were in `J` along with the remaining elements of `I`."] Shorter (usize , PutBack < I >) , # [doc = " The total number of elements that were in `I` along with the remaining elements of `J`."] Longer (usize , PutBack < J >) , } # [doc = " Compares every element yielded by both `i` and `j` with the given function in lock-step and"] # [doc = " returns a `Diff` which describes how `j` differs from `i`."] # [doc = ""] # [doc = " If the number of elements yielded by `j` is less than the number of elements yielded by `i`,"] # [doc = " the number of `j` elements yielded will be returned along with `i`'s remaining elements as"] # [doc = " `Diff::Shorter`."] # [doc = ""] # [doc = " If the two elements of a step differ, the index of those elements along with the remaining"] # [doc = " elements of both `i` and `j` are returned as `Diff::FirstMismatch`."] # [doc = ""] # [doc = " If `i` becomes exhausted before `j` becomes exhausted, the number of elements in `i` along with"] # [doc = " the remaining `j` elements will be returned as `Diff::Longer`."] pub fn diff_with < I , J , F > (i : I , j : J , is_equal : F) -> Option < Diff < I :: IntoIter , J :: IntoIter > > where I : IntoIterator , J : IntoIterator , F : Fn (& I :: Item , & J :: Item) -> bool { let mut i = i . into_iter () ; let mut j = j . into_iter () ; let mut idx = 0 ; while let Some (i_elem) = i . next () { match j . next () { None => return Some (Diff :: Shorter (idx , put_back (i) . with_value (i_elem))) , Some (j_elem) => if ! is_equal (& i_elem , & j_elem) { let remaining_i = put_back (i) . with_value (i_elem) ; let remaining_j = put_back (j) . with_value (j_elem) ; return Some (Diff :: FirstMismatch (idx , remaining_i , remaining_j)) ; } , } idx += 1 ; } j . next () . map (| j_elem | Diff :: Longer (idx , put_back (j) . with_value (j_elem))) } } mod format { use std :: fmt ; use std :: cell :: RefCell ; # [doc = " Format all iterator elements lazily, separated by `sep`."] # [doc = ""] # [doc = " The format value can only be formatted once, after that the iterator is"] # [doc = " exhausted."] # [doc = ""] # [doc = " See [`.format_with()`](../trait.Itertools.html#method.format_with) for more information."] # [derive (Clone)] pub struct FormatWith < 'a , I , F > { sep : & 'a str , # [doc = " FormatWith uses interior mutability because Display::fmt takes &self."] inner : RefCell < Option < (I , F) > > , } # [doc = " Format all iterator elements lazily, separated by `sep`."] # [doc = ""] # [doc = " The format value can only be formatted once, after that the iterator is"] # [doc = " exhausted."] # [doc = ""] # [doc = " See [`.format()`](../trait.Itertools.html#method.format)"] # [doc = " for more information."] # [derive (Clone)] pub struct Format < 'a , I > { sep : & 'a str , # [doc = " Format uses interior mutability because Display::fmt takes &self."] inner : RefCell < Option < I > > , } pub fn new_format < 'a , I , F > (iter : I , separator : & 'a str , f : F) -> FormatWith < 'a , I , F > where I : Iterator , F : FnMut (I :: Item , & mut dyn FnMut (& dyn fmt :: Display) -> fmt :: Result) -> fmt :: Result { FormatWith { sep : separator , inner : RefCell :: new (Some ((iter , f))) , } } pub fn new_format_default < 'a , I > (iter : I , separator : & 'a str) -> Format < 'a , I > where I : Iterator , { Format { sep : separator , inner : RefCell :: new (Some (iter)) , } } impl < 'a , I , F > fmt :: Display for FormatWith < 'a , I , F > where I : Iterator , F : FnMut (I :: Item , & mut dyn FnMut (& dyn fmt :: Display) -> fmt :: Result) -> fmt :: Result { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { let (mut iter , mut format) = match self . inner . borrow_mut () . take () { Some (t) => t , None => panic ! ("FormatWith: was already formatted once") , } ; if let Some (fst) = iter . next () { format (fst , & mut | disp : & dyn fmt :: Display | disp . fmt (f)) ? ; for elt in iter { if self . sep . len () > 0 { f . write_str (self . sep) ? ; } format (elt , & mut | disp : & dyn fmt :: Display | disp . fmt (f)) ? ; } } Ok (()) } } impl < 'a , I > Format < 'a , I > where I : Iterator , { fn format < F > (& self , f : & mut fmt :: Formatter , mut cb : F) -> fmt :: Result where F : FnMut (& I :: Item , & mut fmt :: Formatter) -> fmt :: Result , { let mut iter = match self . inner . borrow_mut () . take () { Some (t) => t , None => panic ! ("Format: was already formatted once") , } ; if let Some (fst) = iter . next () { cb (& fst , f) ? ; for elt in iter { if self . sep . len () > 0 { f . write_str (self . sep) ? ; } cb (& elt , f) ? ; } } Ok (()) } } macro_rules ! impl_format { ($ ($ fmt_trait : ident) *) => { $ (impl <'a , I > fmt ::$ fmt_trait for Format <'a , I > where I : Iterator , I :: Item : fmt ::$ fmt_trait , { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { self . format (f , fmt ::$ fmt_trait :: fmt) } }) * } } impl_format ! { Display Debug UpperExp LowerExp UpperHex LowerHex Octal Binary Pointer } } # [cfg (feature = "use_std")] mod group_map { use std :: collections :: HashMap ; use std :: hash :: Hash ; use std :: iter :: Iterator ; # [doc = " Return a `HashMap` of keys mapped to a list of their corresponding values."] # [doc = ""] # [doc = " See [`.into_group_map()`](../trait.Itertools.html#method.into_group_map)"] # [doc = " for more information."] pub fn into_group_map < I , K , V > (iter : I) -> HashMap < K , Vec < V > > where I : Iterator < Item = (K , V) > , K : Hash + Eq , { let mut lookup = HashMap :: new () ; for (key , val) in iter { lookup . entry (key) . or_insert (Vec :: new ()) . push (val) ; } lookup } } # [cfg (feature = "use_std")] mod groupbylazy { use std :: cell :: { Cell , RefCell } ; use std :: vec ; # [doc = " A trait to unify FnMut for GroupBy with the chunk key in IntoChunks"] trait KeyFunction < A > { type Key ; fn call_mut (& mut self , arg : A) -> Self :: Key ; } impl < 'a , A , K , F : ? Sized > KeyFunction < A > for F where F : FnMut (A) -> K { type Key = K ; # [inline] fn call_mut (& mut self , arg : A) -> Self :: Key { (* self) (arg) } } # [doc = " ChunkIndex acts like the grouping key function for IntoChunks"] # [derive (Debug)] struct ChunkIndex { size : usize , index : usize , key : usize , } impl ChunkIndex { # [inline (always)] fn new (size : usize) -> Self { ChunkIndex { size , index : 0 , key : 0 , } } } impl < 'a , A > KeyFunction < A > for ChunkIndex { type Key = usize ; # [inline (always)] fn call_mut (& mut self , _arg : A) -> Self :: Key { if self . index == self . size { self . key += 1 ; self . index = 0 ; } self . index += 1 ; self . key } } struct GroupInner < K , I , F > where I : Iterator { key : F , iter : I , current_key : Option < K > , current_elt : Option < I :: Item > , # [doc = " flag set if iterator is exhausted"] done : bool , # [doc = " Index of group we are currently buffering or visiting"] top_group : usize , # [doc = " Least index for which we still have elements buffered"] oldest_buffered_group : usize , # [doc = " Group index for `buffer[0]` -- the slots"] # [doc = " bottom_group..oldest_buffered_group are unused and will be erased when"] # [doc = " that range is large enough."] bottom_group : usize , # [doc = " Buffered groups, from `bottom_group` (index 0) to `top_group`."] buffer : Vec < vec :: IntoIter < I :: Item > > , # [doc = " index of last group iter that was dropped, usize::MAX == none"] dropped_group : usize , } impl < K , I , F > GroupInner < K , I , F > where I : Iterator , F : for < 'a > KeyFunction < & 'a I :: Item , Key = K > , K : PartialEq , { # [doc = " `client`: Index of group that requests next element"] # [inline (always)] fn step (& mut self , client : usize) -> Option < I :: Item > { if client < self . oldest_buffered_group { None } else if client < self . top_group || (client == self . top_group && self . buffer . len () > self . top_group - self . bottom_group) { self . lookup_buffer (client) } else if self . done { None } else if self . top_group == client { self . step_current () } else { self . step_buffering (client) } } # [inline (never)] fn lookup_buffer (& mut self , client : usize) -> Option < I :: Item > { let bufidx = client - self . bottom_group ; if client < self . oldest_buffered_group { return None ; } let elt = self . buffer . get_mut (bufidx) . and_then (| queue | queue . next ()) ; if elt . is_none () && client == self . oldest_buffered_group { self . oldest_buffered_group += 1 ; while self . buffer . get (self . oldest_buffered_group - self . bottom_group) . map_or (false , | buf | buf . len () == 0) { self . oldest_buffered_group += 1 ; } let nclear = self . oldest_buffered_group - self . bottom_group ; if nclear > 0 && nclear >= self . buffer . len () / 2 { let mut i = 0 ; self . buffer . retain (| buf | { i += 1 ; debug_assert ! (buf . len () == 0 || i > nclear) ; i > nclear }) ; self . bottom_group = self . oldest_buffered_group ; } } elt } # [doc = " Take the next element from the iterator, and set the done"] # [doc = " flag if exhausted. Must not be called after done."] # [inline (always)] fn next_element (& mut self) -> Option < I :: Item > { debug_assert ! (! self . done) ; match self . iter . next () { None => { self . done = true ; None } otherwise => otherwise , } } # [inline (never)] fn step_buffering (& mut self , client : usize) -> Option < I :: Item > { debug_assert ! (self . top_group + 1 == client) ; let mut group = Vec :: new () ; if let Some (elt) = self . current_elt . take () { if self . top_group != self . dropped_group { group . push (elt) ; } } let mut first_elt = None ; while let Some (elt) = self . next_element () { let key = self . key . call_mut (& elt) ; match self . current_key . take () { None => { } Some (old_key) => if old_key != key { self . current_key = Some (key) ; first_elt = Some (elt) ; break ; } , } self . current_key = Some (key) ; if self . top_group != self . dropped_group { group . push (elt) ; } } if self . top_group != self . dropped_group { self . push_next_group (group) ; } if first_elt . is_some () { self . top_group += 1 ; debug_assert ! (self . top_group == client) ; } first_elt } fn push_next_group (& mut self , group : Vec < I :: Item >) { while self . top_group - self . bottom_group > self . buffer . len () { if self . buffer . is_empty () { self . bottom_group += 1 ; self . oldest_buffered_group += 1 ; } else { self . buffer . push (Vec :: new () . into_iter ()) ; } } self . buffer . push (group . into_iter ()) ; debug_assert ! (self . top_group + 1 - self . bottom_group == self . buffer . len ()) ; } # [doc = " This is the immediate case, where we use no buffering"] # [inline] fn step_current (& mut self) -> Option < I :: Item > { debug_assert ! (! self . done) ; if let elt @ Some (..) = self . current_elt . take () { return elt ; } match self . next_element () { None => None , Some (elt) => { let key = self . key . call_mut (& elt) ; match self . current_key . take () { None => { } Some (old_key) => if old_key != key { self . current_key = Some (key) ; self . current_elt = Some (elt) ; self . top_group += 1 ; return None ; } , } self . current_key = Some (key) ; Some (elt) } } } # [doc = " Request the just started groups' key."] # [doc = ""] # [doc = " `client`: Index of group"] # [doc = ""] # [doc = " **Panics** if no group key is available."] fn group_key (& mut self , client : usize) -> K { debug_assert ! (! self . done) ; debug_assert ! (client == self . top_group) ; debug_assert ! (self . current_key . is_some ()) ; debug_assert ! (self . current_elt . is_none ()) ; let old_key = self . current_key . take () . unwrap () ; if let Some (elt) = self . next_element () { let key = self . key . call_mut (& elt) ; if old_key != key { self . top_group += 1 ; } self . current_key = Some (key) ; self . current_elt = Some (elt) ; } old_key } } impl < K , I , F > GroupInner < K , I , F > where I : Iterator , { # [doc = " Called when a group is dropped"] fn drop_group (& mut self , client : usize) { if self . dropped_group == ! 0 || client > self . dropped_group { self . dropped_group = client ; } } } # [doc = " `GroupBy` is the storage for the lazy grouping operation."] # [doc = ""] # [doc = " If the groups are consumed in their original order, or if each"] # [doc = " group is dropped without keeping it around, then `GroupBy` uses"] # [doc = " no allocations. It needs allocations only if several group iterators"] # [doc = " are alive at the same time."] # [doc = ""] # [doc = " This type implements `IntoIterator` (it is **not** an iterator"] # [doc = " itself), because the group iterators need to borrow from this"] # [doc = " value. It should be stored in a local variable or temporary and"] # [doc = " iterated."] # [doc = ""] # [doc = " See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct GroupBy < K , I , F > where I : Iterator , { inner : RefCell < GroupInner < K , I , F > > , index : Cell < usize > , } # [doc = " Create a new"] pub fn new < K , J , F > (iter : J , f : F) -> GroupBy < K , J :: IntoIter , F > where J : IntoIterator , F : FnMut (& J :: Item) -> K , { GroupBy { inner : RefCell :: new (GroupInner { key : f , iter : iter . into_iter () , current_key : None , current_elt : None , done : false , top_group : 0 , oldest_buffered_group : 0 , bottom_group : 0 , buffer : Vec :: new () , dropped_group : ! 0 , }) , index : Cell :: new (0) , } } impl < K , I , F > GroupBy < K , I , F > where I : Iterator , { # [doc = " `client`: Index of group that requests next element"] fn step (& self , client : usize) -> Option < I :: Item > where F : FnMut (& I :: Item) -> K , K : PartialEq , { self . inner . borrow_mut () . step (client) } # [doc = " `client`: Index of group"] fn drop_group (& self , client : usize) { self . inner . borrow_mut () . drop_group (client) } } impl < 'a , K , I , F > IntoIterator for & 'a GroupBy < K , I , F > where I : Iterator , I :: Item : 'a , F : FnMut (& I :: Item) -> K , K : PartialEq { type Item = (K , Group < 'a , K , I , F >) ; type IntoIter = Groups < 'a , K , I , F > ; fn into_iter (self) -> Self :: IntoIter { Groups { parent : self } } } # [doc = " An iterator that yields the Group iterators."] # [doc = ""] # [doc = " Iterator element type is `(K, Group)`:"] # [doc = " the group's key `K` and the group's iterator."] # [doc = ""] # [doc = " See [`.group_by()`](../trait.Itertools.html#method.group_by) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Groups < 'a , K : 'a , I : 'a , F : 'a > where I : Iterator , I :: Item : 'a { parent : & 'a GroupBy < K , I , F > , } impl < 'a , K , I , F > Iterator for Groups < 'a , K , I , F > where I : Iterator , I :: Item : 'a , F : FnMut (& I :: Item) -> K , K : PartialEq { type Item = (K , Group < 'a , K , I , F >) ; # [inline] fn next (& mut self) -> Option < Self :: Item > { let index = self . parent . index . get () ; self . parent . index . set (index + 1) ; let inner = & mut * self . parent . inner . borrow_mut () ; inner . step (index) . map (| elt | { let key = inner . group_key (index) ; (key , Group { parent : self . parent , index , first : Some (elt) , }) }) } } # [doc = " An iterator for the elements in a single group."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] pub struct Group < 'a , K : 'a , I : 'a , F : 'a > where I : Iterator , I :: Item : 'a , { parent : & 'a GroupBy < K , I , F > , index : usize , first : Option < I :: Item > , } impl < 'a , K , I , F > Drop for Group < 'a , K , I , F > where I : Iterator , I :: Item : 'a , { fn drop (& mut self) { self . parent . drop_group (self . index) ; } } impl < 'a , K , I , F > Iterator for Group < 'a , K , I , F > where I : Iterator , I :: Item : 'a , F : FnMut (& I :: Item) -> K , K : PartialEq , { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < Self :: Item > { if let elt @ Some (..) = self . first . take () { return elt ; } self . parent . step (self . index) } } # [doc = " Create a new"] pub fn new_chunks < J > (iter : J , size : usize) -> IntoChunks < J :: IntoIter > where J : IntoIterator , { IntoChunks { inner : RefCell :: new (GroupInner { key : ChunkIndex :: new (size) , iter : iter . into_iter () , current_key : None , current_elt : None , done : false , top_group : 0 , oldest_buffered_group : 0 , bottom_group : 0 , buffer : Vec :: new () , dropped_group : ! 0 , }) , index : Cell :: new (0) , } } # [doc = " `ChunkLazy` is the storage for a lazy chunking operation."] # [doc = ""] # [doc = " `IntoChunks` behaves just like `GroupBy`: it is iterable, and"] # [doc = " it only buffers if several chunk iterators are alive at the same time."] # [doc = ""] # [doc = " This type implements `IntoIterator` (it is **not** an iterator"] # [doc = " itself), because the chunk iterators need to borrow from this"] # [doc = " value. It should be stored in a local variable or temporary and"] # [doc = " iterated."] # [doc = ""] # [doc = " Iterator element type is `Chunk`, each chunk's iterator."] # [doc = ""] # [doc = " See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct IntoChunks < I > where I : Iterator , { inner : RefCell < GroupInner < usize , I , ChunkIndex > > , index : Cell < usize > , } impl < I > IntoChunks < I > where I : Iterator , { # [doc = " `client`: Index of chunk that requests next element"] fn step (& self , client : usize) -> Option < I :: Item > { self . inner . borrow_mut () . step (client) } # [doc = " `client`: Index of chunk"] fn drop_group (& self , client : usize) { self . inner . borrow_mut () . drop_group (client) } } impl < 'a , I > IntoIterator for & 'a IntoChunks < I > where I : Iterator , I :: Item : 'a , { type Item = Chunk < 'a , I > ; type IntoIter = Chunks < 'a , I > ; fn into_iter (self) -> Self :: IntoIter { Chunks { parent : self , } } } # [doc = " An iterator that yields the Chunk iterators."] # [doc = ""] # [doc = " Iterator element type is `Chunk`."] # [doc = ""] # [doc = " See [`.chunks()`](../trait.Itertools.html#method.chunks) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Chunks < 'a , I : 'a > where I : Iterator , I :: Item : 'a , { parent : & 'a IntoChunks < I > , } impl < 'a , I > Iterator for Chunks < 'a , I > where I : Iterator , I :: Item : 'a , { type Item = Chunk < 'a , I > ; # [inline] fn next (& mut self) -> Option < Self :: Item > { let index = self . parent . index . get () ; self . parent . index . set (index + 1) ; let inner = & mut * self . parent . inner . borrow_mut () ; inner . step (index) . map (| elt | { Chunk { parent : self . parent , index , first : Some (elt) , } }) } } # [doc = " An iterator for the elements in a single chunk."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] pub struct Chunk < 'a , I : 'a > where I : Iterator , I :: Item : 'a , { parent : & 'a IntoChunks < I > , index : usize , first : Option < I :: Item > , } impl < 'a , I > Drop for Chunk < 'a , I > where I : Iterator , I :: Item : 'a , { fn drop (& mut self) { self . parent . drop_group (self . index) ; } } impl < 'a , I > Iterator for Chunk < 'a , I > where I : Iterator , I :: Item : 'a , { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < Self :: Item > { if let elt @ Some (..) = self . first . take () { return elt ; } self . parent . step (self . index) } } } mod intersperse { use std :: iter :: Fuse ; use super :: size_hint ; # [derive (Clone)] # [doc = " An iterator adaptor to insert a particular value"] # [doc = " between each element of the adapted iterator."] # [doc = ""] # [doc = " Iterator element type is `I::Item`"] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " See [`.intersperse()`](../trait.Itertools.html#method.intersperse) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] # [derive (Debug)] pub struct Intersperse < I > where I : Iterator { element : I :: Item , iter : Fuse < I > , peek : Option < I :: Item > , } # [doc = " Create a new Intersperse iterator"] pub fn intersperse < I > (iter : I , elt : I :: Item) -> Intersperse < I > where I : Iterator { let mut iter = iter . fuse () ; Intersperse { peek : iter . next () , iter , element : elt , } } impl < I > Iterator for Intersperse < I > where I : Iterator , I :: Item : Clone { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { if self . peek . is_some () { self . peek . take () } else { self . peek = self . iter . next () ; if self . peek . is_some () { Some (self . element . clone ()) } else { None } } } fn size_hint (& self) -> (usize , Option < usize >) { let has_peek = self . peek . is_some () as usize ; let sh = self . iter . size_hint () ; size_hint :: add_scalar (size_hint :: add (sh , sh) , has_peek) } fn fold < B , F > (mut self , init : B , mut f : F) -> B where Self : Sized , F : FnMut (B , Self :: Item) -> B , { let mut accum = init ; if let Some (x) = self . peek . take () { accum = f (accum , x) ; } let element = & self . element ; self . iter . fold (accum , | accum , x | { let accum = f (accum , element . clone ()) ; let accum = f (accum , x) ; accum }) } } } # [cfg (feature = "use_std")] mod kmerge_impl { use crate :: size_hint ; use crate :: Itertools ; use std :: mem :: replace ; use std :: fmt ; # [doc = " Head element and Tail iterator pair"] # [doc = ""] # [doc = " `PartialEq`, `Eq`, `PartialOrd` and `Ord` are implemented by comparing sequences based on"] # [doc = " first items (which are guaranteed to exist)."] # [doc = ""] # [doc = " The meanings of `PartialOrd` and `Ord` are reversed so as to turn the heap used in"] # [doc = " `KMerge` into a min-heap."] # [derive (Debug)] struct HeadTail < I > where I : Iterator { head : I :: Item , tail : I , } impl < I > HeadTail < I > where I : Iterator { # [doc = " Constructs a `HeadTail` from an `Iterator`. Returns `None` if the `Iterator` is empty."] fn new (mut it : I) -> Option < HeadTail < I > > { let head = it . next () ; head . map (| h | { HeadTail { head : h , tail : it , } }) } # [doc = " Get the next element and update `head`, returning the old head in `Some`."] # [doc = ""] # [doc = " Returns `None` when the tail is exhausted (only `head` then remains)."] fn next (& mut self) -> Option < I :: Item > { if let Some (next) = self . tail . next () { Some (replace (& mut self . head , next)) } else { None } } # [doc = " Hints at the size of the sequence, same as the `Iterator` method."] fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: add_scalar (self . tail . size_hint () , 1) } } impl < I > Clone for HeadTail < I > where I : Iterator + Clone , I :: Item : Clone { clone_fields ! (head , tail) ; } # [doc = " Make `data` a heap (min-heap w.r.t the sorting)."] fn heapify < T , S > (data : & mut [T] , mut less_than : S) where S : FnMut (& T , & T) -> bool { for i in (0 .. data . len () / 2) . rev () { sift_down (data , i , & mut less_than) ; } } # [doc = " Sift down element at `index` (`heap` is a min-heap wrt the ordering)"] fn sift_down < T , S > (heap : & mut [T] , index : usize , mut less_than : S) where S : FnMut (& T , & T) -> bool { debug_assert ! (index <= heap . len ()) ; let mut pos = index ; let mut child = 2 * pos + 1 ; while pos < heap . len () && child < heap . len () { let right = child + 1 ; if right < heap . len () && less_than (& heap [right] , & heap [child]) { child = right ; } if ! less_than (& heap [child] , & heap [pos]) { return ; } heap . swap (pos , child) ; pos = child ; child = 2 * pos + 1 ; } } # [doc = " An iterator adaptor that merges an abitrary number of base iterators in ascending order."] # [doc = " If all base iterators are sorted (ascending), the result is sorted."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] # [doc = ""] # [doc = " See [`.kmerge()`](../trait.Itertools.html#method.kmerge) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub type KMerge < I > = KMergeBy < I , KMergeByLt > ; pub trait KMergePredicate < T > { fn kmerge_pred (& mut self , a : & T , b : & T) -> bool ; } # [derive (Clone)] pub struct KMergeByLt ; impl < T : PartialOrd > KMergePredicate < T > for KMergeByLt { fn kmerge_pred (& mut self , a : & T , b : & T) -> bool { a < b } } impl < T , F : FnMut (& T , & T) -> bool > KMergePredicate < T > for F { fn kmerge_pred (& mut self , a : & T , b : & T) -> bool { self (a , b) } } # [doc = " Create an iterator that merges elements of the contained iterators using"] # [doc = " the ordering function."] # [doc = ""] # [doc = " Equivalent to `iterable.into_iter().kmerge()`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::kmerge;"] # [doc = ""] # [doc = " for elt in kmerge(vec![vec![0, 2, 4], vec![1, 3, 5], vec![6, 7]]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn kmerge < I > (iterable : I) -> KMerge < < I :: Item as IntoIterator > :: IntoIter > where I : IntoIterator , I :: Item : IntoIterator , < < I as IntoIterator > :: Item as IntoIterator > :: Item : PartialOrd { kmerge_by (iterable , KMergeByLt) } # [doc = " An iterator adaptor that merges an abitrary number of base iterators"] # [doc = " according to an ordering function."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] # [doc = ""] # [doc = " See [`.kmerge_by()`](../trait.Itertools.html#method.kmerge_by) for more"] # [doc = " information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct KMergeBy < I , F > where I : Iterator , { heap : Vec < HeadTail < I > > , less_than : F , } impl < I , F > fmt :: Debug for KMergeBy < I , F > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug , { debug_fmt_fields ! (KMergeBy , heap) ; } # [doc = " Create an iterator that merges elements of the contained iterators."] # [doc = ""] # [doc = " Equivalent to `iterable.into_iter().kmerge_by(less_than)`."] pub fn kmerge_by < I , F > (iterable : I , mut less_than : F) -> KMergeBy < < I :: Item as IntoIterator > :: IntoIter , F > where I : IntoIterator , I :: Item : IntoIterator , F : KMergePredicate < < < I as IntoIterator > :: Item as IntoIterator > :: Item > , { let iter = iterable . into_iter () ; let (lower , _) = iter . size_hint () ; let mut heap : Vec < _ > = Vec :: with_capacity (lower) ; heap . extend (iter . filter_map (| it | HeadTail :: new (it . into_iter ()))) ; heapify (& mut heap , | a , b | less_than . kmerge_pred (& a . head , & b . head)) ; KMergeBy { heap , less_than } } impl < I , F > Clone for KMergeBy < I , F > where I : Iterator + Clone , I :: Item : Clone , F : Clone , { clone_fields ! (heap , less_than) ; } impl < I , F > Iterator for KMergeBy < I , F > where I : Iterator , F : KMergePredicate < I :: Item > { type Item = I :: Item ; fn next (& mut self) -> Option < Self :: Item > { if self . heap . is_empty () { return None ; } let result = if let Some (next) = self . heap [0] . next () { next } else { self . heap . swap_remove (0) . head } ; let less_than = & mut self . less_than ; sift_down (& mut self . heap , 0 , | a , b | less_than . kmerge_pred (& a . head , & b . head)) ; Some (result) } fn size_hint (& self) -> (usize , Option < usize >) { self . heap . iter () . map (| i | i . size_hint ()) . fold1 (size_hint :: add) . unwrap_or ((0 , Some (0))) } } } # [cfg (feature = "use_std")] mod lazy_buffer { use std :: ops :: Index ; # [derive (Debug , Clone)] pub struct LazyBuffer < I : Iterator > { pub it : I , done : bool , buffer : Vec < I :: Item > , } impl < I > LazyBuffer < I > where I : Iterator , { pub fn new (it : I) -> LazyBuffer < I > { LazyBuffer { it , done : false , buffer : Vec :: new () , } } pub fn len (& self) -> usize { self . buffer . len () } pub fn is_done (& self) -> bool { self . done } pub fn get_next (& mut self) -> bool { if self . done { return false ; } let next_item = self . it . next () ; match next_item { Some (x) => { self . buffer . push (x) ; true } None => { self . done = true ; false } } } } impl < I , J > Index < J > for LazyBuffer < I > where I : Iterator , I :: Item : Sized , Vec < I :: Item > : Index < J > { type Output = < Vec < I :: Item > as Index < J > > :: Output ; fn index (& self , _index : J) -> & Self :: Output { self . buffer . index (_index) } } } mod merge_join { use std :: cmp :: Ordering ; use std :: iter :: Fuse ; use std :: fmt ; use super :: adaptors :: { PutBack , put_back } ; use crate :: either_or_both :: EitherOrBoth ; # [doc = " Return an iterator adaptor that merge-joins items from the two base iterators in ascending order."] # [doc = ""] # [doc = " See [`.merge_join_by()`](trait.Itertools.html#method.merge_join_by) for more information."] pub fn merge_join_by < I , J , F > (left : I , right : J , cmp_fn : F) -> MergeJoinBy < I :: IntoIter , J :: IntoIter , F > where I : IntoIterator , J : IntoIterator , F : FnMut (& I :: Item , & J :: Item) -> Ordering { MergeJoinBy { left : put_back (left . into_iter () . fuse ()) , right : put_back (right . into_iter () . fuse ()) , cmp_fn , } } # [doc = " An iterator adaptor that merge-joins items from the two base iterators in ascending order."] # [doc = ""] # [doc = " See [`.merge_join_by()`](../trait.Itertools.html#method.merge_join_by) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct MergeJoinBy < I : Iterator , J : Iterator , F > { left : PutBack < Fuse < I > > , right : PutBack < Fuse < J > > , cmp_fn : F } impl < I , J , F > Clone for MergeJoinBy < I , J , F > where I : Iterator , J : Iterator , PutBack < Fuse < I > > : Clone , PutBack < Fuse < J > > : Clone , F : Clone , { clone_fields ! (left , right , cmp_fn) ; } impl < I , J , F > fmt :: Debug for MergeJoinBy < I , J , F > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug , J : Iterator + fmt :: Debug , J :: Item : fmt :: Debug , { debug_fmt_fields ! (MergeJoinBy , left , right) ; } impl < I , J , F > Iterator for MergeJoinBy < I , J , F > where I : Iterator , J : Iterator , F : FnMut (& I :: Item , & J :: Item) -> Ordering { type Item = EitherOrBoth < I :: Item , J :: Item > ; fn next (& mut self) -> Option < Self :: Item > { match (self . left . next () , self . right . next ()) { (None , None) => None , (Some (left) , None) => Some (EitherOrBoth :: Left (left)) , (None , Some (right)) => Some (EitherOrBoth :: Right (right)) , (Some (left) , Some (right)) => { match (self . cmp_fn) (& left , & right) { Ordering :: Equal => Some (EitherOrBoth :: Both (left , right)) , Ordering :: Less => { self . right . put_back (right) ; Some (EitherOrBoth :: Left (left)) } , Ordering :: Greater => { self . left . put_back (left) ; Some (EitherOrBoth :: Right (right)) } } } } } fn size_hint (& self) -> (usize , Option < usize >) { let (a_lower , a_upper) = self . left . size_hint () ; let (b_lower , b_upper) = self . right . size_hint () ; let lower = :: std :: cmp :: max (a_lower , b_lower) ; let upper = match (a_upper , b_upper) { (Some (x) , Some (y)) => x . checked_add (y) , _ => None , } ; (lower , upper) } fn count (mut self) -> usize { let mut count = 0 ; loop { match (self . left . next () , self . right . next ()) { (None , None) => break count , (Some (_left) , None) => break count + 1 + self . left . into_parts () . 1 . count () , (None , Some (_right)) => break count + 1 + self . right . into_parts () . 1 . count () , (Some (left) , Some (right)) => { count += 1 ; match (self . cmp_fn) (& left , & right) { Ordering :: Equal => { } Ordering :: Less => self . right . put_back (right) , Ordering :: Greater => self . left . put_back (left) , } } } } } fn last (mut self) -> Option < Self :: Item > { let mut previous_element = None ; loop { match (self . left . next () , self . right . next ()) { (None , None) => break previous_element , (Some (left) , None) => { break Some (EitherOrBoth :: Left (self . left . into_parts () . 1 . last () . unwrap_or (left) ,)) } (None , Some (right)) => { break Some (EitherOrBoth :: Right (self . right . into_parts () . 1 . last () . unwrap_or (right) ,)) } (Some (left) , Some (right)) => { previous_element = match (self . cmp_fn) (& left , & right) { Ordering :: Equal => Some (EitherOrBoth :: Both (left , right)) , Ordering :: Less => { self . right . put_back (right) ; Some (EitherOrBoth :: Left (left)) } Ordering :: Greater => { self . left . put_back (left) ; Some (EitherOrBoth :: Right (right)) } } } } } } fn nth (& mut self , mut n : usize) -> Option < Self :: Item > { loop { if n == 0 { break self . next () ; } n -= 1 ; match (self . left . next () , self . right . next ()) { (None , None) => break None , (Some (_left) , None) => break self . left . nth (n) . map (EitherOrBoth :: Left) , (None , Some (_right)) => break self . right . nth (n) . map (EitherOrBoth :: Right) , (Some (left) , Some (right)) => match (self . cmp_fn) (& left , & right) { Ordering :: Equal => { } Ordering :: Less => self . right . put_back (right) , Ordering :: Greater => self . left . put_back (left) , } , } } } } } mod minmax { # [doc = " `MinMaxResult` is an enum returned by `minmax`. See `Itertools::minmax()` for"] # [doc = " more detail."] # [derive (Copy , Clone , PartialEq , Debug)] pub enum MinMaxResult < T > { # [doc = " Empty iterator"] NoElements , # [doc = " Iterator with one element, so the minimum and maximum are the same"] OneElement (T) , # [doc = " More than one element in the iterator, the first element is not larger"] # [doc = " than the second"] MinMax (T , T) } impl < T : Clone > MinMaxResult < T > { # [doc = " `into_option` creates an `Option` of type `(T, T)`. The returned `Option`"] # [doc = " has variant `None` if and only if the `MinMaxResult` has variant"] # [doc = " `NoElements`. Otherwise `Some((x, y))` is returned where `x <= y`."] # [doc = " If the `MinMaxResult` has variant `OneElement(x)`, performing this"] # [doc = " operation will make one clone of `x`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::MinMaxResult::{self, NoElements, OneElement, MinMax};"] # [doc = ""] # [doc = " let r: MinMaxResult<i32> = NoElements;"] # [doc = " assert_eq!(r.into_option(), None);"] # [doc = ""] # [doc = " let r = OneElement(1);"] # [doc = " assert_eq!(r.into_option(), Some((1, 1)));"] # [doc = ""] # [doc = " let r = MinMax(1, 2);"] # [doc = " assert_eq!(r.into_option(), Some((1, 2)));"] # [doc = " ```"] pub fn into_option (self) -> Option < (T , T) > { match self { MinMaxResult :: NoElements => None , MinMaxResult :: OneElement (x) => Some ((x . clone () , x)) , MinMaxResult :: MinMax (x , y) => Some ((x , y)) } } } # [doc = " Implementation guts for `minmax` and `minmax_by_key`."] pub fn minmax_impl < I , K , F , L > (mut it : I , mut key_for : F , mut lt : L) -> MinMaxResult < I :: Item > where I : Iterator , F : FnMut (& I :: Item) -> K , L : FnMut (& I :: Item , & I :: Item , & K , & K) -> bool , { let (mut min , mut max , mut min_key , mut max_key) = match it . next () { None => return MinMaxResult :: NoElements , Some (x) => { match it . next () { None => return MinMaxResult :: OneElement (x) , Some (y) => { let xk = key_for (& x) ; let yk = key_for (& y) ; if ! lt (& y , & x , & yk , & xk) { (x , y , xk , yk) } else { (y , x , yk , xk) } } } } } ; loop { let first = match it . next () { None => break , Some (x) => x } ; let second = match it . next () { None => { let first_key = key_for (& first) ; if lt (& first , & min , & first_key , & min_key) { min = first ; } else if ! lt (& first , & max , & first_key , & max_key) { max = first ; } break ; } Some (x) => x } ; let first_key = key_for (& first) ; let second_key = key_for (& second) ; if ! lt (& second , & first , & second_key , & first_key) { if lt (& first , & min , & first_key , & min_key) { min = first ; min_key = first_key ; } if ! lt (& second , & max , & second_key , & max_key) { max = second ; max_key = second_key ; } } else { if lt (& second , & min , & second_key , & min_key) { min = second ; min_key = second_key ; } if ! lt (& first , & max , & first_key , & max_key) { max = first ; max_key = first_key ; } } } MinMaxResult :: MinMax (min , max) } } # [cfg (feature = "use_std")] mod multipeek_impl { use std :: iter :: Fuse ; use std :: collections :: VecDeque ; use crate :: size_hint ; use crate :: PeekingNext ; # [doc = " See [`multipeek()`](../fn.multipeek.html) for more information."] # [derive (Clone , Debug)] pub struct MultiPeek < I > where I : Iterator { iter : Fuse < I > , buf : VecDeque < I :: Item > , index : usize , } # [doc = " An iterator adaptor that allows the user to peek at multiple `.next()`"] # [doc = " values without advancing the base iterator."] pub fn multipeek < I > (iterable : I) -> MultiPeek < I :: IntoIter > where I : IntoIterator { MultiPeek { iter : iterable . into_iter () . fuse () , buf : VecDeque :: new () , index : 0 , } } impl < I > MultiPeek < I > where I : Iterator { # [doc = " Reset the peeking cursor"] pub fn reset_peek (& mut self) { self . index = 0 ; } } impl < I : Iterator > MultiPeek < I > { # [doc = " Works exactly like `.next()` with the only difference that it doesn't"] # [doc = " advance itself. `.peek()` can be called multiple times, to peek"] # [doc = " further ahead."] pub fn peek (& mut self) -> Option < & I :: Item > { let ret = if self . index < self . buf . len () { Some (& self . buf [self . index]) } else { match self . iter . next () { Some (x) => { self . buf . push_back (x) ; Some (& self . buf [self . index]) } None => return None , } } ; self . index += 1 ; ret } } impl < I > PeekingNext for MultiPeek < I > where I : Iterator , { fn peeking_next < F > (& mut self , accept : F) -> Option < Self :: Item > where F : FnOnce (& Self :: Item) -> bool { if self . buf . is_empty () { if let Some (r) = self . peek () { if ! accept (r) { return None } } } else { if let Some (r) = self . buf . get (0) { if ! accept (r) { return None } } } self . next () } } impl < I > Iterator for MultiPeek < I > where I : Iterator { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { self . index = 0 ; if self . buf . is_empty () { self . iter . next () } else { self . buf . pop_front () } } fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: add_scalar (self . iter . size_hint () , self . buf . len ()) } } impl < I > ExactSizeIterator for MultiPeek < I > where I : ExactSizeIterator { } } mod pad_tail { use std :: iter :: Fuse ; use crate :: size_hint ; # [doc = " An iterator adaptor that pads a sequence to a minimum length by filling"] # [doc = " missing elements using a closure."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] # [doc = ""] # [doc = " See [`.pad_using()`](../trait.Itertools.html#method.pad_using) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct PadUsing < I , F > { iter : Fuse < I > , min : usize , pos : usize , filler : F , } # [doc = " Create a new **PadUsing** iterator."] pub fn pad_using < I , F > (iter : I , min : usize , filler : F) -> PadUsing < I , F > where I : Iterator , F : FnMut (usize) -> I :: Item { PadUsing { iter : iter . fuse () , min , pos : 0 , filler , } } impl < I , F > Iterator for PadUsing < I , F > where I : Iterator , F : FnMut (usize) -> I :: Item { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { match self . iter . next () { None => { if self . pos < self . min { let e = Some ((self . filler) (self . pos)) ; self . pos += 1 ; e } else { None } } , e => { self . pos += 1 ; e } } } fn size_hint (& self) -> (usize , Option < usize >) { let tail = self . min . saturating_sub (self . pos) ; size_hint :: max (self . iter . size_hint () , (tail , Some (tail))) } } impl < I , F > DoubleEndedIterator for PadUsing < I , F > where I : DoubleEndedIterator + ExactSizeIterator , F : FnMut (usize) -> I :: Item { fn next_back (& mut self) -> Option < I :: Item > { if self . min == 0 { self . iter . next_back () } else if self . iter . len () >= self . min { self . min -= 1 ; self . iter . next_back () } else { self . min -= 1 ; Some ((self . filler) (self . min)) } } } impl < I , F > ExactSizeIterator for PadUsing < I , F > where I : ExactSizeIterator , F : FnMut (usize) -> I :: Item { } } mod peeking_take_while { use std :: iter :: Peekable ; use crate :: PutBack ; # [cfg (feature = "use_std")] use crate :: PutBackN ; # [doc = " An iterator that allows peeking at an element before deciding to accept it."] # [doc = ""] # [doc = " See [`.peeking_take_while()`](trait.Itertools.html#method.peeking_take_while)"] # [doc = " for more information."] # [doc = ""] # [doc = " This is implemented by peeking adaptors like peekable and put back,"] # [doc = " but also by a few iterators that can be peeked natively, like the slices"] # [doc = " by reference iterator (`std::slice::Iter`)."] pub trait PeekingNext : Iterator { # [doc = " Pass a reference to the next iterator element to the closure `accept`;"] # [doc = " if `accept` returns true, return it as the next element,"] # [doc = " else None."] fn peeking_next < F > (& mut self , accept : F) -> Option < Self :: Item > where F : FnOnce (& Self :: Item) -> bool ; } impl < I > PeekingNext for Peekable < I > where I : Iterator , { fn peeking_next < F > (& mut self , accept : F) -> Option < Self :: Item > where F : FnOnce (& Self :: Item) -> bool { if let Some (r) = self . peek () { if ! accept (r) { return None ; } } self . next () } } impl < I > PeekingNext for PutBack < I > where I : Iterator , { fn peeking_next < F > (& mut self , accept : F) -> Option < Self :: Item > where F : FnOnce (& Self :: Item) -> bool { if let Some (r) = self . next () { if ! accept (& r) { self . put_back (r) ; return None ; } Some (r) } else { None } } } # [cfg (feature = "use_std")] impl < I > PeekingNext for PutBackN < I > where I : Iterator , { fn peeking_next < F > (& mut self , accept : F) -> Option < Self :: Item > where F : FnOnce (& Self :: Item) -> bool { if let Some (r) = self . next () { if ! accept (& r) { self . put_back (r) ; return None ; } Some (r) } else { None } } } # [doc = " An iterator adaptor that takes items while a closure returns `true`."] # [doc = ""] # [doc = " See [`.peeking_take_while()`](../trait.Itertools.html#method.peeking_take_while)"] # [doc = " for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct PeekingTakeWhile < 'a , I : 'a , F > where I : Iterator , { iter : & 'a mut I , f : F , } # [doc = " Create a PeekingTakeWhile"] pub fn peeking_take_while < I , F > (iter : & mut I , f : F) -> PeekingTakeWhile < I , F > where I : Iterator , { PeekingTakeWhile { iter , f , } } impl < 'a , I , F > Iterator for PeekingTakeWhile < 'a , I , F > where I : PeekingNext , F : FnMut (& I :: Item) -> bool , { type Item = I :: Item ; fn next (& mut self) -> Option < Self :: Item > { self . iter . peeking_next (& mut self . f) } fn size_hint (& self) -> (usize , Option < usize >) { let (_ , hi) = self . iter . size_hint () ; (0 , hi) } } macro_rules ! peeking_next_by_clone { ([$ ($ typarm : tt) *] $ type_ : ty) => { impl <$ ($ typarm) *> PeekingNext for $ type_ { fn peeking_next < F > (& mut self , accept : F) -> Option < Self :: Item > where F : FnOnce (& Self :: Item) -> bool { let saved_state = self . clone () ; if let Some (r) = self . next () { if ! accept (& r) { * self = saved_state ; } else { return Some (r) } } None } } } } peeking_next_by_clone ! { ['a , T] :: std :: slice :: Iter <'a , T > } peeking_next_by_clone ! { ['a] :: std :: str :: Chars <'a > } peeking_next_by_clone ! { ['a] :: std :: str :: CharIndices <'a > } peeking_next_by_clone ! { ['a] :: std :: str :: Bytes <'a > } peeking_next_by_clone ! { ['a , T] :: std :: option :: Iter <'a , T > } peeking_next_by_clone ! { ['a , T] :: std :: result :: Iter <'a , T > } peeking_next_by_clone ! { [T] :: std :: iter :: Empty < T > } # [cfg (feature = "use_std")] peeking_next_by_clone ! { ['a , T] :: std :: collections :: linked_list :: Iter <'a , T > } # [cfg (feature = "use_std")] peeking_next_by_clone ! { ['a , T] :: std :: collections :: vec_deque :: Iter <'a , T > } peeking_next_by_clone ! { [I : Clone + PeekingNext + DoubleEndedIterator] :: std :: iter :: Rev < I > } } # [cfg (feature = "use_std")] mod permutations { use std :: fmt ; use std :: iter :: once ; use super :: lazy_buffer :: LazyBuffer ; # [doc = " An iterator adaptor that iterates through all the `k`-permutations of the"] # [doc = " elements from an iterator."] # [doc = ""] # [doc = " See [`.permutations()`](../trait.Itertools.html#method.permutations) for"] # [doc = " more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Permutations < I : Iterator > { vals : LazyBuffer < I > , state : PermutationState , } impl < I > Clone for Permutations < I > where I : Clone + Iterator , I :: Item : Clone , { clone_fields ! (vals , state) ; } # [derive (Clone , Debug)] enum PermutationState { StartUnknownLen { k : usize , } , OngoingUnknownLen { k : usize , min_n : usize , } , Complete (CompleteState) , Empty , } # [derive (Clone , Debug)] enum CompleteState { Start { n : usize , k : usize , } , Ongoing { indices : Vec < usize > , cycles : Vec < usize > , } } enum CompleteStateRemaining { Known (usize) , Overflow , } impl < I > fmt :: Debug for Permutations < I > where I : Iterator + fmt :: Debug , I :: Item : fmt :: Debug , { debug_fmt_fields ! (Permutations , vals , state) ; } pub fn permutations < I : Iterator > (iter : I , k : usize) -> Permutations < I > { let mut vals = LazyBuffer :: new (iter) ; if k == 0 { let state = PermutationState :: Complete (CompleteState :: Start { n : 0 , k : 0 }) ; return Permutations { vals , state } ; } let mut enough_vals = true ; while vals . len () < k { if ! vals . get_next () { enough_vals = false ; break ; } } let state = if enough_vals { PermutationState :: StartUnknownLen { k } } else { PermutationState :: Empty } ; Permutations { vals , state } } impl < I > Iterator for Permutations < I > where I : Iterator , I :: Item : Clone { type Item = Vec < I :: Item > ; fn next (& mut self) -> Option < Self :: Item > { self . advance () ; let & mut Permutations { ref vals , ref state } = self ; match state { & PermutationState :: StartUnknownLen { .. } => panic ! ("unexpected iterator state") , & PermutationState :: OngoingUnknownLen { k , min_n } => { let latest_idx = min_n - 1 ; let indices = (0 .. (k - 1)) . chain (once (latest_idx)) ; Some (indices . map (| i | vals [i] . clone ()) . collect ()) } & PermutationState :: Complete (CompleteState :: Start { .. }) => None , & PermutationState :: Complete (CompleteState :: Ongoing { ref indices , ref cycles }) => { let k = cycles . len () ; Some (indices [0 .. k] . iter () . map (| & i | vals [i] . clone ()) . collect ()) } , & PermutationState :: Empty => None } } fn count (self) -> usize { let Permutations { vals , state } = self ; fn from_complete (complete_state : CompleteState) -> usize { match complete_state . remaining () { CompleteStateRemaining :: Known (count) => count , CompleteStateRemaining :: Overflow => { panic ! ("Iterator count greater than usize::MAX") ; } } } match state { PermutationState :: StartUnknownLen { k } => { let n = vals . len () + vals . it . count () ; let complete_state = CompleteState :: Start { n , k } ; from_complete (complete_state) } PermutationState :: OngoingUnknownLen { k , min_n } => { let prev_iteration_count = min_n - k + 1 ; let n = vals . len () + vals . it . count () ; let complete_state = CompleteState :: Start { n , k } ; from_complete (complete_state) - prev_iteration_count } , PermutationState :: Complete (state) => from_complete (state) , PermutationState :: Empty => 0 } } fn size_hint (& self) -> (usize , Option < usize >) { match self . state { PermutationState :: StartUnknownLen { .. } | PermutationState :: OngoingUnknownLen { .. } => (0 , None) , PermutationState :: Complete (ref state) => match state . remaining () { CompleteStateRemaining :: Known (count) => (count , Some (count)) , CompleteStateRemaining :: Overflow => (:: std :: usize :: MAX , None) } PermutationState :: Empty => (0 , Some (0)) } } } impl < I > Permutations < I > where I : Iterator , I :: Item : Clone { fn advance (& mut self) { let & mut Permutations { ref mut vals , ref mut state } = self ; * state = match state { & mut PermutationState :: StartUnknownLen { k } => { PermutationState :: OngoingUnknownLen { k , min_n : k } } & mut PermutationState :: OngoingUnknownLen { k , min_n } => { if vals . get_next () { PermutationState :: OngoingUnknownLen { k , min_n : min_n + 1 } } else { let n = min_n ; let prev_iteration_count = n - k + 1 ; let mut complete_state = CompleteState :: Start { n , k } ; for _ in 0 .. (prev_iteration_count + 1) { complete_state . advance () ; } PermutationState :: Complete (complete_state) } } & mut PermutationState :: Complete (ref mut state) => { state . advance () ; return ; } & mut PermutationState :: Empty => { return ; } } ; } } impl CompleteState { fn advance (& mut self) { * self = match self { & mut CompleteState :: Start { n , k } => { let indices = (0 .. n) . collect () ; let cycles = ((n - k) .. n) . rev () . collect () ; CompleteState :: Ongoing { cycles , indices } } , & mut CompleteState :: Ongoing { ref mut indices , ref mut cycles } => { let n = indices . len () ; let k = cycles . len () ; for i in (0 .. k) . rev () { if cycles [i] == 0 { cycles [i] = n - i - 1 ; let to_push = indices . remove (i) ; indices . push (to_push) ; } else { let swap_index = n - cycles [i] ; indices . swap (i , swap_index) ; cycles [i] -= 1 ; return ; } } CompleteState :: Start { n , k } } } } fn remaining (& self) -> CompleteStateRemaining { use self :: CompleteStateRemaining :: { Known , Overflow } ; match self { & CompleteState :: Start { n , k } => { if n < k { return Known (0) ; } let count : Option < usize > = (n - k + 1 .. n + 1) . fold (Some (1) , | acc , i | { acc . and_then (| acc | acc . checked_mul (i)) }) ; match count { Some (count) => Known (count) , None => Overflow } } & CompleteState :: Ongoing { ref indices , ref cycles } => { let mut count : usize = 0 ; for (i , & c) in cycles . iter () . enumerate () { let radix = indices . len () - i ; let next_count = count . checked_mul (radix) . and_then (| count | count . checked_add (c)) ; count = match next_count { Some (count) => count , None => { return Overflow ; } } ; } Known (count) } } } } } mod process_results_impl { # [doc = " An iterator that produces only the `T` values as long as the"] # [doc = " inner iterator produces `Ok(T)`."] # [doc = ""] # [doc = " Used by [`process_results`](../fn.process_results.html), see its docs"] # [doc = " for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] # [derive (Debug)] pub struct ProcessResults < 'a , I , E : 'a > { error : & 'a mut Result < () , E > , iter : I , } impl < 'a , I , T , E > Iterator for ProcessResults < 'a , I , E > where I : Iterator < Item = Result < T , E > > { type Item = T ; fn next (& mut self) -> Option < Self :: Item > { match self . iter . next () { Some (Ok (x)) => Some (x) , Some (Err (e)) => { * self . error = Err (e) ; None } None => None , } } fn size_hint (& self) -> (usize , Option < usize >) { let (_ , hi) = self . iter . size_hint () ; (0 , hi) } } # [doc = " Lift a function of the values of an iterator so that it can process"] # [doc = " an iterator of `Result` values instead."] # [doc = ""] # [doc = " `iterable` is an iterator or iterable with `Result<T, E>` elements, where"] # [doc = " `T` is the value type and `E` the error type."] # [doc = ""] # [doc = " `processor` is a closure that receives an adapted version of the iterable"] # [doc = " as the only argument  the adapted iterator produces elements of type `T`,"] # [doc = " as long as the original iterator produces `Ok` values."] # [doc = ""] # [doc = " If the original iterable produces an error at any point, the adapted"] # [doc = " iterator ends and the `process_results` function will return the"] # [doc = " error iself."] # [doc = ""] # [doc = " Otherwise, the return value from the closure is returned wrapped"] # [doc = " inside `Ok`."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::process_results;"] # [doc = ""] # [doc = " type R = Result<i32, &'static str>;"] # [doc = ""] # [doc = " let first_values: Vec<R> = vec![Ok(1), Ok(0), Ok(3)];"] # [doc = " let second_values: Vec<R> = vec![Ok(2), Ok(1), Err(\"overflow\")];"] # [doc = ""] # [doc = " // Lift the iterator .max() method to work on the values in Results using process_results"] # [doc = ""] # [doc = " let first_max = process_results(first_values, |iter| iter.max().unwrap_or(0));"] # [doc = " let second_max = process_results(second_values, |iter| iter.max().unwrap_or(0));"] # [doc = ""] # [doc = " assert_eq!(first_max, Ok(3));"] # [doc = " assert!(second_max.is_err());"] # [doc = " ```"] pub fn process_results < I , F , T , E , R > (iterable : I , processor : F) -> Result < R , E > where I : IntoIterator < Item = Result < T , E > > , F : FnOnce (ProcessResults < I :: IntoIter , E >) -> R { let iter = iterable . into_iter () ; let mut error = Ok (()) ; let result = processor (ProcessResults { error : & mut error , iter }) ; error . map (| _ | result) } } # [cfg (feature = "use_std")] mod put_back_n_impl { use crate :: size_hint ; # [doc = " An iterator adaptor that allows putting multiple"] # [doc = " items in front of the iterator."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] # [derive (Debug , Clone)] pub struct PutBackN < I : Iterator > { top : Vec < I :: Item > , iter : I , } # [doc = " Create an iterator where you can put back multiple values to the front"] # [doc = " of the iteration."] # [doc = ""] # [doc = " Iterator element type is `I::Item`."] pub fn put_back_n < I > (iterable : I) -> PutBackN < I :: IntoIter > where I : IntoIterator { PutBackN { top : Vec :: new () , iter : iterable . into_iter () , } } impl < I : Iterator > PutBackN < I > { # [doc = " Puts x in front of the iterator."] # [doc = " The values are yielded in order of the most recently put back"] # [doc = " values first."] # [doc = ""] # [doc = " ```rust"] # [doc = " use itertools::put_back_n;"] # [doc = ""] # [doc = " let mut it = put_back_n(1..5);"] # [doc = " it.next();"] # [doc = " it.put_back(1);"] # [doc = " it.put_back(0);"] # [doc = ""] # [doc = " assert!(itertools::equal(it, 0..5));"] # [doc = " ```"] # [inline] pub fn put_back (& mut self , x : I :: Item) { self . top . push (x) ; } } impl < I : Iterator > Iterator for PutBackN < I > { type Item = I :: Item ; # [inline] fn next (& mut self) -> Option < I :: Item > { if self . top . is_empty () { self . iter . next () } else { self . top . pop () } } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: add_scalar (self . iter . size_hint () , self . top . len ()) } } } # [cfg (feature = "use_std")] mod rciter_impl { use std :: iter :: IntoIterator ; use std :: rc :: Rc ; use std :: cell :: RefCell ; # [doc = " A wrapper for `Rc<RefCell<I>>`, that implements the `Iterator` trait."] # [derive (Debug)] pub struct RcIter < I > { # [doc = " The boxed iterator."] pub rciter : Rc < RefCell < I > > , } # [doc = " Return an iterator inside a `Rc<RefCell<_>>` wrapper."] # [doc = ""] # [doc = " The returned `RcIter` can be cloned, and each clone will refer back to the"] # [doc = " same original iterator."] # [doc = ""] # [doc = " `RcIter` allows doing interesting things like using `.zip()` on an iterator with"] # [doc = " itself, at the cost of runtime borrow checking which may have a performance"] # [doc = " penalty."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::rciter;"] # [doc = " use itertools::zip;"] # [doc = ""] # [doc = " // In this example a range iterator is created and we iterate it using"] # [doc = " // three separate handles (two of them given to zip)."] # [doc = " // We also use the IntoIterator implementation for `&RcIter`."] # [doc = ""] # [doc = " let mut iter = rciter(0..9);"] # [doc = " let mut z = zip(&iter, &iter);"] # [doc = ""] # [doc = " assert_eq!(z.next(), Some((0, 1)));"] # [doc = " assert_eq!(z.next(), Some((2, 3)));"] # [doc = " assert_eq!(z.next(), Some((4, 5)));"] # [doc = " assert_eq!(iter.next(), Some(6));"] # [doc = " assert_eq!(z.next(), Some((7, 8)));"] # [doc = " assert_eq!(z.next(), None);"] # [doc = " ```"] # [doc = ""] # [doc = " **Panics** in iterator methods if a borrow error is encountered in the"] # [doc = " iterator methods. It can only happen if the `RcIter` is reentered in"] # [doc = " `.next()`, i.e. if it somehow participates in an iterator knot"] # [doc = " where it is an adaptor of itself."] pub fn rciter < I > (iterable : I) -> RcIter < I :: IntoIter > where I : IntoIterator { RcIter { rciter : Rc :: new (RefCell :: new (iterable . into_iter ())) } } impl < I > Clone for RcIter < I > { # [inline] clone_fields ! (rciter) ; } impl < A , I > Iterator for RcIter < I > where I : Iterator < Item = A > { type Item = A ; # [inline] fn next (& mut self) -> Option < A > { self . rciter . borrow_mut () . next () } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { let (_ , hi) = self . rciter . borrow () . size_hint () ; (0 , hi) } } impl < I > DoubleEndedIterator for RcIter < I > where I : DoubleEndedIterator { # [inline] fn next_back (& mut self) -> Option < I :: Item > { self . rciter . borrow_mut () . next_back () } } # [doc = " Return an iterator from `&RcIter<I>` (by simply cloning it)."] impl < 'a , I > IntoIterator for & 'a RcIter < I > where I : Iterator { type Item = I :: Item ; type IntoIter = RcIter < I > ; fn into_iter (self) -> RcIter < I > { self . clone () } } } mod repeatn { # [doc = " An iterator that produces *n* repetitions of an element."] # [doc = ""] # [doc = " See [`repeat_n()`](../fn.repeat_n.html) for more information."] # [must_use = "iterators are lazy and do nothing unless consumed"] # [derive (Clone , Debug)] pub struct RepeatN < A > { elt : Option < A > , n : usize , } # [doc = " Create an iterator that produces `n` repetitions of `element`."] pub fn repeat_n < A > (element : A , n : usize) -> RepeatN < A > where A : Clone , { if n == 0 { RepeatN { elt : None , n , } } else { RepeatN { elt : Some (element) , n , } } } impl < A > Iterator for RepeatN < A > where A : Clone { type Item = A ; fn next (& mut self) -> Option < Self :: Item > { if self . n > 1 { self . n -= 1 ; self . elt . as_ref () . cloned () } else { self . n = 0 ; self . elt . take () } } fn size_hint (& self) -> (usize , Option < usize >) { (self . n , Some (self . n)) } } impl < A > DoubleEndedIterator for RepeatN < A > where A : Clone { # [inline] fn next_back (& mut self) -> Option < Self :: Item > { self . next () } } impl < A > ExactSizeIterator for RepeatN < A > where A : Clone { } } mod size_hint { use std :: usize ; use std :: cmp ; # [doc = " **SizeHint** is the return type of **Iterator::size_hint()**."] pub type SizeHint = (usize , Option < usize >) ; # [doc = " Add **SizeHint** correctly."] # [inline] pub fn add (a : SizeHint , b : SizeHint) -> SizeHint { let min = a . 0 . checked_add (b . 0) . unwrap_or (usize :: MAX) ; let max = match (a . 1 , b . 1) { (Some (x) , Some (y)) => x . checked_add (y) , _ => None , } ; (min , max) } # [doc = " Add **x** correctly to a **SizeHint**."] # [inline] pub fn add_scalar (sh : SizeHint , x : usize) -> SizeHint { let (mut low , mut hi) = sh ; low = low . saturating_add (x) ; hi = hi . and_then (| elt | elt . checked_add (x)) ; (low , hi) } # [doc = " Sbb **x** correctly to a **SizeHint**."] # [inline] # [allow (dead_code)] pub fn sub_scalar (sh : SizeHint , x : usize) -> SizeHint { let (mut low , mut hi) = sh ; low = low . saturating_sub (x) ; hi = hi . map (| elt | elt . saturating_sub (x)) ; (low , hi) } # [doc = " Multiply **SizeHint** correctly"] # [doc = ""] # [doc = " ```ignore"] # [doc = " use std::usize;"] # [doc = " use itertools::size_hint;"] # [doc = ""] # [doc = " assert_eq!(size_hint::mul((3, Some(4)), (3, Some(4))),"] # [doc = "            (9, Some(16)));"] # [doc = ""] # [doc = " assert_eq!(size_hint::mul((3, Some(4)), (usize::MAX, None)),"] # [doc = "            (usize::MAX, None));"] # [doc = ""] # [doc = " assert_eq!(size_hint::mul((3, None), (0, Some(0))),"] # [doc = "            (0, Some(0)));"] # [doc = " ```"] # [inline] pub fn mul (a : SizeHint , b : SizeHint) -> SizeHint { let low = a . 0 . checked_mul (b . 0) . unwrap_or (usize :: MAX) ; let hi = match (a . 1 , b . 1) { (Some (x) , Some (y)) => x . checked_mul (y) , (Some (0) , None) | (None , Some (0)) => Some (0) , _ => None , } ; (low , hi) } # [doc = " Multiply **x** correctly with a **SizeHint**."] # [inline] pub fn mul_scalar (sh : SizeHint , x : usize) -> SizeHint { let (mut low , mut hi) = sh ; low = low . saturating_mul (x) ; hi = hi . and_then (| elt | elt . checked_mul (x)) ; (low , hi) } # [doc = " Return the maximum"] # [inline] pub fn max (a : SizeHint , b : SizeHint) -> SizeHint { let (a_lower , a_upper) = a ; let (b_lower , b_upper) = b ; let lower = cmp :: max (a_lower , b_lower) ; let upper = match (a_upper , b_upper) { (Some (x) , Some (y)) => Some (cmp :: max (x , y)) , _ => None , } ; (lower , upper) } # [doc = " Return the minimum"] # [inline] pub fn min (a : SizeHint , b : SizeHint) -> SizeHint { let (a_lower , a_upper) = a ; let (b_lower , b_upper) = b ; let lower = cmp :: min (a_lower , b_lower) ; let upper = match (a_upper , b_upper) { (Some (u1) , Some (u2)) => Some (cmp :: min (u1 , u2)) , _ => a_upper . or (b_upper) , } ; (lower , upper) } } mod sources { use std :: fmt ; use std :: mem ; # [doc = " See [`repeat_call`](../fn.repeat_call.html) for more information."] # [derive (Clone)] # [deprecated (note = "Use std repeat_with() instead" , since = "0.8")] pub struct RepeatCall < F > { f : F , } impl < F > fmt :: Debug for RepeatCall < F > { debug_fmt_fields ! (RepeatCall ,) ; } # [doc = " An iterator source that produces elements indefinitely by calling"] # [doc = " a given closure."] # [doc = ""] # [doc = " Iterator element type is the return type of the closure."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::repeat_call;"] # [doc = " use itertools::Itertools;"] # [doc = " use std::collections::BinaryHeap;"] # [doc = ""] # [doc = " let mut heap = BinaryHeap::from(vec![2, 5, 3, 7, 8]);"] # [doc = ""] # [doc = " // extract each element in sorted order"] # [doc = " for element in repeat_call(|| heap.pop()).while_some() {"] # [doc = "     print!(\"{}\", element);"] # [doc = " }"] # [doc = ""] # [doc = " itertools::assert_equal("] # [doc = "     repeat_call(|| 1).take(5),"] # [doc = "     vec![1, 1, 1, 1, 1]"] # [doc = " );"] # [doc = " ```"] # [deprecated (note = "Use std repeat_with() instead" , since = "0.8")] pub fn repeat_call < F , A > (function : F) -> RepeatCall < F > where F : FnMut () -> A { RepeatCall { f : function } } impl < A , F > Iterator for RepeatCall < F > where F : FnMut () -> A { type Item = A ; # [inline] fn next (& mut self) -> Option < A > { Some ((self . f) ()) } fn size_hint (& self) -> (usize , Option < usize >) { (usize :: max_value () , None) } } # [doc = " Creates a new unfold source with the specified closure as the \"iterator"] # [doc = " function\" and an initial state to eventually pass to the closure"] # [doc = ""] # [doc = " `unfold` is a general iterator builder: it has a mutable state value,"] # [doc = " and a closure with access to the state that produces the next value."] # [doc = ""] # [doc = " This more or less equivalent to a regular struct with an `Iterator`"] # [doc = " implementation, and is useful for one-off iterators."] # [doc = ""] # [doc = " ```"] # [doc = " // an iterator that yields sequential Fibonacci numbers,"] # [doc = " // and stops at the maximum representable value."] # [doc = ""] # [doc = " use itertools::unfold;"] # [doc = ""] # [doc = " let (mut x1, mut x2) = (1u32, 1u32);"] # [doc = " let mut fibonacci = unfold((), move |_| {"] # [doc = "     // Attempt to get the next Fibonacci number"] # [doc = "     let next = x1.saturating_add(x2);"] # [doc = ""] # [doc = "     // Shift left: ret <- x1 <- x2 <- next"] # [doc = "     let ret = x1;"] # [doc = "     x1 = x2;"] # [doc = "     x2 = next;"] # [doc = ""] # [doc = "     // If addition has saturated at the maximum, we are finished"] # [doc = "     if ret == x1 && ret > 1 {"] # [doc = "         return None;"] # [doc = "     }"] # [doc = ""] # [doc = "     Some(ret)"] # [doc = " });"] # [doc = ""] # [doc = " itertools::assert_equal(fibonacci.by_ref().take(8),"] # [doc = "                         vec![1, 1, 2, 3, 5, 8, 13, 21]);"] # [doc = " assert_eq!(fibonacci.last(), Some(2_971_215_073))"] # [doc = " ```"] pub fn unfold < A , St , F > (initial_state : St , f : F) -> Unfold < St , F > where F : FnMut (& mut St) -> Option < A > { Unfold { f , state : initial_state , } } impl < St , F > fmt :: Debug for Unfold < St , F > where St : fmt :: Debug , { debug_fmt_fields ! (Unfold , state) ; } # [doc = " See [`unfold`](../fn.unfold.html) for more information."] # [derive (Clone)] # [must_use = "iterators are lazy and do nothing unless consumed"] pub struct Unfold < St , F > { f : F , # [doc = " Internal state that will be passed to the closure on the next iteration"] pub state : St , } impl < A , St , F > Iterator for Unfold < St , F > where F : FnMut (& mut St) -> Option < A > { type Item = A ; # [inline] fn next (& mut self) -> Option < A > { (self . f) (& mut self . state) } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { (0 , None) } } # [doc = " An iterator that infinitely applies function to value and yields results."] # [doc = ""] # [doc = " This `struct` is created by the [`iterate()`] function. See its documentation for more."] # [doc = ""] # [doc = " [`iterate()`]: ../fn.iterate.html"] # [derive (Clone)] # [must_use = "iterators are lazy and do nothing unless consumed"] pub struct Iterate < St , F > { state : St , f : F , } impl < St , F > fmt :: Debug for Iterate < St , F > where St : fmt :: Debug , { debug_fmt_fields ! (Iterate , state) ; } impl < St , F > Iterator for Iterate < St , F > where F : FnMut (& St) -> St { type Item = St ; # [inline] fn next (& mut self) -> Option < Self :: Item > { let next_state = (self . f) (& self . state) ; Some (mem :: replace (& mut self . state , next_state)) } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { (usize :: max_value () , None) } } # [doc = " Creates a new iterator that infinitely applies function to value and yields results."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::iterate;"] # [doc = ""] # [doc = " itertools::assert_equal(iterate(1, |&i| i * 3).take(5), vec![1, 3, 9, 27, 81]);"] # [doc = " ```"] pub fn iterate < St , F > (initial_value : St , f : F) -> Iterate < St , F > where F : FnMut (& St) -> St { Iterate { state : initial_value , f , } } } # [cfg (feature = "use_std")] mod tee { use super :: size_hint ; use std :: cell :: RefCell ; use std :: collections :: VecDeque ; use std :: rc :: Rc ; # [doc = " Common buffer object for the two tee halves"] # [derive (Debug)] struct TeeBuffer < A , I > { backlog : VecDeque < A > , iter : I , # [doc = " The owner field indicates which id should read from the backlog"] owner : bool , } # [doc = " One half of an iterator pair where both return the same elements."] # [doc = ""] # [doc = " See [`.tee()`](../trait.Itertools.html#method.tee) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] # [derive (Debug)] pub struct Tee < I > where I : Iterator { rcbuffer : Rc < RefCell < TeeBuffer < I :: Item , I > > > , id : bool , } pub fn new < I > (iter : I) -> (Tee < I > , Tee < I >) where I : Iterator { let buffer = TeeBuffer { backlog : VecDeque :: new () , iter , owner : false } ; let t1 = Tee { rcbuffer : Rc :: new (RefCell :: new (buffer)) , id : true } ; let t2 = Tee { rcbuffer : t1 . rcbuffer . clone () , id : false } ; (t1 , t2) } impl < I > Iterator for Tee < I > where I : Iterator , I :: Item : Clone { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { let mut buffer = self . rcbuffer . borrow_mut () ; if buffer . owner == self . id { match buffer . backlog . pop_front () { None => { } some_elt => return some_elt , } } match buffer . iter . next () { None => None , Some (elt) => { buffer . backlog . push_back (elt . clone ()) ; buffer . owner = ! self . id ; Some (elt) } } } fn size_hint (& self) -> (usize , Option < usize >) { let buffer = self . rcbuffer . borrow () ; let sh = buffer . iter . size_hint () ; if buffer . owner == self . id { let log_len = buffer . backlog . len () ; size_hint :: add_scalar (sh , log_len) } else { sh } } } impl < I > ExactSizeIterator for Tee < I > where I : ExactSizeIterator , I :: Item : Clone { } } mod tuple_impl { use std :: iter :: Fuse ; # [doc = " Implemented for homogeneous tuples of size up to 4."] pub trait HomogeneousTuple : TupleCollect { } impl < T : TupleCollect > HomogeneousTuple for T { } # [doc = " An iterator over a incomplete tuple."] # [doc = ""] # [doc = " See [`.tuples()`](../trait.Itertools.html#method.tuples) and"] # [doc = " [`Tuples::into_buffer()`](struct.Tuples.html#method.into_buffer)."] # [derive (Clone , Debug)] pub struct TupleBuffer < T > where T : HomogeneousTuple { cur : usize , buf : T :: Buffer , } impl < T > TupleBuffer < T > where T : HomogeneousTuple { fn new (buf : T :: Buffer) -> Self { TupleBuffer { cur : 0 , buf , } } } impl < T > Iterator for TupleBuffer < T > where T : HomogeneousTuple { type Item = T :: Item ; fn next (& mut self) -> Option < Self :: Item > { let s = self . buf . as_mut () ; if let Some (ref mut item) = s . get_mut (self . cur) { self . cur += 1 ; item . take () } else { None } } fn size_hint (& self) -> (usize , Option < usize >) { let buffer = & self . buf . as_ref () [self . cur ..] ; let len = if buffer . len () == 0 { 0 } else { buffer . iter () . position (| x | x . is_none ()) . unwrap_or (buffer . len ()) } ; (len , Some (len)) } } impl < T > ExactSizeIterator for TupleBuffer < T > where T : HomogeneousTuple { } # [doc = " An iterator that groups the items in tuples of a specific size."] # [doc = ""] # [doc = " See [`.tuples()`](../trait.Itertools.html#method.tuples) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Tuples < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple { iter : Fuse < I > , buf : T :: Buffer , } # [doc = " Create a new tuples iterator."] pub fn tuples < I , T > (iter : I) -> Tuples < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple { Tuples { iter : iter . fuse () , buf : Default :: default () , } } impl < I , T > Iterator for Tuples < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple { type Item = T ; fn next (& mut self) -> Option < T > { T :: collect_from_iter (& mut self . iter , & mut self . buf) } } impl < I , T > Tuples < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple { # [doc = " Return a buffer with the produced items that was not enough to be grouped in a tuple."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut iter = (0..5).tuples();"] # [doc = " assert_eq!(Some((0, 1, 2)), iter.next());"] # [doc = " assert_eq!(None, iter.next());"] # [doc = " itertools::assert_equal(vec![3, 4], iter.into_buffer());"] # [doc = " ```"] pub fn into_buffer (self) -> TupleBuffer < T > { TupleBuffer :: new (self . buf) } } # [doc = " An iterator over all contiguous windows that produces tuples of a specific size."] # [doc = ""] # [doc = " See [`.tuple_windows()`](../trait.Itertools.html#method.tuple_windows) for more"] # [doc = " information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] # [derive (Clone , Debug)] pub struct TupleWindows < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple { iter : I , last : Option < T > , } # [doc = " Create a new tuple windows iterator."] pub fn tuple_windows < I , T > (mut iter : I) -> TupleWindows < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple , T :: Item : Clone { use std :: iter :: once ; let mut last = None ; if T :: num_items () != 1 { if let Some (item) = iter . next () { let iter = once (item . clone ()) . chain (once (item)) . chain (& mut iter) ; last = T :: collect_from_iter_no_buf (iter) ; } } TupleWindows { last , iter , } } impl < I , T > Iterator for TupleWindows < I , T > where I : Iterator < Item = T :: Item > , T : HomogeneousTuple + Clone , T :: Item : Clone { type Item = T ; fn next (& mut self) -> Option < T > { if T :: num_items () == 1 { return T :: collect_from_iter_no_buf (& mut self . iter) } if let Some (ref mut last) = self . last { if let Some (new) = self . iter . next () { last . left_shift_push (new) ; return Some (last . clone ()) ; } } None } } pub trait TupleCollect : Sized { type Item ; type Buffer : Default + AsRef < [Option < Self :: Item >] > + AsMut < [Option < Self :: Item >] > ; fn collect_from_iter < I > (iter : I , buf : & mut Self :: Buffer) -> Option < Self > where I : IntoIterator < Item = Self :: Item > ; fn collect_from_iter_no_buf < I > (iter : I) -> Option < Self > where I : IntoIterator < Item = Self :: Item > ; fn num_items () -> usize ; fn left_shift_push (& mut self , item : Self :: Item) ; } macro_rules ! impl_tuple_collect { () => () ; ($ N : expr ; $ A : ident ; $ ($ X : ident) ,* ; $ ($ Y : ident) ,* ; $ ($ Y_rev : ident) ,*) => (impl <$ A > TupleCollect for ($ ($ X) ,*,) { type Item = $ A ; type Buffer = [Option <$ A >; $ N - 1] ; # [allow (unused_assignments , unused_mut)] fn collect_from_iter < I > (iter : I , buf : & mut Self :: Buffer) -> Option < Self > where I : IntoIterator < Item = $ A > { let mut iter = iter . into_iter () ; $ (let mut $ Y = None ;) * loop { $ ($ Y = iter . next () ; if $ Y . is_none () { break }) * return Some (($ ($ Y . unwrap ()) ,*,)) } let mut i = 0 ; let mut s = buf . as_mut () ; $ (if i < s . len () { s [i] = $ Y ; i += 1 ; }) * return None ; } # [allow (unused_assignments)] fn collect_from_iter_no_buf < I > (iter : I) -> Option < Self > where I : IntoIterator < Item = $ A > { let mut iter = iter . into_iter () ; loop { $ (let $ Y = if let Some ($ Y) = iter . next () { $ Y } else { break ; } ;) * return Some (($ ($ Y) ,*,)) } return None ; } fn num_items () -> usize { $ N } fn left_shift_push (& mut self , item : $ A) { use std :: mem :: replace ; let & mut ($ (ref mut $ Y) ,*,) = self ; let tmp = item ; $ (let tmp = replace ($ Y_rev , tmp) ;) * drop (tmp) ; } }) } impl_tuple_collect ! (1 ; A ; A ; a ; a) ; impl_tuple_collect ! (2 ; A ; A , A ; a , b ; b , a) ; impl_tuple_collect ! (3 ; A ; A , A , A ; a , b , c ; c , b , a) ; impl_tuple_collect ! (4 ; A ; A , A , A , A ; a , b , c , d ; d , c , b , a) ; } # [cfg (feature = "use_std")] mod unique_impl { use std :: collections :: HashMap ; use std :: collections :: hash_map :: { Entry } ; use std :: hash :: Hash ; use std :: fmt ; # [doc = " An iterator adapter to filter out duplicate elements."] # [doc = ""] # [doc = " See [`.unique_by()`](../trait.Itertools.html#method.unique) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct UniqueBy < I : Iterator , V , F > { iter : I , used : HashMap < V , () > , f : F , } impl < I , V , F > fmt :: Debug for UniqueBy < I , V , F > where I : Iterator + fmt :: Debug , V : fmt :: Debug + Hash + Eq , { debug_fmt_fields ! (UniqueBy , iter , used) ; } # [doc = " Create a new `UniqueBy` iterator."] pub fn unique_by < I , V , F > (iter : I , f : F) -> UniqueBy < I , V , F > where V : Eq + Hash , F : FnMut (& I :: Item) -> V , I : Iterator , { UniqueBy { iter , used : HashMap :: new () , f , } } fn count_new_keys < I , K > (mut used : HashMap < K , () > , iterable : I) -> usize where I : IntoIterator < Item = K > , K : Hash + Eq , { let iter = iterable . into_iter () ; let current_used = used . len () ; used . extend (iter . map (| key | (key , ()))) ; used . len () - current_used } impl < I , V , F > Iterator for UniqueBy < I , V , F > where I : Iterator , V : Eq + Hash , F : FnMut (& I :: Item) -> V { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { while let Some (v) = self . iter . next () { let key = (self . f) (& v) ; if self . used . insert (key , ()) . is_none () { return Some (v) ; } } None } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { let (low , hi) = self . iter . size_hint () ; ((low > 0 && self . used . is_empty ()) as usize , hi) } fn count (self) -> usize { let mut key_f = self . f ; count_new_keys (self . used , self . iter . map (move | elt | key_f (& elt))) } } impl < I > Iterator for Unique < I > where I : Iterator , I :: Item : Eq + Hash + Clone { type Item = I :: Item ; fn next (& mut self) -> Option < I :: Item > { while let Some (v) = self . iter . iter . next () { if let Entry :: Vacant (entry) = self . iter . used . entry (v) { let elt = entry . key () . clone () ; entry . insert (()) ; return Some (elt) ; } } None } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { let (low , hi) = self . iter . iter . size_hint () ; ((low > 0 && self . iter . used . is_empty ()) as usize , hi) } fn count (self) -> usize { count_new_keys (self . iter . used , self . iter . iter) } } # [doc = " An iterator adapter to filter out duplicate elements."] # [doc = ""] # [doc = " See [`.unique()`](../trait.Itertools.html#method.unique) for more information."] # [derive (Clone)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Unique < I : Iterator > { iter : UniqueBy < I , I :: Item , () > , } impl < I > fmt :: Debug for Unique < I > where I : Iterator + fmt :: Debug , I :: Item : Hash + Eq + fmt :: Debug , { debug_fmt_fields ! (Unique , iter) ; } pub fn unique < I > (iter : I) -> Unique < I > where I : Iterator , I :: Item : Eq + Hash , { Unique { iter : UniqueBy { iter , used : HashMap :: new () , f : () , } } } } mod with_position { use std :: iter :: { Fuse , Peekable } ; # [doc = " An iterator adaptor that wraps each element in an [`Position`](../enum.Position.html)."] # [doc = ""] # [doc = " Iterator element type is `Position<I::Item>`."] # [doc = ""] # [doc = " See [`.with_position()`](../trait.Itertools.html#method.with_position) for more information."] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct WithPosition < I > where I : Iterator , { handled_first : bool , peekable : Peekable < Fuse < I > > , } impl < I > Clone for WithPosition < I > where I : Clone + Iterator , I :: Item : Clone , { clone_fields ! (handled_first , peekable) ; } # [doc = " Create a new `WithPosition` iterator."] pub fn with_position < I > (iter : I) -> WithPosition < I > where I : Iterator , { WithPosition { handled_first : false , peekable : iter . fuse () . peekable () , } } # [doc = " A value yielded by `WithPosition`."] # [doc = " Indicates the position of this element in the iterator results."] # [doc = ""] # [doc = " See [`.with_position()`](trait.Itertools.html#method.with_position) for more information."] # [derive (Copy , Clone , Debug , PartialEq)] pub enum Position < T > { # [doc = " This is the first element."] First (T) , # [doc = " This is neither the first nor the last element."] Middle (T) , # [doc = " This is the last element."] Last (T) , # [doc = " This is the only element."] Only (T) , } impl < T > Position < T > { # [doc = " Return the inner value."] pub fn into_inner (self) -> T { match self { Position :: First (x) | Position :: Middle (x) | Position :: Last (x) | Position :: Only (x) => x , } } } impl < I : Iterator > Iterator for WithPosition < I > { type Item = Position < I :: Item > ; fn next (& mut self) -> Option < Self :: Item > { match self . peekable . next () { Some (item) => { if ! self . handled_first { self . handled_first = true ; match self . peekable . peek () { Some (_) => Some (Position :: First (item)) , None => Some (Position :: Only (item)) , } } else { match self . peekable . peek () { Some (_) => Some (Position :: Middle (item)) , None => Some (Position :: Last (item)) , } } } None => None , } } fn size_hint (& self) -> (usize , Option < usize >) { self . peekable . size_hint () } } impl < I > ExactSizeIterator for WithPosition < I > where I : ExactSizeIterator , { } } mod zip_eq_impl { use super :: size_hint ; # [doc = " An iterator which iterates two other iterators simultaneously"] # [doc = ""] # [doc = " See [`.zip_eq()`](../trait.Itertools.html#method.zip_eq) for more information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct ZipEq < I , J > { a : I , b : J , } # [doc = " Iterate `i` and `j` in lock step."] # [doc = ""] # [doc = " **Panics** if the iterators are not of the same length."] # [doc = ""] # [doc = " `IntoIterator` enabled version of `i.zip_eq(j)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::zip_eq;"] # [doc = ""] # [doc = " let data = [1, 2, 3, 4, 5];"] # [doc = " for (a, b) in zip_eq(&data[..data.len() - 1], &data[1..]) {"] # [doc = "     /* loop body */"] # [doc = " }"] # [doc = " ```"] pub fn zip_eq < I , J > (i : I , j : J) -> ZipEq < I :: IntoIter , J :: IntoIter > where I : IntoIterator , J : IntoIterator { ZipEq { a : i . into_iter () , b : j . into_iter () , } } impl < I , J > Iterator for ZipEq < I , J > where I : Iterator , J : Iterator { type Item = (I :: Item , J :: Item) ; fn next (& mut self) -> Option < Self :: Item > { match (self . a . next () , self . b . next ()) { (None , None) => None , (Some (a) , Some (b)) => Some ((a , b)) , (None , Some (_)) | (Some (_) , None) => panic ! ("itertools: .zip_eq() reached end of one iterator before the other") } } fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: min (self . a . size_hint () , self . b . size_hint ()) } } impl < I , J > ExactSizeIterator for ZipEq < I , J > where I : ExactSizeIterator , J : ExactSizeIterator { } } mod zip_longest { use std :: cmp :: Ordering :: { Equal , Greater , Less } ; use super :: size_hint ; use std :: iter :: Fuse ; use crate :: either_or_both :: EitherOrBoth ; # [doc = " An iterator which iterates two other iterators simultaneously"] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " See [`.zip_longest()`](../trait.Itertools.html#method.zip_longest) for more information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct ZipLongest < T , U > { a : Fuse < T > , b : Fuse < U > , } # [doc = " Create a new `ZipLongest` iterator."] pub fn zip_longest < T , U > (a : T , b : U) -> ZipLongest < T , U > where T : Iterator , U : Iterator { ZipLongest { a : a . fuse () , b : b . fuse () , } } impl < T , U > Iterator for ZipLongest < T , U > where T : Iterator , U : Iterator { type Item = EitherOrBoth < T :: Item , U :: Item > ; # [inline] fn next (& mut self) -> Option < Self :: Item > { match (self . a . next () , self . b . next ()) { (None , None) => None , (Some (a) , None) => Some (EitherOrBoth :: Left (a)) , (None , Some (b)) => Some (EitherOrBoth :: Right (b)) , (Some (a) , Some (b)) => Some (EitherOrBoth :: Both (a , b)) , } } # [inline] fn size_hint (& self) -> (usize , Option < usize >) { size_hint :: max (self . a . size_hint () , self . b . size_hint ()) } } impl < T , U > DoubleEndedIterator for ZipLongest < T , U > where T : DoubleEndedIterator + ExactSizeIterator , U : DoubleEndedIterator + ExactSizeIterator { # [inline] fn next_back (& mut self) -> Option < Self :: Item > { match self . a . len () . cmp (& self . b . len ()) { Equal => match (self . a . next_back () , self . b . next_back ()) { (None , None) => None , (Some (a) , Some (b)) => Some (EitherOrBoth :: Both (a , b)) , (Some (a) , None) => Some (EitherOrBoth :: Left (a)) , (None , Some (b)) => Some (EitherOrBoth :: Right (b)) , } , Greater => self . a . next_back () . map (EitherOrBoth :: Left) , Less => self . b . next_back () . map (EitherOrBoth :: Right) , } } } impl < T , U > ExactSizeIterator for ZipLongest < T , U > where T : ExactSizeIterator , U : ExactSizeIterator { } } mod ziptuple { use super :: size_hint ; # [doc = " See [`multizip`](../fn.multizip.html) for more information."] # [derive (Clone , Debug)] # [must_use = "iterator adaptors are lazy and do nothing unless consumed"] pub struct Zip < T > { t : T , } # [doc = " An iterator that generalizes *.zip()* and allows running multiple iterators in lockstep."] # [doc = ""] # [doc = " The iterator `Zip<(I, J, ..., M)>` is formed from a tuple of iterators (or values that"] # [doc = " implement `IntoIterator`) and yields elements"] # [doc = " until any of the subiterators yields `None`."] # [doc = ""] # [doc = " The iterator element type is a tuple like like `(A, B, ..., E)` where `A` to `E` are the"] # [doc = " element types of the subiterator."] # [doc = ""] # [doc = " **Note:** The result of this macro is a value of a named type (`Zip<(I, J,"] # [doc = " ..)>` of each component iterator `I, J, ...`) if each component iterator is"] # [doc = " nameable."] # [doc = ""] # [doc = " Prefer [`izip!()`] over `multizip` for the performance benefits of using the"] # [doc = " standard library `.zip()`. Prefer `multizip` if a nameable type is needed."] # [doc = ""] # [doc = " [`izip!()`]: macro.izip.html"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::multizip;"] # [doc = ""] # [doc = " // iterate over three sequences side-by-side"] # [doc = " let mut results = [0, 0, 0, 0];"] # [doc = " let inputs = [3, 7, 9, 6];"] # [doc = ""] # [doc = " for (r, index, input) in multizip((&mut results, 0..10, &inputs)) {"] # [doc = "     *r = index * 10 + input;"] # [doc = " }"] # [doc = ""] # [doc = " assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);"] # [doc = " ```"] pub fn multizip < T , U > (t : U) -> Zip < T > where Zip < T > : From < U > , Zip < T > : Iterator , { Zip :: from (t) } macro_rules ! impl_zip_iter { ($ ($ B : ident) ,*) => (# [allow (non_snake_case)] impl <$ ($ B : IntoIterator) ,*> From < ($ ($ B ,) *) > for Zip < ($ ($ B :: IntoIter ,) *) > { fn from (t : ($ ($ B ,) *)) -> Self { let ($ ($ B ,) *) = t ; Zip { t : ($ ($ B . into_iter () ,) *) } } } # [allow (non_snake_case)] # [allow (unused_assignments)] impl <$ ($ B) ,*> Iterator for Zip < ($ ($ B ,) *) > where $ ($ B : Iterator ,) * { type Item = ($ ($ B :: Item ,) *) ; fn next (& mut self) -> Option < Self :: Item > { let ($ (ref mut $ B ,) *) = self . t ; $ (let $ B = match $ B . next () { None => return None , Some (elt) => elt } ;) * Some (($ ($ B ,) *)) } fn size_hint (& self) -> (usize , Option < usize >) { let sh = (:: std :: usize :: MAX , None) ; let ($ (ref $ B ,) *) = self . t ; $ (let sh = size_hint :: min ($ B . size_hint () , sh) ;) * sh } } # [allow (non_snake_case)] impl <$ ($ B) ,*> ExactSizeIterator for Zip < ($ ($ B ,) *) > where $ ($ B : ExactSizeIterator ,) * { }) ; } impl_zip_iter ! (A) ; impl_zip_iter ! (A , B) ; impl_zip_iter ! (A , B , C) ; impl_zip_iter ! (A , B , C , D) ; impl_zip_iter ! (A , B , C , D , E) ; impl_zip_iter ! (A , B , C , D , E , F) ; impl_zip_iter ! (A , B , C , D , E , F , G) ; impl_zip_iter ! (A , B , C , D , E , F , G , H) ; } # [macro_export] # [doc = " Create an iterator over the cartesian product of iterators."] # [doc = ""] # [doc = " Iterator element type is like `(A, B, ..., E)` if formed"] # [doc = " from iterators `(I, J, ..., M)` with element types `I::Item = A`, `J::Item = B`, etc."] # [doc = ""] # [doc = " ```"] # [doc = " # use itertools::iproduct;"] # [doc = " #"] # [doc = " # fn main() {"] # [doc = " // Iterate over the coordinates of a 4 x 4 x 4 grid"] # [doc = " // from (0, 0, 0), (0, 0, 1), .., (0, 1, 0), (0, 1, 1), .. etc until (3, 3, 3)"] # [doc = " for (i, j, k) in iproduct!(0..4, 0..4, 0..4) {"] # [doc = "    // .."] # [doc = " }"] # [doc = " # }"] # [doc = " ```"] macro_rules ! iproduct { (@ flatten $ I : expr ,) => ($ I) ; (@ flatten $ I : expr , $ J : expr , $ ($ K : expr ,) *) => (iproduct ! (@ flatten $ crate :: cons_tuples (iproduct ! ($ I , $ J)) , $ ($ K ,) *)) ; ($ I : expr) => ($ crate :: __std_iter :: IntoIterator :: into_iter ($ I)) ; ($ I : expr , $ J : expr) => ($ crate :: Itertools :: cartesian_product (iproduct ! ($ I) , iproduct ! ($ J))) ; ($ I : expr , $ J : expr , $ ($ K : expr) ,+) => (iproduct ! (@ flatten iproduct ! ($ I , $ J) , $ ($ K ,) +)) ; } # [macro_export] # [doc = " Create an iterator running multiple iterators in lockstep."] # [doc = ""] # [doc = " The `izip!` iterator yields elements until any subiterator"] # [doc = " returns `None`."] # [doc = ""] # [doc = " This is a version of the standard ``.zip()`` that's supporting more than"] # [doc = " two iterators. The iterator element type is a tuple with one element"] # [doc = " from each of the input iterators. Just like ``.zip()``, the iteration stops"] # [doc = " when the shortest of the inputs reaches its end."] # [doc = ""] # [doc = " **Note:** The result of this macro is in the general case an iterator"] # [doc = " composed of repeated `.zip()` and a `.map()`; it has an anonymous type."] # [doc = " The special cases of one and two arguments produce the equivalent of"] # [doc = " `$a.into_iter()` and `$a.into_iter().zip($b)` respectively."] # [doc = ""] # [doc = " Prefer this macro `izip!()` over [`multizip`] for the performance benefits"] # [doc = " of using the standard library `.zip()`."] # [doc = ""] # [doc = " [`multizip`]: fn.multizip.html"] # [doc = ""] # [doc = " ```"] # [doc = " # use itertools::izip;"] # [doc = " #"] # [doc = " # fn main() {"] # [doc = ""] # [doc = " // iterate over three sequences side-by-side"] # [doc = " let mut results = [0, 0, 0, 0];"] # [doc = " let inputs = [3, 7, 9, 6];"] # [doc = ""] # [doc = " for (r, index, input) in izip!(&mut results, 0..10, &inputs) {"] # [doc = "     *r = index * 10 + input;"] # [doc = " }"] # [doc = ""] # [doc = " assert_eq!(results, [0 + 3, 10 + 7, 29, 36]);"] # [doc = " # }"] # [doc = " ```"] macro_rules ! izip { (@ closure $ p : pat => $ tup : expr) => { |$ p | $ tup } ; (@ closure $ p : pat => ($ ($ tup : tt) *) , $ _iter : expr $ (, $ tail : expr) *) => { izip ! (@ closure ($ p , b) => ($ ($ tup) *, b) $ (, $ tail) *) } ; ($ first : expr $ (,) *) => { $ crate :: __std_iter :: IntoIterator :: into_iter ($ first) } ; ($ first : expr , $ second : expr $ (,) *) => { izip ! ($ first) . zip ($ second) } ; ($ first : expr $ (, $ rest : expr) * $ (,) *) => { izip ! ($ first) $ (. zip ($ rest)) * . map (izip ! (@ closure a => (a) $ (, $ rest) *)) } ; } # [doc = " An [`Iterator`] blanket implementation that provides extra adaptors and"] # [doc = " methods."] # [doc = ""] # [doc = " This trait defines a number of methods. They are divided into two groups:"] # [doc = ""] # [doc = " * *Adaptors* take an iterator and parameter as input, and return"] # [doc = " a new iterator value. These are listed first in the trait. An example"] # [doc = " of an adaptor is [`.interleave()`](#method.interleave)"] # [doc = ""] # [doc = " * *Regular methods* are those that don't return iterators and instead"] # [doc = " return a regular value of some other kind."] # [doc = " [`.next_tuple()`](#method.next_tuple) is an example and the first regular"] # [doc = " method in the list."] # [doc = ""] # [doc = " [`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"] pub trait Itertools : Iterator { # [doc = " Alternate elements from two iterators until both have run out."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (1..7).interleave(vec![-1, -2]);"] # [doc = " itertools::assert_equal(it, vec![1, -1, 2, -2, 3, 4, 5, 6]);"] # [doc = " ```"] fn interleave < J > (self , other : J) -> Interleave < Self , J :: IntoIter > where J : IntoIterator < Item = Self :: Item > , Self : Sized { interleave (self , other) } # [doc = " Alternate elements from two iterators until at least one of them has run"] # [doc = " out."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (1..7).interleave_shortest(vec![-1, -2]);"] # [doc = " itertools::assert_equal(it, vec![1, -1, 2, -2, 3]);"] # [doc = " ```"] fn interleave_shortest < J > (self , other : J) -> InterleaveShortest < Self , J :: IntoIter > where J : IntoIterator < Item = Self :: Item > , Self : Sized { adaptors :: interleave_shortest (self , other . into_iter ()) } # [doc = " An iterator adaptor to insert a particular value"] # [doc = " between each element of the adapted iterator."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " itertools::assert_equal((0..3).intersperse(8), vec![0, 8, 1, 8, 2]);"] # [doc = " ```"] fn intersperse (self , element : Self :: Item) -> Intersperse < Self > where Self : Sized , Self :: Item : Clone { intersperse :: intersperse (self , element) } # [doc = " Create an iterator which iterates over both this and the specified"] # [doc = " iterator simultaneously, yielding pairs of two optional elements."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " As long as neither input iterator is exhausted yet, it yields two values"] # [doc = " via `EitherOrBoth::Both`."] # [doc = ""] # [doc = " When the parameter iterator is exhausted, it only yields a value from the"] # [doc = " `self` iterator via `EitherOrBoth::Left`."] # [doc = ""] # [doc = " When the `self` iterator is exhausted, it only yields a value from the"] # [doc = " parameter iterator via `EitherOrBoth::Right`."] # [doc = ""] # [doc = " When both iterators return `None`, all further invocations of `.next()`"] # [doc = " will return `None`."] # [doc = ""] # [doc = " Iterator element type is"] # [doc = " [`EitherOrBoth<Self::Item, J::Item>`](enum.EitherOrBoth.html)."] # [doc = ""] # [doc = " ```rust"] # [doc = " use itertools::EitherOrBoth::{Both, Right};"] # [doc = " use itertools::Itertools;"] # [doc = " let it = (0..1).zip_longest(1..3);"] # [doc = " itertools::assert_equal(it, vec![Both(0, 1), Right(2)]);"] # [doc = " ```"] # [inline] fn zip_longest < J > (self , other : J) -> ZipLongest < Self , J :: IntoIter > where J : IntoIterator , Self : Sized { zip_longest :: zip_longest (self , other . into_iter ()) } # [doc = " Create an iterator which iterates over both this and the specified"] # [doc = " iterator simultaneously, yielding pairs of elements."] # [doc = ""] # [doc = " **Panics** if the iterators reach an end and they are not of equal"] # [doc = " lengths."] # [inline] fn zip_eq < J > (self , other : J) -> ZipEq < Self , J :: IntoIter > where J : IntoIterator , Self : Sized { zip_eq (self , other) } # [doc = " A meta iterator adaptor. Its closure receives a reference to the"] # [doc = " iterator and may pick off as many elements as it likes, to produce the"] # [doc = " next iterator element."] # [doc = ""] # [doc = " Iterator element type is `B`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // An adaptor that gathers elements in pairs"] # [doc = " let pit = (0..4).batching(|it| {"] # [doc = "            match it.next() {"] # [doc = "                None => None,"] # [doc = "                Some(x) => match it.next() {"] # [doc = "                    None => None,"] # [doc = "                    Some(y) => Some((x, y)),"] # [doc = "                }"] # [doc = "            }"] # [doc = "        });"] # [doc = ""] # [doc = " itertools::assert_equal(pit, vec![(0, 1), (2, 3)]);"] # [doc = " ```"] # [doc = ""] fn batching < B , F > (self , f : F) -> Batching < Self , F > where F : FnMut (& mut Self) -> Option < B > , Self : Sized { adaptors :: batching (self , f) } # [doc = " Return an *iterable* that can group iterator elements."] # [doc = " Consecutive elements that map to the same key (runs), are assigned"] # [doc = " to the same group."] # [doc = ""] # [doc = " `GroupBy` is the storage for the lazy grouping operation."] # [doc = ""] # [doc = " If the groups are consumed in order, or if each group's iterator is"] # [doc = " dropped without keeping it around, then `GroupBy` uses no"] # [doc = " allocations.  It needs allocations only if several group iterators"] # [doc = " are alive at the same time."] # [doc = ""] # [doc = " This type implements `IntoIterator` (it is **not** an iterator"] # [doc = " itself), because the group iterators need to borrow from this"] # [doc = " value. It should be stored in a local variable or temporary and"] # [doc = " iterated."] # [doc = ""] # [doc = " Iterator element type is `(K, Group)`: the group's key and the"] # [doc = " group iterator."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // group data into runs of larger than zero or not."] # [doc = " let data = vec![1, 3, -2, -2, 1, 0, 1, 2];"] # [doc = " // groups:     |---->|------>|--------->|"] # [doc = ""] # [doc = " // Note: The `&` is significant here, `GroupBy` is iterable"] # [doc = " // only by reference. You can also call `.into_iter()` explicitly."] # [doc = " let mut data_grouped = Vec::new();"] # [doc = " for (key, group) in &data.into_iter().group_by(|elt| *elt >= 0) {"] # [doc = "     data_grouped.push((key, group.collect()));"] # [doc = " }"] # [doc = " assert_eq!(data_grouped, vec![(true, vec![1, 3]), (false, vec![-2, -2]), (true, vec![1, 0, 1, 2])]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn group_by < K , F > (self , key : F) -> GroupBy < K , Self , F > where Self : Sized , F : FnMut (& Self :: Item) -> K , K : PartialEq , { groupbylazy :: new (self , key) } # [doc = " Return an *iterable* that can chunk the iterator."] # [doc = ""] # [doc = " Yield subiterators (chunks) that each yield a fixed number elements,"] # [doc = " determined by `size`. The last chunk will be shorter if there aren't"] # [doc = " enough elements."] # [doc = ""] # [doc = " `IntoChunks` is based on `GroupBy`: it is iterable (implements"] # [doc = " `IntoIterator`, **not** `Iterator`), and it only buffers if several"] # [doc = " chunk iterators are alive at the same time."] # [doc = ""] # [doc = " Iterator element type is `Chunk`, each chunk's iterator."] # [doc = ""] # [doc = " **Panics** if `size` is 0."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![1, 1, 2, -2, 6, 0, 3, 1];"] # [doc = " //chunk size=3 |------->|-------->|--->|"] # [doc = ""] # [doc = " // Note: The `&` is significant here, `IntoChunks` is iterable"] # [doc = " // only by reference. You can also call `.into_iter()` explicitly."] # [doc = " for chunk in &data.into_iter().chunks(3) {"] # [doc = "     // Check that the sum of each chunk is 4."] # [doc = "     assert_eq!(4, chunk.sum());"] # [doc = " }"] # [doc = " ```"] # [cfg (feature = "use_std")] fn chunks (self , size : usize) -> IntoChunks < Self > where Self : Sized , { assert ! (size != 0) ; groupbylazy :: new_chunks (self , size) } # [doc = " Return an iterator over all contiguous windows producing tuples of"] # [doc = " a specific size (up to 4)."] # [doc = ""] # [doc = " `tuple_windows` clones the iterator elements so that they can be"] # [doc = " part of successive windows, this makes it most suited for iterators"] # [doc = " of references and other values that are cheap to copy."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " let mut v = Vec::new();"] # [doc = " for (a, b) in (1..5).tuple_windows() {"] # [doc = "     v.push((a, b));"] # [doc = " }"] # [doc = " assert_eq!(v, vec![(1, 2), (2, 3), (3, 4)]);"] # [doc = ""] # [doc = " let mut it = (1..5).tuple_windows();"] # [doc = " assert_eq!(Some((1, 2, 3)), it.next());"] # [doc = " assert_eq!(Some((2, 3, 4)), it.next());"] # [doc = " assert_eq!(None, it.next());"] # [doc = ""] # [doc = " // this requires a type hint"] # [doc = " let it = (1..5).tuple_windows::<(_, _, _)>();"] # [doc = " itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);"] # [doc = ""] # [doc = " // you can also specify the complete type"] # [doc = " use itertools::TupleWindows;"] # [doc = " use std::ops::Range;"] # [doc = ""] # [doc = " let it: TupleWindows<Range<u32>, (u32, u32, u32)> = (1..5).tuple_windows();"] # [doc = " itertools::assert_equal(it, vec![(1, 2, 3), (2, 3, 4)]);"] # [doc = " ```"] fn tuple_windows < T > (self) -> TupleWindows < Self , T > where Self : Sized + Iterator < Item = T :: Item > , T : traits :: HomogeneousTuple , T :: Item : Clone { tuple_impl :: tuple_windows (self) } # [doc = " Return an iterator that groups the items in tuples of a specific size"] # [doc = " (up to 4)."] # [doc = ""] # [doc = " See also the method [`.next_tuple()`](#method.next_tuple)."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " let mut v = Vec::new();"] # [doc = " for (a, b) in (1..5).tuples() {"] # [doc = "     v.push((a, b));"] # [doc = " }"] # [doc = " assert_eq!(v, vec![(1, 2), (3, 4)]);"] # [doc = ""] # [doc = " let mut it = (1..7).tuples();"] # [doc = " assert_eq!(Some((1, 2, 3)), it.next());"] # [doc = " assert_eq!(Some((4, 5, 6)), it.next());"] # [doc = " assert_eq!(None, it.next());"] # [doc = ""] # [doc = " // this requires a type hint"] # [doc = " let it = (1..7).tuples::<(_, _, _)>();"] # [doc = " itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);"] # [doc = ""] # [doc = " // you can also specify the complete type"] # [doc = " use itertools::Tuples;"] # [doc = " use std::ops::Range;"] # [doc = ""] # [doc = " let it: Tuples<Range<u32>, (u32, u32, u32)> = (1..7).tuples();"] # [doc = " itertools::assert_equal(it, vec![(1, 2, 3), (4, 5, 6)]);"] # [doc = " ```"] # [doc = ""] # [doc = " See also [`Tuples::into_buffer`](structs/struct.Tuples.html#method.into_buffer)."] fn tuples < T > (self) -> Tuples < Self , T > where Self : Sized + Iterator < Item = T :: Item > , T : traits :: HomogeneousTuple { tuple_impl :: tuples (self) } # [doc = " Split into an iterator pair that both yield all elements from"] # [doc = " the original iterator."] # [doc = ""] # [doc = " **Note:** If the iterator is clonable, prefer using that instead"] # [doc = " of using this method. It is likely to be more efficient."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " let xs = vec![0, 1, 2, 3];"] # [doc = ""] # [doc = " let (mut t1, t2) = xs.into_iter().tee();"] # [doc = " itertools::assert_equal(t1.next(), Some(0));"] # [doc = " itertools::assert_equal(t2, 0..4);"] # [doc = " itertools::assert_equal(t1, 1..4);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn tee (self) -> (Tee < Self > , Tee < Self >) where Self : Sized , Self :: Item : Clone { tee :: new (self) } # [doc = " Return an iterator adaptor that steps `n` elements in the base iterator"] # [doc = " for each iteration."] # [doc = ""] # [doc = " The iterator steps by yielding the next element from the base iterator,"] # [doc = " then skipping forward `n - 1` elements."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " **Panics** if the step is 0."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (0..8).step(3);"] # [doc = " itertools::assert_equal(it, vec![0, 3, 6]);"] # [doc = " ```"] # [deprecated (note = "Use std .step_by() instead" , since = "0.8")] # [allow (deprecated)] fn step (self , n : usize) -> Step < Self > where Self : Sized { adaptors :: step (self , n) } # [doc = " Convert each item of the iterator using the `Into` trait."] # [doc = ""] # [doc = " ```rust"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " (1i32..42i32).map_into::<f64>().collect_vec();"] # [doc = " ```"] fn map_into < R > (self) -> MapInto < Self , R > where Self : Sized , Self :: Item : Into < R > , { adaptors :: map_into (self) } # [doc = " Return an iterator adaptor that applies the provided closure"] # [doc = " to every `Result::Ok` value. `Result::Err` values are"] # [doc = " unchanged."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let input = vec![Ok(41), Err(false), Ok(11)];"] # [doc = " let it = input.into_iter().map_results(|i| i + 1);"] # [doc = " itertools::assert_equal(it, vec![Ok(42), Err(false), Ok(12)]);"] # [doc = " ```"] fn map_results < F , T , U , E > (self , f : F) -> MapResults < Self , F > where Self : Iterator < Item = Result < T , E > > + Sized , F : FnMut (T) -> U , { adaptors :: map_results (self , f) } # [doc = " Return an iterator adaptor that merges the two base iterators in"] # [doc = " ascending order.  If both base iterators are sorted (ascending), the"] # [doc = " result is sorted."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a = (0..11).step(3);"] # [doc = " let b = (0..11).step(5);"] # [doc = " let it = a.merge(b);"] # [doc = " itertools::assert_equal(it, vec![0, 0, 3, 5, 6, 9, 10]);"] # [doc = " ```"] fn merge < J > (self , other : J) -> Merge < Self , J :: IntoIter > where Self : Sized , Self :: Item : PartialOrd , J : IntoIterator < Item = Self :: Item > { merge (self , other) } # [doc = " Return an iterator adaptor that merges the two base iterators in order."] # [doc = " This is much like `.merge()` but allows for a custom ordering."] # [doc = ""] # [doc = " This can be especially useful for sequences of tuples."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a = (0..).zip(\"bc\".chars());"] # [doc = " let b = (0..).zip(\"ad\".chars());"] # [doc = " let it = a.merge_by(b, |x, y| x.1 <= y.1);"] # [doc = " itertools::assert_equal(it, vec![(0, 'a'), (0, 'b'), (1, 'c'), (1, 'd')]);"] # [doc = " ```"] fn merge_by < J , F > (self , other : J , is_first : F) -> MergeBy < Self , J :: IntoIter , F > where Self : Sized , J : IntoIterator < Item = Self :: Item > , F : FnMut (& Self :: Item , & Self :: Item) -> bool { adaptors :: merge_by_new (self , other . into_iter () , is_first) } # [doc = " Create an iterator that merges items from both this and the specified"] # [doc = " iterator in ascending order."] # [doc = ""] # [doc = " It chooses whether to pair elements based on the `Ordering` returned by the"] # [doc = " specified compare function. At any point, inspecting the tip of the"] # [doc = " iterators `I` and `J` as items `i` of type `I::Item` and `j` of type"] # [doc = " `J::Item` respectively, the resulting iterator will:"] # [doc = ""] # [doc = " - Emit `EitherOrBoth::Left(i)` when `i < j`,"] # [doc = "   and remove `i` from its source iterator"] # [doc = " - Emit `EitherOrBoth::Right(j)` when `i > j`,"] # [doc = "   and remove `j` from its source iterator"] # [doc = " - Emit `EitherOrBoth::Both(i, j)` when  `i == j`,"] # [doc = "   and remove both `i` and `j` from their respective source iterators"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " use itertools::EitherOrBoth::{Left, Right, Both};"] # [doc = ""] # [doc = " let ki = (0..10).step(3);"] # [doc = " let ku = (0..10).step(5);"] # [doc = " let ki_ku = ki.merge_join_by(ku, |i, j| i.cmp(j)).map(|either| {"] # [doc = "     match either {"] # [doc = "         Left(_) => \"Ki\","] # [doc = "         Right(_) => \"Ku\","] # [doc = "         Both(_, _) => \"KiKu\""] # [doc = "     }"] # [doc = " });"] # [doc = ""] # [doc = " itertools::assert_equal(ki_ku, vec![\"KiKu\", \"Ki\", \"Ku\", \"Ki\", \"Ki\"]);"] # [doc = " ```"] # [inline] fn merge_join_by < J , F > (self , other : J , cmp_fn : F) -> MergeJoinBy < Self , J :: IntoIter , F > where J : IntoIterator , F : FnMut (& Self :: Item , & J :: Item) -> std :: cmp :: Ordering , Self : Sized { merge_join_by (self , other , cmp_fn) } # [doc = " Return an iterator adaptor that flattens an iterator of iterators by"] # [doc = " merging them in ascending order."] # [doc = ""] # [doc = " If all base iterators are sorted (ascending), the result is sorted."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a = (0..6).step(3);"] # [doc = " let b = (1..6).step(3);"] # [doc = " let c = (2..6).step(3);"] # [doc = " let it = vec![a, b, c].into_iter().kmerge();"] # [doc = " itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn kmerge (self) -> KMerge < < Self :: Item as IntoIterator > :: IntoIter > where Self : Sized , Self :: Item : IntoIterator , < Self :: Item as IntoIterator > :: Item : PartialOrd , { kmerge (self) } # [doc = " Return an iterator adaptor that flattens an iterator of iterators by"] # [doc = " merging them according to the given closure."] # [doc = ""] # [doc = " The closure `first` is called with two elements *a*, *b* and should"] # [doc = " return `true` if *a* is ordered before *b*."] # [doc = ""] # [doc = " If all base iterators are sorted according to `first`, the result is"] # [doc = " sorted."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a = vec![-1f64, 2., 3., -5., 6., -7.];"] # [doc = " let b = vec![0., 2., -4.];"] # [doc = " let mut it = vec![a, b].into_iter().kmerge_by(|a, b| a.abs() < b.abs());"] # [doc = " assert_eq!(it.next(), Some(0.));"] # [doc = " assert_eq!(it.last(), Some(-7.));"] # [doc = " ```"] # [cfg (feature = "use_std")] fn kmerge_by < F > (self , first : F) -> KMergeBy < < Self :: Item as IntoIterator > :: IntoIter , F > where Self : Sized , Self :: Item : IntoIterator , F : FnMut (& < Self :: Item as IntoIterator > :: Item , & < Self :: Item as IntoIterator > :: Item) -> bool { kmerge_by (self , first) } # [doc = " Return an iterator adaptor that iterates over the cartesian product of"] # [doc = " the element sets of two iterators `self` and `J`."] # [doc = ""] # [doc = " Iterator element type is `(Self::Item, J::Item)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (0..2).cartesian_product(\"\".chars());"] # [doc = " itertools::assert_equal(it, vec![(0, ''), (0, ''), (1, ''), (1, '')]);"] # [doc = " ```"] fn cartesian_product < J > (self , other : J) -> Product < Self , J :: IntoIter > where Self : Sized , Self :: Item : Clone , J : IntoIterator , J :: IntoIter : Clone { adaptors :: cartesian_product (self , other . into_iter ()) } # [doc = " Return an iterator adaptor that iterates over the cartesian product of"] # [doc = " all subiterators returned by meta-iterator `self`."] # [doc = ""] # [doc = " All provided iterators must yield the same `Item` type. To generate"] # [doc = " the product of iterators yielding multiple types, use the"] # [doc = " [`iproduct`](macro.iproduct.html) macro instead."] # [doc = ""] # [doc = ""] # [doc = " The iterator element type is `Vec<T>`, where `T` is the iterator element"] # [doc = " of the subiterators."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " let mut multi_prod = (0..3).map(|i| (i * 2)..(i * 2 + 2))"] # [doc = "     .multi_cartesian_product();"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![0, 2, 4]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![0, 2, 5]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![0, 3, 4]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![0, 3, 5]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![1, 2, 4]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![1, 2, 5]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![1, 3, 4]));"] # [doc = " assert_eq!(multi_prod.next(), Some(vec![1, 3, 5]));"] # [doc = " assert_eq!(multi_prod.next(), None);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn multi_cartesian_product (self) -> MultiProduct < < Self :: Item as IntoIterator > :: IntoIter > where Self : Iterator + Sized , Self :: Item : IntoIterator , < Self :: Item as IntoIterator > :: IntoIter : Clone , < Self :: Item as IntoIterator > :: Item : Clone { adaptors :: multi_cartesian_product (self) } # [doc = " Return an iterator adaptor that uses the passed-in closure to"] # [doc = " optionally merge together consecutive elements."] # [doc = ""] # [doc = " The closure `f` is passed two elements, `previous` and `current` and may"] # [doc = " return either (1) `Ok(combined)` to merge the two values or"] # [doc = " (2) `Err((previous', current'))` to indicate they can't be merged."] # [doc = " In (2), the value `previous'` is emitted by the iterator."] # [doc = " Either (1) `combined` or (2) `current'` becomes the previous value"] # [doc = " when coalesce continues with the next pair of elements to merge. The"] # [doc = " value that remains at the end is also emitted by the iterator."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // sum same-sign runs together"] # [doc = " let data = vec![-1., -2., -3., 3., 1., 0., -1.];"] # [doc = " itertools::assert_equal(data.into_iter().coalesce(|x, y|"] # [doc = "         if (x >= 0.) == (y >= 0.) {"] # [doc = "             Ok(x + y)"] # [doc = "         } else {"] # [doc = "             Err((x, y))"] # [doc = "         }),"] # [doc = "         vec![-6., 4., -1.]);"] # [doc = " ```"] fn coalesce < F > (self , f : F) -> Coalesce < Self , F > where Self : Sized , F : FnMut (Self :: Item , Self :: Item) -> Result < Self :: Item , (Self :: Item , Self :: Item) > { adaptors :: coalesce (self , f) } # [doc = " Remove duplicates from sections of consecutive identical elements."] # [doc = " If the iterator is sorted, all elements will be unique."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![1., 1., 2., 3., 3., 2., 2.];"] # [doc = " itertools::assert_equal(data.into_iter().dedup(),"] # [doc = "                         vec![1., 2., 3., 2.]);"] # [doc = " ```"] fn dedup (self) -> Dedup < Self > where Self : Sized , Self :: Item : PartialEq , { adaptors :: dedup (self) } # [doc = " Remove duplicates from sections of consecutive identical elements,"] # [doc = " determining equality using a comparison function."] # [doc = " If the iterator is sorted, all elements will be unique."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " This iterator is *fused*."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![(0, 1.), (1, 1.), (0, 2.), (0, 3.), (1, 3.), (1, 2.), (2, 2.)];"] # [doc = " itertools::assert_equal(data.into_iter().dedup_by(|x, y| x.1==y.1),"] # [doc = "                         vec![(0, 1.), (0, 2.), (0, 3.), (1, 2.)]);"] # [doc = " ```"] fn dedup_by < Cmp > (self , cmp : Cmp) -> DedupBy < Self , Cmp > where Self : Sized , Cmp : FnMut (& Self :: Item , & Self :: Item) -> bool , { adaptors :: dedup_by (self , cmp) } # [doc = " Return an iterator adaptor that filters out elements that have"] # [doc = " already been produced once during the iteration. Duplicates"] # [doc = " are detected using hash and equality."] # [doc = ""] # [doc = " Clones of visited elements are stored in a hash set in the"] # [doc = " iterator."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![10, 20, 30, 20, 40, 10, 50];"] # [doc = " itertools::assert_equal(data.into_iter().unique(),"] # [doc = "                         vec![10, 20, 30, 40, 50]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn unique (self) -> Unique < Self > where Self : Sized , Self :: Item : Clone + Eq + Hash { unique_impl :: unique (self) } # [doc = " Return an iterator adaptor that filters out elements that have"] # [doc = " already been produced once during the iteration."] # [doc = ""] # [doc = " Duplicates are detected by comparing the key they map to"] # [doc = " with the keying function `f` by hash and equality."] # [doc = " The keys are stored in a hash set in the iterator."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![\"a\", \"bb\", \"aa\", \"c\", \"ccc\"];"] # [doc = " itertools::assert_equal(data.into_iter().unique_by(|s| s.len()),"] # [doc = "                         vec![\"a\", \"bb\", \"ccc\"]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn unique_by < V , F > (self , f : F) -> UniqueBy < Self , V , F > where Self : Sized , V : Eq + Hash , F : FnMut (& Self :: Item) -> V { unique_impl :: unique_by (self , f) } # [doc = " Return an iterator adaptor that borrows from this iterator and"] # [doc = " takes items while the closure `accept` returns `true`."] # [doc = ""] # [doc = " This adaptor can only be used on iterators that implement `PeekingNext`"] # [doc = " like `.peekable()`, `put_back` and a few other collection iterators."] # [doc = ""] # [doc = " The last and rejected element (first `false`) is still available when"] # [doc = " `peeking_take_while` is done."] # [doc = ""] # [doc = ""] # [doc = " See also [`.take_while_ref()`](#method.take_while_ref)"] # [doc = " which is a similar adaptor."] fn peeking_take_while < F > (& mut self , accept : F) -> PeekingTakeWhile < Self , F > where Self : Sized + PeekingNext , F : FnMut (& Self :: Item) -> bool , { peeking_take_while :: peeking_take_while (self , accept) } # [doc = " Return an iterator adaptor that borrows from a `Clone`-able iterator"] # [doc = " to only pick off elements while the predicate `accept` returns `true`."] # [doc = ""] # [doc = " It uses the `Clone` trait to restore the original iterator so that the"] # [doc = " last and rejected element (first `false`) is still available when"] # [doc = " `take_while_ref` is done."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut hexadecimals = \"0123456789abcdef\".chars();"] # [doc = ""] # [doc = " let decimals = hexadecimals.take_while_ref(|c| c.is_numeric())"] # [doc = "                            .collect::<String>();"] # [doc = " assert_eq!(decimals, \"0123456789\");"] # [doc = " assert_eq!(hexadecimals.next(), Some('a'));"] # [doc = ""] # [doc = " ```"] fn take_while_ref < F > (& mut self , accept : F) -> TakeWhileRef < Self , F > where Self : Clone , F : FnMut (& Self :: Item) -> bool { adaptors :: take_while_ref (self , accept) } # [doc = " Return an iterator adaptor that filters `Option<A>` iterator elements"] # [doc = " and produces `A`. Stops on the first `None` encountered."] # [doc = ""] # [doc = " Iterator element type is `A`, the unwrapped element."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // List all hexadecimal digits"] # [doc = " itertools::assert_equal("] # [doc = "     (0..).map(|i| std::char::from_digit(i, 16)).while_some(),"] # [doc = "     \"0123456789abcdef\".chars());"] # [doc = ""] # [doc = " ```"] fn while_some < A > (self) -> WhileSome < Self > where Self : Sized + Iterator < Item = Option < A > > { adaptors :: while_some (self) } # [doc = " Return an iterator adaptor that iterates over the combinations of the"] # [doc = " elements from an iterator."] # [doc = ""] # [doc = " Iterator element can be any homogeneous tuple of type `Self::Item` with"] # [doc = " size up to 4."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut v = Vec::new();"] # [doc = " for (a, b) in (1..5).tuple_combinations() {"] # [doc = "     v.push((a, b));"] # [doc = " }"] # [doc = " assert_eq!(v, vec![(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]);"] # [doc = ""] # [doc = " let mut it = (1..5).tuple_combinations();"] # [doc = " assert_eq!(Some((1, 2, 3)), it.next());"] # [doc = " assert_eq!(Some((1, 2, 4)), it.next());"] # [doc = " assert_eq!(Some((1, 3, 4)), it.next());"] # [doc = " assert_eq!(Some((2, 3, 4)), it.next());"] # [doc = " assert_eq!(None, it.next());"] # [doc = ""] # [doc = " // this requires a type hint"] # [doc = " let it = (1..5).tuple_combinations::<(_, _, _)>();"] # [doc = " itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);"] # [doc = ""] # [doc = " // you can also specify the complete type"] # [doc = " use itertools::TupleCombinations;"] # [doc = " use std::ops::Range;"] # [doc = ""] # [doc = " let it: TupleCombinations<Range<u32>, (u32, u32, u32)> = (1..5).tuple_combinations();"] # [doc = " itertools::assert_equal(it, vec![(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]);"] # [doc = " ```"] fn tuple_combinations < T > (self) -> TupleCombinations < Self , T > where Self : Sized + Clone , Self :: Item : Clone , T : adaptors :: HasCombination < Self > , { adaptors :: tuple_combinations (self) } # [doc = " Return an iterator adaptor that iterates over the `k`-length combinations of"] # [doc = " the elements from an iterator."] # [doc = ""] # [doc = " Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,"] # [doc = " and clones the iterator elements."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (1..5).combinations(3);"] # [doc = " itertools::assert_equal(it, vec!["] # [doc = "     vec![1, 2, 3],"] # [doc = "     vec![1, 2, 4],"] # [doc = "     vec![1, 3, 4],"] # [doc = "     vec![2, 3, 4],"] # [doc = " ]);"] # [doc = " ```"] # [doc = ""] # [doc = " Note: Combinations does not take into account the equality of the iterated values."] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = vec![1, 2, 2].into_iter().combinations(2);"] # [doc = " itertools::assert_equal(it, vec!["] # [doc = "     vec![1, 2], // Note: these are the same"] # [doc = "     vec![1, 2], // Note: these are the same"] # [doc = "     vec![2, 2],"] # [doc = " ]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn combinations (self , k : usize) -> Combinations < Self > where Self : Sized , Self :: Item : Clone { combinations :: combinations (self , k) } # [doc = " Return an iterator that iterates over the `k`-length combinations of"] # [doc = " the elements from an iterator, with replacement."] # [doc = ""] # [doc = " Iterator element type is `Vec<Self::Item>`. The iterator produces a new Vec per iteration,"] # [doc = " and clones the iterator elements."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (1..4).combinations_with_replacement(2);"] # [doc = " itertools::assert_equal(it, vec!["] # [doc = "     vec![1, 1],"] # [doc = "     vec![1, 2],"] # [doc = "     vec![1, 3],"] # [doc = "     vec![2, 2],"] # [doc = "     vec![2, 3],"] # [doc = "     vec![3, 3],"] # [doc = " ]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn combinations_with_replacement (self , k : usize) -> CombinationsWithReplacement < Self > where Self : Sized , Self :: Item : Clone , { combinations_with_replacement :: combinations_with_replacement (self , k) } # [doc = " Return an iterator adaptor that iterates over all k-permutations of the"] # [doc = " elements from an iterator."] # [doc = ""] # [doc = " Iterator element type is `Vec<Self::Item>` with length `k`. The iterator"] # [doc = " produces a new Vec per iteration, and clones the iterator elements."] # [doc = ""] # [doc = " If `k` is greater than the length of the input iterator, the resultant"] # [doc = " iterator adaptor will be empty."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let perms = (5..8).permutations(2);"] # [doc = " itertools::assert_equal(perms, vec!["] # [doc = "     vec![5, 6],"] # [doc = "     vec![5, 7],"] # [doc = "     vec![6, 5],"] # [doc = "     vec![6, 7],"] # [doc = "     vec![7, 5],"] # [doc = "     vec![7, 6],"] # [doc = " ]);"] # [doc = " ```"] # [doc = ""] # [doc = " Note: Permutations does not take into account the equality of the iterated values."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = vec![2, 2].into_iter().permutations(2);"] # [doc = " itertools::assert_equal(it, vec!["] # [doc = "     vec![2, 2], // Note: these are the same"] # [doc = "     vec![2, 2], // Note: these are the same"] # [doc = " ]);"] # [doc = " ```"] # [doc = ""] # [doc = " Note: The source iterator is collected lazily, and will not be"] # [doc = " re-iterated if the permutations adaptor is completed and re-iterated."] # [cfg (feature = "use_std")] fn permutations (self , k : usize) -> Permutations < Self > where Self : Sized , Self :: Item : Clone { permutations :: permutations (self , k) } # [doc = " Return an iterator adaptor that pads the sequence to a minimum length of"] # [doc = " `min` by filling missing elements using a closure `f`."] # [doc = ""] # [doc = " Iterator element type is `Self::Item`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let it = (0..5).pad_using(10, |i| 2*i);"] # [doc = " itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 10, 12, 14, 16, 18]);"] # [doc = ""] # [doc = " let it = (0..10).pad_using(5, |i| 2*i);"] # [doc = " itertools::assert_equal(it, vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);"] # [doc = ""] # [doc = " let it = (0..5).pad_using(10, |i| 2*i).rev();"] # [doc = " itertools::assert_equal(it, vec![18, 16, 14, 12, 10, 4, 3, 2, 1, 0]);"] # [doc = " ```"] fn pad_using < F > (self , min : usize , f : F) -> PadUsing < Self , F > where Self : Sized , F : FnMut (usize) -> Self :: Item { pad_tail :: pad_using (self , min , f) } # [doc = " Return an iterator adaptor that wraps each element in a `Position` to"] # [doc = " ease special-case handling of the first or last elements."] # [doc = ""] # [doc = " Iterator element type is"] # [doc = " [`Position<Self::Item>`](enum.Position.html)"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::{Itertools, Position};"] # [doc = ""] # [doc = " let it = (0..4).with_position();"] # [doc = " itertools::assert_equal(it,"] # [doc = "                         vec![Position::First(0),"] # [doc = "                              Position::Middle(1),"] # [doc = "                              Position::Middle(2),"] # [doc = "                              Position::Last(3)]);"] # [doc = ""] # [doc = " let it = (0..1).with_position();"] # [doc = " itertools::assert_equal(it, vec![Position::Only(0)]);"] # [doc = " ```"] fn with_position (self) -> WithPosition < Self > where Self : Sized , { with_position :: with_position (self) } # [doc = " Return an iterator adaptor that yields the indices of all elements"] # [doc = " satisfying a predicate, counted from the start of the iterator."] # [doc = ""] # [doc = " Equivalent to `iter.enumerate().filter(|(_, v)| predicate(v)).map(|(i, _)| i)`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![1, 2, 3, 3, 4, 6, 7, 9];"] # [doc = " itertools::assert_equal(data.iter().positions(|v| v % 2 == 0), vec![1, 4, 5]);"] # [doc = ""] # [doc = " itertools::assert_equal(data.iter().positions(|v| v % 2 == 1).rev(), vec![7, 6, 3, 2, 0]);"] # [doc = " ```"] fn positions < P > (self , predicate : P) -> Positions < Self , P > where Self : Sized , P : FnMut (Self :: Item) -> bool , { adaptors :: positions (self , predicate) } # [doc = " Return an iterator adaptor that applies a mutating function"] # [doc = " to each element before yielding it."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let input = vec![vec![1], vec![3, 2, 1]];"] # [doc = " let it = input.into_iter().update(|mut v| v.push(0));"] # [doc = " itertools::assert_equal(it, vec![vec![1, 0], vec![3, 2, 1, 0]]);"] # [doc = " ```"] fn update < F > (self , updater : F) -> Update < Self , F > where Self : Sized , F : FnMut (& mut Self :: Item) , { adaptors :: update (self , updater) } # [doc = " Advances the iterator and returns the next items grouped in a tuple of"] # [doc = " a specific size (up to 4)."] # [doc = ""] # [doc = " If there are enough elements to be grouped in a tuple, then the tuple is"] # [doc = " returned inside `Some`, otherwise `None` is returned."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut iter = 1..5;"] # [doc = ""] # [doc = " assert_eq!(Some((1, 2)), iter.next_tuple());"] # [doc = " ```"] fn next_tuple < T > (& mut self) -> Option < T > where Self : Sized + Iterator < Item = T :: Item > , T : traits :: HomogeneousTuple { T :: collect_from_iter_no_buf (self) } # [doc = " Collects all items from the iterator into a tuple of a specific size"] # [doc = " (up to 4)."] # [doc = ""] # [doc = " If the number of elements inside the iterator is **exactly** equal to"] # [doc = " the tuple size, then the tuple is returned inside `Some`, otherwise"] # [doc = " `None` is returned."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let iter = 1..3;"] # [doc = ""] # [doc = " if let Some((x, y)) = iter.collect_tuple() {"] # [doc = "     assert_eq!((x, y), (1, 2))"] # [doc = " } else {"] # [doc = "     panic!(\"Expected two elements\")"] # [doc = " }"] # [doc = " ```"] fn collect_tuple < T > (mut self) -> Option < T > where Self : Sized + Iterator < Item = T :: Item > , T : traits :: HomogeneousTuple { match self . next_tuple () { elt @ Some (_) => match self . next () { Some (_) => None , None => elt , } , _ => None } } # [doc = " Find the position and value of the first element satisfying a predicate."] # [doc = ""] # [doc = " The iterator is not advanced past the first element found."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let text = \"H\";"] # [doc = " assert_eq!(text.chars().find_position(|ch| ch.is_lowercase()), Some((1, '')));"] # [doc = " ```"] fn find_position < P > (& mut self , mut pred : P) -> Option < (usize , Self :: Item) > where P : FnMut (& Self :: Item) -> bool { let mut index = 0usize ; for elt in self { if pred (& elt) { return Some ((index , elt)) ; } index += 1 ; } None } # [doc = " Check whether all elements compare equal."] # [doc = ""] # [doc = " Empty iterators are considered to have equal elements:"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![1, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5];"] # [doc = " assert!(!data.iter().all_equal());"] # [doc = " assert!(data[0..3].iter().all_equal());"] # [doc = " assert!(data[3..5].iter().all_equal());"] # [doc = " assert!(data[5..8].iter().all_equal());"] # [doc = ""] # [doc = " let data : Option<usize> = None;"] # [doc = " assert!(data.into_iter().all_equal());"] # [doc = " ```"] fn all_equal (& mut self) -> bool where Self : Sized , Self :: Item : PartialEq , { match self . next () { None => true , Some (a) => self . all (| x | a == x) , } } # [doc = " Consume the first `n` elements from the iterator eagerly,"] # [doc = " and return the same iterator again."] # [doc = ""] # [doc = " It works similarly to *.skip(* `n` *)* except it is eager and"] # [doc = " preserves the iterator type."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut iter = \"\".chars().dropping(2);"] # [doc = " itertools::assert_equal(iter, \"\".chars());"] # [doc = " ```"] # [doc = ""] # [doc = " *Fusing notes: if the iterator is exhausted by dropping,"] # [doc = " the result of calling `.next()` again depends on the iterator implementation.*"] fn dropping (mut self , n : usize) -> Self where Self : Sized { if n > 0 { self . nth (n - 1) ; } self } # [doc = " Consume the last `n` elements from the iterator eagerly,"] # [doc = " and return the same iterator again."] # [doc = ""] # [doc = " This is only possible on double ended iterators. `n` may be"] # [doc = " larger than the number of elements."] # [doc = ""] # [doc = " Note: This method is eager, dropping the back elements immediately and"] # [doc = " preserves the iterator type."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let init = vec![0, 3, 6, 9].into_iter().dropping_back(1);"] # [doc = " itertools::assert_equal(init, vec![0, 3, 6]);"] # [doc = " ```"] fn dropping_back (mut self , n : usize) -> Self where Self : Sized , Self : DoubleEndedIterator { if n > 0 { (& mut self) . rev () . nth (n - 1) ; } self } # [doc = " Run the closure `f` eagerly on each element of the iterator."] # [doc = ""] # [doc = " Consumes the iterator until its end."] # [doc = ""] # [doc = " ```"] # [doc = " use std::sync::mpsc::channel;"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let (tx, rx) = channel();"] # [doc = ""] # [doc = " // use .foreach() to apply a function to each value -- sending it"] # [doc = " (0..5).map(|x| x * 2 + 1).foreach(|x| { tx.send(x).unwrap(); } );"] # [doc = ""] # [doc = " drop(tx);"] # [doc = ""] # [doc = " itertools::assert_equal(rx.iter(), vec![1, 3, 5, 7, 9]);"] # [doc = " ```"] # [deprecated (note = "Use .for_each() instead" , since = "0.8")] fn foreach < F > (self , f : F) where F : FnMut (Self :: Item) , Self : Sized , { self . for_each (f) } # [doc = " Combine all an iterator's elements into one element by using `Extend`."] # [doc = ""] # [doc = " This combinator will extend the first item with each of the rest of the"] # [doc = " items of the iterator. If the iterator is empty, the default value of"] # [doc = " `I::Item` is returned."] # [doc = ""] # [doc = " ```rust"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let input = vec![vec![1], vec![2, 3], vec![4, 5, 6]];"] # [doc = " assert_eq!(input.into_iter().concat(),"] # [doc = "            vec![1, 2, 3, 4, 5, 6]);"] # [doc = " ```"] fn concat (self) -> Self :: Item where Self : Sized , Self :: Item : Extend < < < Self as Iterator > :: Item as IntoIterator > :: Item > + IntoIterator + Default { concat (self) } # [doc = " `.collect_vec()` is simply a type specialization of `.collect()`,"] # [doc = " for convenience."] # [cfg (feature = "use_std")] fn collect_vec (self) -> Vec < Self :: Item > where Self : Sized { self . collect () } # [doc = " `.try_collect()` is more convenient way of writing"] # [doc = " `.collect::<Result<_, _>>()`"] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use std::{fs, io};"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " fn process_dir_entries(entries: &[fs::DirEntry]) {"] # [doc = "     // ..."] # [doc = " }"] # [doc = ""] # [doc = " fn do_stuff() -> std::io::Result<()> {"] # [doc = "     let entries: Vec<_> = fs::read_dir(\".\")?.try_collect()?;"] # [doc = "     process_dir_entries(&entries);"] # [doc = ""] # [doc = "     Ok(())"] # [doc = " }"] # [doc = " ```"] # [cfg (feature = "use_std")] fn try_collect < T , U , E > (self) -> Result < U , E > where Self : Sized + Iterator < Item = Result < T , E > > , Result < U , E > : FromIterator < Result < T , E > > , { self . collect () } # [doc = " Assign to each reference in `self` from the `from` iterator,"] # [doc = " stopping at the shortest of the two iterators."] # [doc = ""] # [doc = " The `from` iterator is queried for its next element before the `self`"] # [doc = " iterator, and if either is exhausted the method is done."] # [doc = ""] # [doc = " Return the number of elements written."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut xs = [0; 4];"] # [doc = " xs.iter_mut().set_from(1..);"] # [doc = " assert_eq!(xs, [1, 2, 3, 4]);"] # [doc = " ```"] # [inline] fn set_from < 'a , A : 'a , J > (& mut self , from : J) -> usize where Self : Iterator < Item = & 'a mut A > , J : IntoIterator < Item = A > { let mut count = 0 ; for elt in from { match self . next () { None => break , Some (ptr) => * ptr = elt , } count += 1 ; } count } # [doc = " Combine all iterator elements into one String, separated by `sep`."] # [doc = ""] # [doc = " Use the `Display` implementation of each element."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " assert_eq!([\"a\", \"b\", \"c\"].iter().join(\", \"), \"a, b, c\");"] # [doc = " assert_eq!([1, 2, 3].iter().join(\", \"), \"1, 2, 3\");"] # [doc = " ```"] # [cfg (feature = "use_std")] fn join (& mut self , sep : & str) -> String where Self :: Item : std :: fmt :: Display { match self . next () { None => String :: new () , Some (first_elt) => { let (lower , _) = self . size_hint () ; let mut result = String :: with_capacity (sep . len () * lower) ; write ! (& mut result , "{}" , first_elt) . unwrap () ; for elt in self { result . push_str (sep) ; write ! (& mut result , "{}" , elt) . unwrap () ; } result } } } # [doc = " Format all iterator elements, separated by `sep`."] # [doc = ""] # [doc = " All elements are formatted (any formatting trait)"] # [doc = " with `sep` inserted between each element."] # [doc = ""] # [doc = " **Panics** if the formatter helper is formatted more than once."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = [1.1, 2.71828, -3.];"] # [doc = " assert_eq!("] # [doc = "     format!(\"{:.2}\", data.iter().format(\", \")),"] # [doc = "            \"1.10, 2.72, -3.00\");"] # [doc = " ```"] fn format (self , sep : & str) -> Format < Self > where Self : Sized , { format :: new_format_default (self , sep) } # [doc = " Format all iterator elements, separated by `sep`."] # [doc = ""] # [doc = " This is a customizable version of `.format()`."] # [doc = ""] # [doc = " The supplied closure `format` is called once per iterator element,"] # [doc = " with two arguments: the element and a callback that takes a"] # [doc = " `&Display` value, i.e. any reference to type that implements `Display`."] # [doc = ""] # [doc = " Using `&format_args!(...)` is the most versatile way to apply custom"] # [doc = " element formatting. The callback can be called multiple times if needed."] # [doc = ""] # [doc = " **Panics** if the formatter helper is formatted more than once."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = [1.1, 2.71828, -3.];"] # [doc = " let data_formatter = data.iter().format_with(\", \", |elt, f| f(&format_args!(\"{:.2}\", elt)));"] # [doc = " assert_eq!(format!(\"{}\", data_formatter),"] # [doc = "            \"1.10, 2.72, -3.00\");"] # [doc = ""] # [doc = " // .format_with() is recursively composable"] # [doc = " let matrix = [[1., 2., 3.],"] # [doc = "               [4., 5., 6.]];"] # [doc = " let matrix_formatter = matrix.iter().format_with(\"\\n\", |row, f| {"] # [doc = "                                 f(&row.iter().format_with(\", \", |elt, g| g(&elt)))"] # [doc = "                              });"] # [doc = " assert_eq!(format!(\"{}\", matrix_formatter),"] # [doc = "            \"1, 2, 3\\n4, 5, 6\");"] # [doc = ""] # [doc = ""] # [doc = " ```"] fn format_with < F > (self , sep : & str , format : F) -> FormatWith < Self , F > where Self : Sized , F : FnMut (Self :: Item , & mut dyn FnMut (& dyn fmt :: Display) -> fmt :: Result) -> fmt :: Result , { format :: new_format (self , sep , format) } # [doc = " Fold `Result` values from an iterator."] # [doc = ""] # [doc = " Only `Ok` values are folded. If no error is encountered, the folded"] # [doc = " value is returned inside `Ok`. Otherwise, the operation terminates"] # [doc = " and returns the first `Err` value it encounters. No iterator elements are"] # [doc = " consumed after the first error."] # [doc = ""] # [doc = " The first accumulator value is the `start` parameter."] # [doc = " Each iteration passes the accumulator value and the next value inside `Ok`"] # [doc = " to the fold function `f` and its return value becomes the new accumulator value."] # [doc = ""] # [doc = " For example the sequence *Ok(1), Ok(2), Ok(3)* will result in a"] # [doc = " computation like this:"] # [doc = ""] # [doc = " ```ignore"] # [doc = " let mut accum = start;"] # [doc = " accum = f(accum, 1);"] # [doc = " accum = f(accum, 2);"] # [doc = " accum = f(accum, 3);"] # [doc = " ```"] # [doc = ""] # [doc = " With a `start` value of 0 and an addition as folding function,"] # [doc = " this effectively results in *((0 + 1) + 2) + 3*"] # [doc = ""] # [doc = " ```"] # [doc = " use std::ops::Add;"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let values = [1, 2, -2, -1, 2, 1];"] # [doc = " assert_eq!("] # [doc = "     values.iter()"] # [doc = "           .map(Ok::<_, ()>)"] # [doc = "           .fold_results(0, Add::add),"] # [doc = "     Ok(3)"] # [doc = " );"] # [doc = " assert!("] # [doc = "     values.iter()"] # [doc = "           .map(|&x| if x >= 0 { Ok(x) } else { Err(\"Negative number\") })"] # [doc = "           .fold_results(0, Add::add)"] # [doc = "           .is_err()"] # [doc = " );"] # [doc = " ```"] fn fold_results < A , E , B , F > (& mut self , mut start : B , mut f : F) -> Result < B , E > where Self : Iterator < Item = Result < A , E > > , F : FnMut (B , A) -> B { for elt in self { match elt { Ok (v) => start = f (start , v) , Err (u) => return Err (u) , } } Ok (start) } # [doc = " Fold `Option` values from an iterator."] # [doc = ""] # [doc = " Only `Some` values are folded. If no `None` is encountered, the folded"] # [doc = " value is returned inside `Some`. Otherwise, the operation terminates"] # [doc = " and returns `None`. No iterator elements are consumed after the `None`."] # [doc = ""] # [doc = " This is the `Option` equivalent to `fold_results`."] # [doc = ""] # [doc = " ```"] # [doc = " use std::ops::Add;"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let mut values = vec![Some(1), Some(2), Some(-2)].into_iter();"] # [doc = " assert_eq!(values.fold_options(5, Add::add), Some(5 + 1 + 2 - 2));"] # [doc = ""] # [doc = " let mut more_values = vec![Some(2), None, Some(0)].into_iter();"] # [doc = " assert!(more_values.fold_options(0, Add::add).is_none());"] # [doc = " assert_eq!(more_values.next().unwrap(), Some(0));"] # [doc = " ```"] fn fold_options < A , B , F > (& mut self , mut start : B , mut f : F) -> Option < B > where Self : Iterator < Item = Option < A > > , F : FnMut (B , A) -> B { for elt in self { match elt { Some (v) => start = f (start , v) , None => return None , } } Some (start) } # [doc = " Accumulator of the elements in the iterator."] # [doc = ""] # [doc = " Like `.fold()`, without a base case. If the iterator is"] # [doc = " empty, return `None`. With just one element, return it."] # [doc = " Otherwise elements are accumulated in sequence using the closure `f`."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " assert_eq!((0..10).fold1(|x, y| x + y).unwrap_or(0), 45);"] # [doc = " assert_eq!((0..0).fold1(|x, y| x * y), None);"] # [doc = " ```"] fn fold1 < F > (mut self , f : F) -> Option < Self :: Item > where F : FnMut (Self :: Item , Self :: Item) -> Self :: Item , Self : Sized , { self . next () . map (move | x | self . fold (x , f)) } # [doc = " Accumulate the elements in the iterator in a tree-like manner."] # [doc = ""] # [doc = " You can think of it as, while there's more than one item, repeatedly"] # [doc = " combining adjacent items.  It does so in bottom-up-merge-sort order,"] # [doc = " however, so that it needs only logarithmic stack space."] # [doc = ""] # [doc = " This produces a call tree like the following (where the calls under"] # [doc = " an item are done after reading that item):"] # [doc = ""] # [doc = " ```text"] # [doc = " 1 2 3 4 5 6 7"] # [doc = "       "] # [doc = " f f f "] # [doc = "          "] # [doc = "   f   f"] # [doc = "            "] # [doc = "       f"] # [doc = " ```"] # [doc = ""] # [doc = " Which, for non-associative functions, will typically produce a different"] # [doc = " result than the linear call tree used by `fold1`:"] # [doc = ""] # [doc = " ```text"] # [doc = " 1 2 3 4 5 6 7"] # [doc = "       "] # [doc = " ffffff"] # [doc = " ```"] # [doc = ""] # [doc = " If `f` is associative, prefer the normal `fold1` instead."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // The same tree as above"] # [doc = " let num_strings = (1..8).map(|x| x.to_string());"] # [doc = " assert_eq!(num_strings.tree_fold1(|x, y| format!(\"f({}, {})\", x, y)),"] # [doc = "     Some(String::from(\"f(f(f(1, 2), f(3, 4)), f(f(5, 6), 7))\")));"] # [doc = ""] # [doc = " // Like fold1, an empty iterator produces None"] # [doc = " assert_eq!((0..0).tree_fold1(|x, y| x * y), None);"] # [doc = ""] # [doc = " // tree_fold1 matches fold1 for associative operations..."] # [doc = " assert_eq!((0..10).tree_fold1(|x, y| x + y),"] # [doc = "     (0..10).fold1(|x, y| x + y));"] # [doc = " // ...but not for non-associative ones"] # [doc = " assert_ne!((0..10).tree_fold1(|x, y| x - y),"] # [doc = "     (0..10).fold1(|x, y| x - y));"] # [doc = " ```"] fn tree_fold1 < F > (mut self , mut f : F) -> Option < Self :: Item > where F : FnMut (Self :: Item , Self :: Item) -> Self :: Item , Self : Sized , { type State < T > = Result < T , Option < T > > ; fn inner0 < T , II , FF > (it : & mut II , f : & mut FF) -> State < T > where II : Iterator < Item = T > , FF : FnMut (T , T) -> T { let a = if let Some (v) = it . next () { v } else { return Err (None) } ; let b = if let Some (v) = it . next () { v } else { return Err (Some (a)) } ; Ok (f (a , b)) } fn inner < T , II , FF > (stop : usize , it : & mut II , f : & mut FF) -> State < T > where II : Iterator < Item = T > , FF : FnMut (T , T) -> T { let mut x = inner0 (it , f) ? ; for height in 0 .. stop { let next = if height == 0 { inner0 (it , f) } else { inner (height , it , f) } ; match next { Ok (y) => x = f (x , y) , Err (None) => return Err (Some (x)) , Err (Some (y)) => return Err (Some (f (x , y))) , } } Ok (x) } match inner (usize :: max_value () , & mut self , & mut f) { Err (x) => x , _ => unreachable ! () , } } # [doc = " An iterator method that applies a function, producing a single, final value."] # [doc = ""] # [doc = " `fold_while()` is basically equivalent to `fold()` but with additional support for"] # [doc = " early exit via short-circuiting."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " use itertools::FoldWhile::{Continue, Done};"] # [doc = ""] # [doc = " let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"] # [doc = ""] # [doc = " let mut result = 0;"] # [doc = ""] # [doc = " // for loop:"] # [doc = " for i in &numbers {"] # [doc = "     if *i > 5 {"] # [doc = "         break;"] # [doc = "     }"] # [doc = "     result = result + i;"] # [doc = " }"] # [doc = ""] # [doc = " // fold:"] # [doc = " let result2 = numbers.iter().fold(0, |acc, x| {"] # [doc = "     if *x > 5 { acc } else { acc + x }"] # [doc = " });"] # [doc = ""] # [doc = " // fold_while:"] # [doc = " let result3 = numbers.iter().fold_while(0, |acc, x| {"] # [doc = "     if *x > 5 { Done(acc) } else { Continue(acc + x) }"] # [doc = " }).into_inner();"] # [doc = ""] # [doc = " // they're the same"] # [doc = " assert_eq!(result, result2);"] # [doc = " assert_eq!(result2, result3);"] # [doc = " ```"] # [doc = ""] # [doc = " The big difference between the computations of `result2` and `result3` is that while"] # [doc = " `fold()` called the provided closure for every item of the callee iterator,"] # [doc = " `fold_while()` actually stopped iterating as soon as it encountered `Fold::Done(_)`."] # [deprecated (note = "Use .try_fold() instead" , since = "0.8")] fn fold_while < B , F > (& mut self , init : B , mut f : F) -> FoldWhile < B > where Self : Sized , F : FnMut (B , Self :: Item) -> FoldWhile < B > { let mut acc = init ; while let Some (item) = self . next () { match f (acc , item) { FoldWhile :: Continue (res) => acc = res , res @ FoldWhile :: Done (_) => return res , } } FoldWhile :: Continue (acc) } # [doc = " Iterate over the entire iterator and add all the elements."] # [doc = ""] # [doc = " An empty iterator returns `None`, otherwise `Some(sum)`."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When calling `sum1()` and a primitive integer type is being returned, this"] # [doc = " method will panic if the computation overflows and debug assertions are"] # [doc = " enabled."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let empty_sum = (1..1).sum1::<i32>();"] # [doc = " assert_eq!(empty_sum, None);"] # [doc = ""] # [doc = " let nonempty_sum = (1..11).sum1::<i32>();"] # [doc = " assert_eq!(nonempty_sum, Some(55));"] # [doc = " ```"] fn sum1 < S > (mut self) -> Option < S > where Self : Sized , S : std :: iter :: Sum < Self :: Item > , { self . next () . map (| first | once (first) . chain (self) . sum ()) } # [doc = " Iterate over the entire iterator and multiply all the elements."] # [doc = ""] # [doc = " An empty iterator returns `None`, otherwise `Some(product)`."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When calling `product1()` and a primitive integer type is being returned,"] # [doc = " method will panic if the computation overflows and debug assertions are"] # [doc = " enabled."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let empty_product = (1..1).product1::<i32>();"] # [doc = " assert_eq!(empty_product, None);"] # [doc = ""] # [doc = " let nonempty_product = (1..11).product1::<i32>();"] # [doc = " assert_eq!(nonempty_product, Some(3628800));"] # [doc = " ```"] fn product1 < P > (mut self) -> Option < P > where Self : Sized , P : std :: iter :: Product < Self :: Item > , { self . next () . map (| first | once (first) . chain (self) . product ()) } # [doc = " Sort all iterator elements into a new iterator in ascending order."] # [doc = ""] # [doc = " **Note:** This consumes the entire iterator, uses the"] # [doc = " `slice::sort()` method and returns the result as a new"] # [doc = " iterator that owns its elements."] # [doc = ""] # [doc = " The sorted iterator, if directly collected to a `Vec`, is converted"] # [doc = " without any extra copying or allocation cost."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // sort the letters of the text in ascending order"] # [doc = " let text = \"bdacfe\";"] # [doc = " itertools::assert_equal(text.chars().sorted(),"] # [doc = "                         \"abcdef\".chars());"] # [doc = " ```"] # [cfg (feature = "use_std")] fn sorted (self) -> VecIntoIter < Self :: Item > where Self : Sized , Self :: Item : Ord { let mut v = Vec :: from_iter (self) ; v . sort () ; v . into_iter () } # [doc = " Sort all iterator elements into a new iterator in ascending order."] # [doc = ""] # [doc = " **Note:** This consumes the entire iterator, uses the"] # [doc = " `slice::sort_by()` method and returns the result as a new"] # [doc = " iterator that owns its elements."] # [doc = ""] # [doc = " The sorted iterator, if directly collected to a `Vec`, is converted"] # [doc = " without any extra copying or allocation cost."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // sort people in descending order by age"] # [doc = " let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];"] # [doc = ""] # [doc = " let oldest_people_first = people"] # [doc = "     .into_iter()"] # [doc = "     .sorted_by(|a, b| Ord::cmp(&b.1, &a.1))"] # [doc = "     .map(|(person, _age)| person);"] # [doc = ""] # [doc = " itertools::assert_equal(oldest_people_first,"] # [doc = "                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn sorted_by < F > (self , cmp : F) -> VecIntoIter < Self :: Item > where Self : Sized , F : FnMut (& Self :: Item , & Self :: Item) -> Ordering , { let mut v = Vec :: from_iter (self) ; v . sort_by (cmp) ; v . into_iter () } # [doc = " Sort all iterator elements into a new iterator in ascending order."] # [doc = ""] # [doc = " **Note:** This consumes the entire iterator, uses the"] # [doc = " `slice::sort_by_key()` method and returns the result as a new"] # [doc = " iterator that owns its elements."] # [doc = ""] # [doc = " The sorted iterator, if directly collected to a `Vec`, is converted"] # [doc = " without any extra copying or allocation cost."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " // sort people in descending order by age"] # [doc = " let people = vec![(\"Jane\", 20), (\"John\", 18), (\"Jill\", 30), (\"Jack\", 27)];"] # [doc = ""] # [doc = " let oldest_people_first = people"] # [doc = "     .into_iter()"] # [doc = "     .sorted_by_key(|x| -x.1)"] # [doc = "     .map(|(person, _age)| person);"] # [doc = ""] # [doc = " itertools::assert_equal(oldest_people_first,"] # [doc = "                         vec![\"Jill\", \"Jack\", \"Jane\", \"John\"]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn sorted_by_key < K , F > (self , f : F) -> VecIntoIter < Self :: Item > where Self : Sized , K : Ord , F : FnMut (& Self :: Item) -> K , { let mut v = Vec :: from_iter (self) ; v . sort_by_key (f) ; v . into_iter () } # [doc = " Collect all iterator elements into one of two"] # [doc = " partitions. Unlike `Iterator::partition`, each partition may"] # [doc = " have a distinct type."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::{Itertools, Either};"] # [doc = ""] # [doc = " let successes_and_failures = vec![Ok(1), Err(false), Err(true), Ok(2)];"] # [doc = ""] # [doc = " let (successes, failures): (Vec<_>, Vec<_>) = successes_and_failures"] # [doc = "     .into_iter()"] # [doc = "     .partition_map(|r| {"] # [doc = "         match r {"] # [doc = "             Ok(v) => Either::Left(v),"] # [doc = "             Err(v) => Either::Right(v),"] # [doc = "         }"] # [doc = "     });"] # [doc = ""] # [doc = " assert_eq!(successes, [1, 2]);"] # [doc = " assert_eq!(failures, [false, true]);"] # [doc = " ```"] fn partition_map < A , B , F , L , R > (self , mut predicate : F) -> (A , B) where Self : Sized , F : FnMut (Self :: Item) -> Either < L , R > , A : Default + Extend < L > , B : Default + Extend < R > , { let mut left = A :: default () ; let mut right = B :: default () ; self . for_each (| val | match predicate (val) { Either :: Left (v) => left . extend (Some (v)) , Either :: Right (v) => right . extend (Some (v)) , }) ; (left , right) } # [doc = " Return a `HashMap` of keys mapped to `Vec`s of values. Keys and values"] # [doc = " are taken from `(Key, Value)` tuple pairs yielded by the input iterator."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let data = vec![(0, 10), (2, 12), (3, 13), (0, 20), (3, 33), (2, 42)];"] # [doc = " let lookup = data.into_iter().into_group_map();"] # [doc = ""] # [doc = " assert_eq!(lookup[&0], vec![10, 20]);"] # [doc = " assert_eq!(lookup.get(&1), None);"] # [doc = " assert_eq!(lookup[&2], vec![12, 42]);"] # [doc = " assert_eq!(lookup[&3], vec![13, 33]);"] # [doc = " ```"] # [cfg (feature = "use_std")] fn into_group_map < K , V > (self) -> HashMap < K , Vec < V > > where Self : Iterator < Item = (K , V) > + Sized , K : Hash + Eq , { group_map :: into_group_map (self) } # [doc = " Return the minimum and maximum elements in the iterator."] # [doc = ""] # [doc = " The return type `MinMaxResult` is an enum of three variants:"] # [doc = ""] # [doc = " - `NoElements` if the iterator is empty."] # [doc = " - `OneElement(x)` if the iterator has exactly one element."] # [doc = " - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two"] # [doc = "    values are equal if and only if there is more than one"] # [doc = "    element in the iterator and all elements are equal."] # [doc = ""] # [doc = " On an iterator of length `n`, `minmax` does `1.5 * n` comparisons,"] # [doc = " and so is faster than calling `min` and `max` separately which does"] # [doc = " `2 * n` comparisons."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " use itertools::MinMaxResult::{NoElements, OneElement, MinMax};"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().minmax(), NoElements);"] # [doc = ""] # [doc = " let a = [1];"] # [doc = " assert_eq!(a.iter().minmax(), OneElement(&1));"] # [doc = ""] # [doc = " let a = [1, 2, 3, 4, 5];"] # [doc = " assert_eq!(a.iter().minmax(), MinMax(&1, &5));"] # [doc = ""] # [doc = " let a = [1, 1, 1, 1];"] # [doc = " assert_eq!(a.iter().minmax(), MinMax(&1, &1));"] # [doc = " ```"] # [doc = ""] # [doc = " The elements can be floats but no particular result is guaranteed"] # [doc = " if an element is NaN."] fn minmax (self) -> MinMaxResult < Self :: Item > where Self : Sized , Self :: Item : PartialOrd { minmax :: minmax_impl (self , | _ | () , | x , y , _ , _ | x < y) } # [doc = " Return the minimum and maximum element of an iterator, as determined by"] # [doc = " the specified function."] # [doc = ""] # [doc = " The return value is a variant of `MinMaxResult` like for `minmax()`."] # [doc = ""] # [doc = " For the minimum, the first minimal element is returned.  For the maximum,"] # [doc = " the last maximal element wins.  This matches the behavior of the standard"] # [doc = " `Iterator::min()` and `Iterator::max()` methods."] # [doc = ""] # [doc = " The keys can be floats but no particular result is guaranteed"] # [doc = " if a key is NaN."] fn minmax_by_key < K , F > (self , key : F) -> MinMaxResult < Self :: Item > where Self : Sized , K : PartialOrd , F : FnMut (& Self :: Item) -> K { minmax :: minmax_impl (self , key , | _ , _ , xk , yk | xk < yk) } # [doc = " Return the minimum and maximum element of an iterator, as determined by"] # [doc = " the specified comparison function."] # [doc = ""] # [doc = " The return value is a variant of `MinMaxResult` like for `minmax()`."] # [doc = ""] # [doc = " For the minimum, the first minimal element is returned.  For the maximum,"] # [doc = " the last maximal element wins.  This matches the behavior of the standard"] # [doc = " `Iterator::min()` and `Iterator::max()` methods."] fn minmax_by < F > (self , mut compare : F) -> MinMaxResult < Self :: Item > where Self : Sized , F : FnMut (& Self :: Item , & Self :: Item) -> Ordering { minmax :: minmax_impl (self , | _ | () , | x , y , _ , _ | Ordering :: Less == compare (x , y)) } # [doc = " Return the position of the maximum element in the iterator."] # [doc = ""] # [doc = " If several elements are equally maximum, the position of the"] # [doc = " last of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_max(), None);"] # [doc = ""] # [doc = " let a = [-3, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_max(), Some(3));"] # [doc = ""] # [doc = " let a = [1, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_max(), Some(1));"] # [doc = " ```"] fn position_max (self) -> Option < usize > where Self : Sized , Self :: Item : Ord { self . enumerate () . max_by (| x , y | Ord :: cmp (& x . 1 , & y . 1)) . map (| x | x . 0) } # [doc = " Return the position of the maximum element in the iterator, as"] # [doc = " determined by the specified function."] # [doc = ""] # [doc = " If several elements are equally maximum, the position of the"] # [doc = " last of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_max_by_key(|x| x.abs()), None);"] # [doc = ""] # [doc = " let a = [-3_i32, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(4));"] # [doc = ""] # [doc = " let a = [1_i32, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_max_by_key(|x| x.abs()), Some(3));"] # [doc = " ```"] fn position_max_by_key < K , F > (self , mut key : F) -> Option < usize > where Self : Sized , K : Ord , F : FnMut (& Self :: Item) -> K { self . enumerate () . max_by (| x , y | Ord :: cmp (& key (& x . 1) , & key (& y . 1))) . map (| x | x . 0) } # [doc = " Return the position of the maximum element in the iterator, as"] # [doc = " determined by the specified comparison function."] # [doc = ""] # [doc = " If several elements are equally maximum, the position of the"] # [doc = " last of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), None);"] # [doc = ""] # [doc = " let a = [-3_i32, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(3));"] # [doc = ""] # [doc = " let a = [1_i32, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_max_by(|x, y| x.cmp(y)), Some(1));"] # [doc = " ```"] fn position_max_by < F > (self , mut compare : F) -> Option < usize > where Self : Sized , F : FnMut (& Self :: Item , & Self :: Item) -> Ordering { self . enumerate () . max_by (| x , y | compare (& x . 1 , & y . 1)) . map (| x | x . 0) } # [doc = " Return the position of the minimum element in the iterator."] # [doc = ""] # [doc = " If several elements are equally minimum, the position of the"] # [doc = " first of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_min(), None);"] # [doc = ""] # [doc = " let a = [-3, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_min(), Some(4));"] # [doc = ""] # [doc = " let a = [1, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_min(), Some(2));"] # [doc = " ```"] fn position_min (self) -> Option < usize > where Self : Sized , Self :: Item : Ord { self . enumerate () . min_by (| x , y | Ord :: cmp (& x . 1 , & y . 1)) . map (| x | x . 0) } # [doc = " Return the position of the minimum element in the iterator, as"] # [doc = " determined by the specified function."] # [doc = ""] # [doc = " If several elements are equally minimum, the position of the"] # [doc = " first of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_min_by_key(|x| x.abs()), None);"] # [doc = ""] # [doc = " let a = [-3_i32, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(1));"] # [doc = ""] # [doc = " let a = [1_i32, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_min_by_key(|x| x.abs()), Some(0));"] # [doc = " ```"] fn position_min_by_key < K , F > (self , mut key : F) -> Option < usize > where Self : Sized , K : Ord , F : FnMut (& Self :: Item) -> K { self . enumerate () . min_by (| x , y | Ord :: cmp (& key (& x . 1) , & key (& y . 1))) . map (| x | x . 0) } # [doc = " Return the position of the minimum element in the iterator, as"] # [doc = " determined by the specified comparison function."] # [doc = ""] # [doc = " If several elements are equally minimum, the position of the"] # [doc = " first of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), None);"] # [doc = ""] # [doc = " let a = [-3_i32, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(4));"] # [doc = ""] # [doc = " let a = [1_i32, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_min_by(|x, y| x.cmp(y)), Some(2));"] # [doc = " ```"] fn position_min_by < F > (self , mut compare : F) -> Option < usize > where Self : Sized , F : FnMut (& Self :: Item , & Self :: Item) -> Ordering { self . enumerate () . min_by (| x , y | compare (& x . 1 , & y . 1)) . map (| x | x . 0) } # [doc = " Return the positions of the minimum and maximum elements in"] # [doc = " the iterator."] # [doc = ""] # [doc = " The return type [`MinMaxResult`] is an enum of three variants:"] # [doc = ""] # [doc = " - `NoElements` if the iterator is empty."] # [doc = " - `OneElement(xpos)` if the iterator has exactly one element."] # [doc = " - `MinMax(xpos, ypos)` is returned otherwise, where the"] # [doc = "    element at `xpos`  the element at `ypos`. While the"] # [doc = "    referenced elements themselves may be equal, `xpos` cannot"] # [doc = "    be equal to `ypos`."] # [doc = ""] # [doc = " On an iterator of length `n`, `position_minmax` does `1.5 * n`"] # [doc = " comparisons, and so is faster than calling `positon_min` and"] # [doc = " `position_max` separately which does `2 * n` comparisons."] # [doc = ""] # [doc = " For the minimum, if several elements are equally minimum, the"] # [doc = " position of the first of them is returned. For the maximum, if"] # [doc = " several elements are equally maximum, the position of the last"] # [doc = " of them is returned."] # [doc = ""] # [doc = " The elements can be floats but no particular result is"] # [doc = " guaranteed if an element is NaN."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " use itertools::MinMaxResult::{NoElements, OneElement, MinMax};"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_minmax(), NoElements);"] # [doc = ""] # [doc = " let a = [10];"] # [doc = " assert_eq!(a.iter().position_minmax(), OneElement(0));"] # [doc = ""] # [doc = " let a = [-3, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_minmax(), MinMax(4, 3));"] # [doc = ""] # [doc = " let a = [1, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_minmax(), MinMax(2, 1));"] # [doc = " ```"] # [doc = ""] # [doc = " [`MinMaxResult`]: enum.MinMaxResult.html"] fn position_minmax (self) -> MinMaxResult < usize > where Self : Sized , Self :: Item : PartialOrd { use crate :: MinMaxResult :: { NoElements , OneElement , MinMax } ; match minmax :: minmax_impl (self . enumerate () , | _ | () , | x , y , _ , _ | x . 1 < y . 1) { NoElements => NoElements , OneElement (x) => OneElement (x . 0) , MinMax (x , y) => MinMax (x . 0 , y . 0) , } } # [doc = " Return the postions of the minimum and maximum elements of an"] # [doc = " iterator, as determined by the specified function."] # [doc = ""] # [doc = " The return value is a variant of [`MinMaxResult`] like for"] # [doc = " [`position_minmax`]."] # [doc = ""] # [doc = " For the minimum, if several elements are equally minimum, the"] # [doc = " position of the first of them is returned. For the maximum, if"] # [doc = " several elements are equally maximum, the position of the last"] # [doc = " of them is returned."] # [doc = ""] # [doc = " The keys can be floats but no particular result is guaranteed"] # [doc = " if a key is NaN."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " use itertools::MinMaxResult::{NoElements, OneElement, MinMax};"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), NoElements);"] # [doc = ""] # [doc = " let a = [10_i32];"] # [doc = " assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), OneElement(0));"] # [doc = ""] # [doc = " let a = [-3_i32, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(1, 4));"] # [doc = ""] # [doc = " let a = [1_i32, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_minmax_by_key(|x| x.abs()), MinMax(0, 3));"] # [doc = " ```"] # [doc = ""] # [doc = " [`MinMaxResult`]: enum.MinMaxResult.html"] # [doc = " [`position_minmax`]: #method.position_minmax"] fn position_minmax_by_key < K , F > (self , mut key : F) -> MinMaxResult < usize > where Self : Sized , K : PartialOrd , F : FnMut (& Self :: Item) -> K { use crate :: MinMaxResult :: { NoElements , OneElement , MinMax } ; match self . enumerate () . minmax_by_key (| e | key (& e . 1)) { NoElements => NoElements , OneElement (x) => OneElement (x . 0) , MinMax (x , y) => MinMax (x . 0 , y . 0) , } } # [doc = " Return the postions of the minimum and maximum elements of an"] # [doc = " iterator, as determined by the specified comparison function."] # [doc = ""] # [doc = " The return value is a variant of [`MinMaxResult`] like for"] # [doc = " [`position_minmax`]."] # [doc = ""] # [doc = " For the minimum, if several elements are equally minimum, the"] # [doc = " position of the first of them is returned. For the maximum, if"] # [doc = " several elements are equally maximum, the position of the last"] # [doc = " of them is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = " use itertools::MinMaxResult::{NoElements, OneElement, MinMax};"] # [doc = ""] # [doc = " let a: [i32; 0] = [];"] # [doc = " assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), NoElements);"] # [doc = ""] # [doc = " let a = [10_i32];"] # [doc = " assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), OneElement(0));"] # [doc = ""] # [doc = " let a = [-3_i32, 0, 1, 5, -10];"] # [doc = " assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(4, 3));"] # [doc = ""] # [doc = " let a = [1_i32, 1, -1, -1];"] # [doc = " assert_eq!(a.iter().position_minmax_by(|x, y| x.cmp(y)), MinMax(2, 1));"] # [doc = " ```"] # [doc = ""] # [doc = " [`MinMaxResult`]: enum.MinMaxResult.html"] # [doc = " [`position_minmax`]: #method.position_minmax"] fn position_minmax_by < F > (self , mut compare : F) -> MinMaxResult < usize > where Self : Sized , F : FnMut (& Self :: Item , & Self :: Item) -> Ordering { use crate :: MinMaxResult :: { NoElements , OneElement , MinMax } ; match self . enumerate () . minmax_by (| x , y | compare (& x . 1 , & y . 1)) { NoElements => NoElements , OneElement (x) => OneElement (x . 0) , MinMax (x , y) => MinMax (x . 0 , y . 0) , } } # [doc = " If the iterator yields exactly one element, that element will be returned, otherwise"] # [doc = " an error will be returned containing an iterator that has the same output as the input"] # [doc = " iterator."] # [doc = ""] # [doc = " This provides an additional layer of validation over just calling `Iterator::next()`."] # [doc = " If your assumption that there should only be one element yielded is false this provides"] # [doc = " the opportunity to detect and handle that, preventing errors at a distance."] # [doc = ""] # [doc = " # Examples"] # [doc = " ```"] # [doc = " use itertools::Itertools;"] # [doc = ""] # [doc = " assert_eq!((0..10).filter(|&x| x == 2).exactly_one().unwrap(), 2);"] # [doc = " assert!((0..10).filter(|&x| x > 1 && x < 4).exactly_one().unwrap_err().eq(2..4));"] # [doc = " assert!((0..10).filter(|&x| x > 1 && x < 5).exactly_one().unwrap_err().eq(2..5));"] # [doc = " assert!((0..10).filter(|&_| false).exactly_one().unwrap_err().eq(0..0));"] # [doc = " ```"] fn exactly_one (mut self) -> Result < Self :: Item , ExactlyOneError < Self > > where Self : Sized , { match self . next () { Some (first) => { match self . next () { Some (second) => { Err (ExactlyOneError :: new ((Some (first) , Some (second)) , self)) } None => { Ok (first) } } } None => Err (ExactlyOneError :: new ((None , None) , self)) , } } } impl < T : ? Sized > Itertools for T where T : Iterator { } # [doc = " Return `true` if both iterables produce equal sequences"] # [doc = " (elements pairwise equal and sequences of the same length),"] # [doc = " `false` otherwise."] # [doc = ""] # [doc = " This is an `IntoIterator` enabled function that is similar to the standard"] # [doc = " library method `Iterator::eq`."] # [doc = ""] # [doc = " ```"] # [doc = " assert!(itertools::equal(vec![1, 2, 3], 1..4));"] # [doc = " assert!(!itertools::equal(&[0, 0], &[0, 0, 0]));"] # [doc = " ```"] pub fn equal < I , J > (a : I , b : J) -> bool where I : IntoIterator , J : IntoIterator , I :: Item : PartialEq < J :: Item > { let mut ia = a . into_iter () ; let mut ib = b . into_iter () ; loop { match ia . next () { Some (x) => match ib . next () { Some (y) => if x != y { return false ; } , None => return false , } , None => return ib . next () . is_none () } } } # [doc = " Assert that two iterables produce equal sequences, with the same"] # [doc = " semantics as *equal(a, b)*."] # [doc = ""] # [doc = " **Panics** on assertion failure with a message that shows the"] # [doc = " two iteration elements."] # [doc = ""] # [doc = " ```ignore"] # [doc = " assert_equal(\"exceed\".split('c'), \"excess\".split('c'));"] # [doc = " // ^PANIC: panicked at 'Failed assertion Some(\"eed\") == Some(\"ess\") for iteration 1',"] # [doc = " ```"] pub fn assert_equal < I , J > (a : I , b : J) where I : IntoIterator , J : IntoIterator , I :: Item : fmt :: Debug + PartialEq < J :: Item > , J :: Item : fmt :: Debug , { let mut ia = a . into_iter () ; let mut ib = b . into_iter () ; let mut i = 0 ; loop { match (ia . next () , ib . next ()) { (None , None) => return , (a , b) => { let equal = match (& a , & b) { (& Some (ref a) , & Some (ref b)) => a == b , _ => false , } ; assert ! (equal , "Failed assertion {a:?} == {b:?} for iteration {i}" , i = i , a = a , b = b) ; i += 1 ; } } } } # [doc = " Partition a sequence using predicate `pred` so that elements"] # [doc = " that map to `true` are placed before elements which map to `false`."] # [doc = ""] # [doc = " The order within the partitions is arbitrary."] # [doc = ""] # [doc = " Return the index of the split point."] # [doc = ""] # [doc = " ```"] # [doc = " use itertools::partition;"] # [doc = ""] # [doc = " # // use repeated numbers to not promise any ordering"] # [doc = " let mut data = [7, 1, 1, 7, 1, 1, 7];"] # [doc = " let split_index = partition(&mut data, |elt| *elt >= 3);"] # [doc = ""] # [doc = " assert_eq!(data, [7, 7, 7, 1, 1, 1, 1]);"] # [doc = " assert_eq!(split_index, 3);"] # [doc = " ```"] pub fn partition < 'a , A : 'a , I , F > (iter : I , mut pred : F) -> usize where I : IntoIterator < Item = & 'a mut A > , I :: IntoIter : DoubleEndedIterator , F : FnMut (& A) -> bool { let mut split_index = 0 ; let mut iter = iter . into_iter () ; 'main : while let Some (front) = iter . next () { if ! pred (front) { loop { match iter . next_back () { Some (back) => if pred (back) { std :: mem :: swap (front , back) ; break ; } , None => break 'main , } } } split_index += 1 ; } split_index } # [doc = " An enum used for controlling the execution of `.fold_while()`."] # [doc = ""] # [doc = " See [`.fold_while()`](trait.Itertools.html#method.fold_while) for more information."] # [derive (Copy , Clone , Debug , Eq , PartialEq)] pub enum FoldWhile < T > { # [doc = " Continue folding with this value"] Continue (T) , # [doc = " Fold is complete and will return this value"] Done (T) , } impl < T > FoldWhile < T > { # [doc = " Return the value in the continue or done."] pub fn into_inner (self) -> T { match self { FoldWhile :: Continue (x) | FoldWhile :: Done (x) => x , } } # [doc = " Return true if `self` is `Done`, false if it is `Continue`."] pub fn is_done (& self) -> bool { match * self { FoldWhile :: Continue (_) => false , FoldWhile :: Done (_) => true , } } } }mod lazy_static { # ! [doc = "\nA macro for declaring lazily evaluated statics.\n\nUsing this macro, it is possible to have `static`s that require code to be\nexecuted at runtime in order to be initialized.\nThis includes anything requiring heap allocations, like vectors or hash maps,\nas well as anything that requires function calls to be computed.\n\n# Syntax\n\n```ignore\nlazy_static! {\n    [pub] static ref NAME_1: TYPE_1 = EXPR_1;\n    [pub] static ref NAME_2: TYPE_2 = EXPR_2;\n    ...\n    [pub] static ref NAME_N: TYPE_N = EXPR_N;\n}\n```\n\nAttributes (including doc comments) are supported as well:\n\n```rust\n# #[macro_use]\n# extern crate lazy_static;\n# fn main() {\nlazy_static! {\n    /// This is an example for using doc comment attributes\n    static ref EXAMPLE: u8 = 42;\n}\n# }\n```\n\n# Semantics\n\nFor a given `static ref NAME: TYPE = EXPR;`, the macro generates a unique type that\nimplements `Deref<TYPE>` and stores it in a static with name `NAME`. (Attributes end up\nattaching to this type.)\n\nOn first deref, `EXPR` gets evaluated and stored internally, such that all further derefs\ncan return a reference to the same object. Note that this can lead to deadlocks\nif you have multiple lazy statics that depend on each other in their initialization.\n\nApart from the lazy initialization, the resulting \"static ref\" variables\nhave generally the same properties as regular \"static\" variables:\n\n- Any type in them needs to fulfill the `Sync` trait.\n- If the type has a destructor, then it will not run when the process exits.\n\n# Example\n\nUsing the macro:\n\n```rust\n#[macro_use]\nextern crate lazy_static;\n\nuse std::collections::HashMap;\n\nlazy_static! {\n    static ref HASHMAP: HashMap<u32, &'static str> = {\n        let mut m = HashMap::new();\n        m.insert(0, \"foo\");\n        m.insert(1, \"bar\");\n        m.insert(2, \"baz\");\n        m\n    };\n    static ref COUNT: usize = HASHMAP.len();\n    static ref NUMBER: u32 = times_two(21);\n}\n\nfn times_two(n: u32) -> u32 { n * 2 }\n\nfn main() {\n    println!(\"The map has {} entries.\", *COUNT);\n    println!(\"The entry for `0` is \\\"{}\\\".\", HASHMAP.get(&0).unwrap());\n    println!(\"A expensive calculation on a static results in: {}.\", *NUMBER);\n}\n```\n\n# Implementation details\n\nThe `Deref` implementation uses a hidden static variable that is guarded by an atomic check on each access.\n\n# Cargo features\n\nThis crate provides one cargo feature:\n\n- `spin_no_std`: This allows using this crate in a no-std environment, by depending on the standalone `spin` crate.\n\n"] # ! [doc (html_root_url = "https://docs.rs/lazy_static/1.4.0")] # ! [no_std] # [cfg (not (feature = "spin_no_std"))] # [path = "inline_lazy.rs"] # [doc (hidden)] pub mod lazy { extern crate core ; extern crate std ; use self :: std :: prelude :: v1 :: * ; use self :: std :: cell :: Cell ; use self :: std :: hint :: unreachable_unchecked ; use self :: std :: sync :: Once ; # [allow (deprecated)] pub use self :: std :: sync :: ONCE_INIT ; pub struct Lazy < T : Sync > (Cell < Option < T > > , Once) ; impl < T : Sync > Lazy < T > { # [allow (deprecated)] pub const INIT : Self = Lazy (Cell :: new (None) , ONCE_INIT) ; # [inline (always)] pub fn get < F > (& 'static self , f : F) -> & T where F : FnOnce () -> T , { self . 1 . call_once (| | { self . 0 . set (Some (f ())) ; }) ; unsafe { match * self . 0 . as_ptr () { Some (ref x) => x , None => { debug_assert ! (false , "attempted to derefence an uninitialized lazy static. This is a bug") ; unreachable_unchecked () } , } } } } unsafe impl < T : Sync > Sync for Lazy < T > { } # [macro_export] # [doc (hidden)] macro_rules ! __lazy_static_create { ($ NAME : ident , $ T : ty) => { static $ NAME : $ crate :: lazy :: Lazy <$ T > = $ crate :: lazy :: Lazy :: INIT ; } ; } } # [cfg (test)] # [macro_use] extern crate doc_comment ; # [cfg (test)] doctest ! ("../README.md") ; # [cfg (feature = "spin_no_std")] # [path = "core_lazy.rs"] # [doc (hidden)] pub mod lazy { extern crate spin ; use self :: spin :: Once ; pub struct Lazy < T : Sync > (Once < T >) ; impl < T : Sync > Lazy < T > { pub const INIT : Self = Lazy (Once :: INIT) ; # [inline (always)] pub fn get < F > (& 'static self , builder : F) -> & T where F : FnOnce () -> T { self . 0 . call_once (builder) } } # [macro_export] # [doc (hidden)] macro_rules ! __lazy_static_create { ($ NAME : ident , $ T : ty) => { static $ NAME : $ crate :: lazy :: Lazy <$ T > = $ crate :: lazy :: Lazy :: INIT ; } } } # [doc (hidden)] pub use core :: ops :: Deref as __Deref ; # [macro_export (local_inner_macros)] # [doc (hidden)] macro_rules ! __lazy_static_internal { ($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty = $ e : expr ; $ ($ t : tt) *) => { __lazy_static_internal ! (@ MAKE TY , $ (# [$ attr]) *, ($ ($ vis) *) , $ N) ; __lazy_static_internal ! (@ TAIL , $ N : $ T = $ e) ; lazy_static ! ($ ($ t) *) ; } ; (@ TAIL , $ N : ident : $ T : ty = $ e : expr) => { impl $ crate :: __Deref for $ N { type Target = $ T ; fn deref (& self) -> &$ T { # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } # [inline (always)] fn __stability () -> &'static $ T { __lazy_static_create ! (LAZY , $ T) ; LAZY . get (__static_ref_initialize) } __stability () } } impl $ crate :: LazyStatic for $ N { fn initialize (lazy : & Self) { let _ = &** lazy ; } } } ; (@ MAKE TY , $ (# [$ attr : meta]) *, ($ ($ vis : tt) *) , $ N : ident) => { # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)] # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $ N { __private_field : () } ; } ; () => () } # [macro_export (local_inner_macros)] macro_rules ! lazy_static { ($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $ ($ t : tt) *) => { __lazy_static_internal ! ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ; } ; ($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ; $ ($ t : tt) *) => { __lazy_static_internal ! ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ; } ; ($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T : ty = $ e : expr ; $ ($ t : tt) *) => { __lazy_static_internal ! ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t) *) ; } ; () => () } # [doc = " Support trait for enabling a few common operation on lazy static values."] # [doc = ""] # [doc = " This is implemented by each defined lazy static, and"] # [doc = " used by the free functions in this crate."] pub trait LazyStatic { # [doc (hidden)] fn initialize (lazy : & Self) ; } # [doc = " Takes a shared reference to a lazy static and initializes"] # [doc = " it if it has not been already."] # [doc = ""] # [doc = " This can be used to control the initialization point of a lazy static."] # [doc = ""] # [doc = " Example:"] # [doc = ""] # [doc = " ```rust"] # [doc = " #[macro_use]"] # [doc = " extern crate lazy_static;"] # [doc = ""] # [doc = " lazy_static! {"] # [doc = "     static ref BUFFER: Vec<u8> = (0..255).collect();"] # [doc = " }"] # [doc = ""] # [doc = " fn main() {"] # [doc = "     lazy_static::initialize(&BUFFER);"] # [doc = ""] # [doc = "     // ..."] # [doc = "     work_with_initialized_data(&BUFFER);"] # [doc = " }"] # [doc = " # fn work_with_initialized_data(_: &[u8]) {}"] # [doc = " ```"] pub fn initialize < T : LazyStatic > (lazy : & T) { LazyStatic :: initialize (lazy) ; } }mod num_bigint { # ! [doc = " A Big integer (signed version: `BigInt`, unsigned version: `BigUint`)."] # ! [doc = ""] # ! [doc = " A `BigUint` is represented as a vector of `BigDigit`s."] # ! [doc = " A `BigInt` is a combination of `BigUint` and `Sign`."] # ! [doc = ""] # ! [doc = " Common numerical operations are overloaded, so we can treat them"] # ! [doc = " the same way we treat other numbers."] # ! [doc = ""] # ! [doc = " ## Example"] # ! [doc = ""] # ! [doc = " ```rust"] # ! [doc = " extern crate num_bigint;"] # ! [doc = " extern crate num_traits;"] # ! [doc = ""] # ! [doc = " # fn main() {"] # ! [doc = " use num_bigint::BigUint;"] # ! [doc = " use num_traits::{Zero, One};"] # ! [doc = " use std::mem::replace;"] # ! [doc = ""] # ! [doc = " // Calculate large fibonacci numbers."] # ! [doc = " fn fib(n: usize) -> BigUint {"] # ! [doc = "     let mut f0: BigUint = Zero::zero();"] # ! [doc = "     let mut f1: BigUint = One::one();"] # ! [doc = "     for _ in 0..n {"] # ! [doc = "         let f2 = f0 + &f1;"] # ! [doc = "         // This is a low cost way of swapping f0 with f1 and f1 with f2."] # ! [doc = "         f0 = replace(&mut f1, f2);"] # ! [doc = "     }"] # ! [doc = "     f0"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // This is a very large number."] # ! [doc = " println!(\"fib(1000) = {}\", fib(1000));"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " It's easy to generate large random numbers:"] # ! [doc = ""] # ! [doc = " ```rust"] # ! [doc = " # #[cfg(feature = \"rand\")]"] # ! [doc = " extern crate rand;"] # ! [doc = " extern crate num_bigint as bigint;"] # ! [doc = ""] # ! [doc = " # #[cfg(feature = \"rand\")]"] # ! [doc = " # fn main() {"] # ! [doc = " use bigint::{ToBigInt, RandBigInt};"] # ! [doc = ""] # ! [doc = " let mut rng = rand::thread_rng();"] # ! [doc = " let a = rng.gen_bigint(1000);"] # ! [doc = ""] # ! [doc = " let low = -10000.to_bigint().unwrap();"] # ! [doc = " let high = 10000.to_bigint().unwrap();"] # ! [doc = " let b = rng.gen_bigint_range(&low, &high);"] # ! [doc = ""] # ! [doc = " // Probably an even larger number."] # ! [doc = " println!(\"{}\", a * b);"] # ! [doc = " # }"] # ! [doc = ""] # ! [doc = " # #[cfg(not(feature = \"rand\"))]"] # ! [doc = " # fn main() {"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " See the \"Features\" section for instructions for enabling random number generation."] # ! [doc = ""] # ! [doc = " ## Features"] # ! [doc = ""] # ! [doc = " The `std` crate feature is mandatory and enabled by default.  If you depend on"] # ! [doc = " `num-bigint` with `default-features = false`, you must manually enable the"] # ! [doc = " `std` feature yourself.  In the future, we hope to support `#![no_std]` with"] # ! [doc = " the `alloc` crate when `std` is not enabled."] # ! [doc = ""] # ! [doc = " Implementations for `i128` and `u128` are only available with Rust 1.26 and"] # ! [doc = " later.  The build script automatically detects this, but you can make it"] # ! [doc = " mandatory by enabling the `i128` crate feature."] # ! [doc = ""] # ! [doc = " ### Random Generation"] # ! [doc = ""] # ! [doc = " `num-bigint` supports the generation of random big integers when the `rand`"] # ! [doc = " feature is enabled. To enable it include rand as"] # ! [doc = ""] # ! [doc = " ```toml"] # ! [doc = " rand = \"0.5\""] # ! [doc = " num-bigint = { version = \"0.2\", features = [\"rand\"] }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " Note that you must use the version of `rand` that `num-bigint` is compatible"] # ! [doc = " with: `0.5`."] # ! [doc = ""] # ! [doc = ""] # ! [doc = " ## Compatibility"] # ! [doc = ""] # ! [doc = " The `num-bigint` crate is tested for rustc 1.15 and greater."] # ! [doc (html_root_url = "https://docs.rs/num-bigint/0.2")] # ! [cfg_attr (not (feature = "std") , no_std)] # [cfg (feature = "rand")] extern crate rand ; # [cfg (feature = "serde")] extern crate serde ; extern crate num_integer as integer ; extern crate num_traits as traits ; # [cfg (feature = "quickcheck")] extern crate quickcheck ; use std :: error :: Error ; use std :: fmt ; # [macro_use] mod macros { macro_rules ! forward_val_val_binop { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl $ imp <$ res > for $ res { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (self , & other) } } } ; } macro_rules ! forward_val_val_binop_commutative { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl $ imp <$ res > for $ res { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { if self . capacity () >= other . capacity () { $ imp ::$ method (self , & other) } else { $ imp ::$ method (other , & self) } } } } ; } macro_rules ! forward_ref_val_binop { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl <'a > $ imp <$ res > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (self , & other) } } } ; } macro_rules ! forward_ref_val_binop_commutative { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl <'a > $ imp <$ res > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (other , self) } } } ; } macro_rules ! forward_val_ref_binop { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl <'a > $ imp <&'a $ res > for $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ res) -> $ res { $ imp ::$ method (& self , other) } } } ; } macro_rules ! forward_ref_ref_binop { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl <'a , 'b > $ imp <&'b $ res > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ res) -> $ res { $ imp ::$ method (self . clone () , other) } } } ; } macro_rules ! forward_ref_ref_binop_commutative { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl <'a , 'b > $ imp <&'b $ res > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ res) -> $ res { if self . len () >= other . len () { $ imp ::$ method (self . clone () , other) } else { $ imp ::$ method (other . clone () , self) } } } } ; } macro_rules ! forward_val_assign { (impl $ imp : ident for $ res : ty , $ method : ident) => { impl $ imp <$ res > for $ res { # [inline] fn $ method (& mut self , other : $ res) { self .$ method (& other) ; } } } ; } macro_rules ! forward_val_assign_scalar { (impl $ imp : ident for $ res : ty , $ scalar : ty , $ method : ident) => { impl $ imp <$ res > for $ scalar { # [inline] fn $ method (& mut self , other : $ res) { self .$ method (& other) ; } } } ; } # [doc = " use this if val_val_binop is already implemented and the reversed order is required"] macro_rules ! forward_scalar_val_val_binop_commutative { (impl $ imp : ident < $ scalar : ty > for $ res : ty , $ method : ident) => { impl $ imp <$ res > for $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (other , self) } } } ; } macro_rules ! forward_scalar_val_val_binop_to_ref_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { impl $ imp <$ scalar > for $ res { type Output = $ res ; # [inline] fn $ method (self , other : $ scalar) -> $ res { $ imp ::$ method (& self , other) } } impl $ imp <$ res > for $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (self , & other) } } } ; } macro_rules ! forward_scalar_ref_ref_binop_to_ref_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { impl <'a , 'b > $ imp <&'b $ scalar > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ scalar) -> $ res { $ imp ::$ method (self , * other) } } impl <'a , 'b > $ imp <&'a $ res > for &'b $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : &$ res) -> $ res { $ imp ::$ method (* self , other) } } } ; } macro_rules ! forward_scalar_val_ref_binop_to_ref_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { impl <'a > $ imp <&'a $ scalar > for $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ scalar) -> $ res { $ imp ::$ method (& self , * other) } } impl <'a > $ imp <$ res > for &'a $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (* self , & other) } } } ; } macro_rules ! forward_scalar_val_ref_binop_to_val_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { impl <'a > $ imp <&'a $ scalar > for $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ scalar) -> $ res { $ imp ::$ method (self , * other) } } impl <'a > $ imp <$ res > for &'a $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (* self , other) } } } ; } macro_rules ! forward_scalar_ref_val_binop_to_val_val { (impl $ imp : ident < $ scalar : ty > for $ res : ty , $ method : ident) => { impl <'a > $ imp <$ scalar > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : $ scalar) -> $ res { $ imp ::$ method (self . clone () , other) } } impl <'a > $ imp <&'a $ res > for $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : &$ res) -> $ res { $ imp ::$ method (self , other . clone ()) } } } ; } macro_rules ! forward_scalar_ref_ref_binop_to_val_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { impl <'a , 'b > $ imp <&'b $ scalar > for &'a $ res { type Output = $ res ; # [inline] fn $ method (self , other : &$ scalar) -> $ res { $ imp ::$ method (self . clone () , * other) } } impl <'a , 'b > $ imp <&'a $ res > for &'b $ scalar { type Output = $ res ; # [inline] fn $ method (self , other : &$ res) -> $ res { $ imp ::$ method (* self , other . clone ()) } } } ; } macro_rules ! promote_scalars { (impl $ imp : ident <$ promo : ty > for $ res : ty , $ method : ident , $ ($ scalar : ty) ,*) => { $ (forward_all_scalar_binop_to_val_val ! (impl $ imp <$ scalar > for $ res , $ method) ; impl $ imp <$ scalar > for $ res { type Output = $ res ; # [cfg_attr (feature = "cargo-clippy" , allow (renamed_and_removed_lints))] # [cfg_attr (feature = "cargo-clippy" , allow (cast_lossless))] # [inline] fn $ method (self , other : $ scalar) -> $ res { $ imp ::$ method (self , other as $ promo) } } impl $ imp <$ res > for $ scalar { type Output = $ res ; # [cfg_attr (feature = "cargo-clippy" , allow (renamed_and_removed_lints))] # [cfg_attr (feature = "cargo-clippy" , allow (cast_lossless))] # [inline] fn $ method (self , other : $ res) -> $ res { $ imp ::$ method (self as $ promo , other) } }) * } } macro_rules ! promote_scalars_assign { (impl $ imp : ident <$ promo : ty > for $ res : ty , $ method : ident , $ ($ scalar : ty) ,*) => { $ (impl $ imp <$ scalar > for $ res { # [cfg_attr (feature = "cargo-clippy" , allow (renamed_and_removed_lints))] # [cfg_attr (feature = "cargo-clippy" , allow (cast_lossless))] # [inline] fn $ method (& mut self , other : $ scalar) { self .$ method (other as $ promo) ; } }) * } } macro_rules ! promote_unsigned_scalars { (impl $ imp : ident for $ res : ty , $ method : ident) => { promote_scalars ! (impl $ imp < u32 > for $ res , $ method , u8 , u16) ; promote_scalars ! (impl $ imp < UsizePromotion > for $ res , $ method , usize) ; } } macro_rules ! promote_unsigned_scalars_assign { (impl $ imp : ident for $ res : ty , $ method : ident) => { promote_scalars_assign ! (impl $ imp < u32 > for $ res , $ method , u8 , u16) ; promote_scalars_assign ! (impl $ imp < UsizePromotion > for $ res , $ method , usize) ; } } macro_rules ! promote_signed_scalars { (impl $ imp : ident for $ res : ty , $ method : ident) => { promote_scalars ! (impl $ imp < i32 > for $ res , $ method , i8 , i16) ; promote_scalars ! (impl $ imp < IsizePromotion > for $ res , $ method , isize) ; } } macro_rules ! promote_signed_scalars_assign { (impl $ imp : ident for $ res : ty , $ method : ident) => { promote_scalars_assign ! (impl $ imp < i32 > for $ res , $ method , i8 , i16) ; promote_scalars_assign ! (impl $ imp < IsizePromotion > for $ res , $ method , isize) ; } } macro_rules ! forward_all_binop_to_ref_ref { (impl $ imp : ident for $ res : ty , $ method : ident) => { forward_val_val_binop ! (impl $ imp for $ res , $ method) ; forward_val_ref_binop ! (impl $ imp for $ res , $ method) ; forward_ref_val_binop ! (impl $ imp for $ res , $ method) ; } ; } macro_rules ! forward_all_binop_to_val_ref { (impl $ imp : ident for $ res : ty , $ method : ident) => { forward_val_val_binop ! (impl $ imp for $ res , $ method) ; forward_ref_val_binop ! (impl $ imp for $ res , $ method) ; forward_ref_ref_binop ! (impl $ imp for $ res , $ method) ; } ; } macro_rules ! forward_all_binop_to_val_ref_commutative { (impl $ imp : ident for $ res : ty , $ method : ident) => { forward_val_val_binop_commutative ! (impl $ imp for $ res , $ method) ; forward_ref_val_binop_commutative ! (impl $ imp for $ res , $ method) ; forward_ref_ref_binop_commutative ! (impl $ imp for $ res , $ method) ; } ; } macro_rules ! forward_all_scalar_binop_to_ref_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { forward_scalar_val_val_binop_to_ref_val ! (impl $ imp <$ scalar > for $ res , $ method) ; forward_scalar_val_ref_binop_to_ref_val ! (impl $ imp <$ scalar > for $ res , $ method) ; forward_scalar_ref_ref_binop_to_ref_val ! (impl $ imp <$ scalar > for $ res , $ method) ; } } macro_rules ! forward_all_scalar_binop_to_val_val { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { forward_scalar_val_ref_binop_to_val_val ! (impl $ imp <$ scalar > for $ res , $ method) ; forward_scalar_ref_val_binop_to_val_val ! (impl $ imp <$ scalar > for $ res , $ method) ; forward_scalar_ref_ref_binop_to_val_val ! (impl $ imp <$ scalar > for $ res , $ method) ; } } macro_rules ! forward_all_scalar_binop_to_val_val_commutative { (impl $ imp : ident <$ scalar : ty > for $ res : ty , $ method : ident) => { forward_scalar_val_val_binop_commutative ! (impl $ imp <$ scalar > for $ res , $ method) ; forward_all_scalar_binop_to_val_val ! (impl $ imp <$ scalar > for $ res , $ method) ; } } macro_rules ! promote_all_scalars { (impl $ imp : ident for $ res : ty , $ method : ident) => { promote_unsigned_scalars ! (impl $ imp for $ res , $ method) ; promote_signed_scalars ! (impl $ imp for $ res , $ method) ; } } macro_rules ! promote_all_scalars_assign { (impl $ imp : ident for $ res : ty , $ method : ident) => { promote_unsigned_scalars_assign ! (impl $ imp for $ res , $ method) ; promote_signed_scalars_assign ! (impl $ imp for $ res , $ method) ; } } macro_rules ! impl_sum_iter_type { ($ res : ty) => { impl < T > Sum < T > for $ res where $ res : Add < T , Output = $ res >, { fn sum < I > (iter : I) -> Self where I : Iterator < Item = T >, { iter . fold (Zero :: zero () , <$ res >:: add) } } } ; } macro_rules ! impl_product_iter_type { ($ res : ty) => { impl < T > Product < T > for $ res where $ res : Mul < T , Output = $ res >, { fn product < I > (iter : I) -> Self where I : Iterator < Item = T >, { iter . fold (One :: one () , <$ res >:: mul) } } } ; } } mod bigint { # [allow (deprecated , unused_imports)] use std :: ascii :: AsciiExt ; use std :: cmp :: Ordering :: { self , Equal , Greater , Less } ; use std :: default :: Default ; use std :: fmt ; use std :: iter :: { Product , Sum } ; use std :: mem ; use std :: ops :: { Add , AddAssign , BitAnd , BitAndAssign , BitOr , BitOrAssign , BitXor , BitXorAssign , Div , DivAssign , Mul , MulAssign , Neg , Not , Rem , RemAssign , Shl , ShlAssign , Shr , ShrAssign , Sub , SubAssign , } ; use std :: str :: { self , FromStr } ; # [cfg (has_i128)] use std :: { i128 , u128 } ; use std :: { i64 , u64 } ; # [cfg (feature = "serde")] use serde ; use integer :: { Integer , Roots } ; use traits :: { CheckedAdd , CheckedDiv , CheckedMul , CheckedSub , FromPrimitive , Num , One , Pow , Signed , ToPrimitive , Zero , } ; use self :: Sign :: { Minus , NoSign , Plus } ; use super :: ParseBigIntError ; use big_digit :: { self , BigDigit , DoubleBigDigit } ; use biguint ; use biguint :: to_str_radix_reversed ; use biguint :: { BigUint , IntDigits } ; use IsizePromotion ; use UsizePromotion ; # [cfg (feature = "quickcheck")] use quickcheck :: { Arbitrary , Gen } ; # [doc = " A Sign is a `BigInt`'s composing element."] # [derive (PartialEq , PartialOrd , Eq , Ord , Copy , Clone , Debug , Hash)] pub enum Sign { Minus , NoSign , Plus , } impl Neg for Sign { type Output = Sign ; # [doc = " Negate Sign value."] # [inline] fn neg (self) -> Sign { match self { Minus => Plus , NoSign => NoSign , Plus => Minus , } } } impl Mul < Sign > for Sign { type Output = Sign ; # [inline] fn mul (self , other : Sign) -> Sign { match (self , other) { (NoSign , _) | (_ , NoSign) => NoSign , (Plus , Plus) | (Minus , Minus) => Plus , (Plus , Minus) | (Minus , Plus) => Minus , } } } # [cfg (feature = "serde")] impl serde :: Serialize for Sign { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : serde :: Serializer , { match * self { Sign :: Minus => (- 1i8) . serialize (serializer) , Sign :: NoSign => 0i8 . serialize (serializer) , Sign :: Plus => 1i8 . serialize (serializer) , } } } # [cfg (feature = "serde")] impl < 'de > serde :: Deserialize < 'de > for Sign { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : serde :: Deserializer < 'de > , { use serde :: de :: Error ; use serde :: de :: Unexpected ; let sign : i8 = serde :: Deserialize :: deserialize (deserializer) ? ; match sign { - 1 => Ok (Sign :: Minus) , 0 => Ok (Sign :: NoSign) , 1 => Ok (Sign :: Plus) , _ => Err (D :: Error :: invalid_value (Unexpected :: Signed (sign . into ()) , & "a sign of -1, 0, or 1" ,)) , } } } # [doc = " A big signed integer type."] # [derive (Clone , Debug , Hash)] pub struct BigInt { sign : Sign , data : BigUint , } # [cfg (feature = "quickcheck")] impl Arbitrary for BigInt { fn arbitrary < G : Gen > (g : & mut G) -> Self { let positive = bool :: arbitrary (g) ; let sign = if positive { Sign :: Plus } else { Sign :: Minus } ; Self :: from_biguint (sign , BigUint :: arbitrary (g)) } # [allow (bare_trait_objects)] fn shrink (& self) -> Box < Iterator < Item = Self > > { let sign = self . sign () ; let unsigned_shrink = self . data . shrink () ; Box :: new (unsigned_shrink . map (move | x | BigInt :: from_biguint (sign , x))) } } # [doc = " Return the magnitude of a `BigInt`."] # [doc = ""] # [doc = " This is in a private module, pseudo pub(crate)"] # [cfg (feature = "rand")] pub fn magnitude (i : & BigInt) -> & BigUint { & i . data } # [doc = " Return the owned magnitude of a `BigInt`."] # [doc = ""] # [doc = " This is in a private module, pseudo pub(crate)"] # [cfg (feature = "rand")] pub fn into_magnitude (i : BigInt) -> BigUint { i . data } impl PartialEq for BigInt { # [inline] fn eq (& self , other : & BigInt) -> bool { self . cmp (other) == Equal } } impl Eq for BigInt { } impl PartialOrd for BigInt { # [inline] fn partial_cmp (& self , other : & BigInt) -> Option < Ordering > { Some (self . cmp (other)) } } impl Ord for BigInt { # [inline] fn cmp (& self , other : & BigInt) -> Ordering { let scmp = self . sign . cmp (& other . sign) ; if scmp != Equal { return scmp ; } match self . sign { NoSign => Equal , Plus => self . data . cmp (& other . data) , Minus => other . data . cmp (& self . data) , } } } impl Default for BigInt { # [inline] fn default () -> BigInt { Zero :: zero () } } impl fmt :: Display for BigInt { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (! self . is_negative () , "" , & self . data . to_str_radix (10)) } } impl fmt :: Binary for BigInt { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (! self . is_negative () , "0b" , & self . data . to_str_radix (2)) } } impl fmt :: Octal for BigInt { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (! self . is_negative () , "0o" , & self . data . to_str_radix (8)) } } impl fmt :: LowerHex for BigInt { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (! self . is_negative () , "0x" , & self . data . to_str_radix (16)) } } impl fmt :: UpperHex for BigInt { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { let mut s = self . data . to_str_radix (16) ; s . make_ascii_uppercase () ; f . pad_integral (! self . is_negative () , "0x" , & s) } } # [inline] fn negate_carry (a : BigDigit , acc : & mut DoubleBigDigit) -> BigDigit { * acc += DoubleBigDigit :: from (! a) ; let lo = * acc as BigDigit ; * acc >>= big_digit :: BITS ; lo } impl Not for BigInt { type Output = BigInt ; fn not (mut self) -> BigInt { match self . sign { NoSign | Plus => { self . data += 1u32 ; self . sign = Minus ; } Minus => { self . data -= 1u32 ; self . sign = if self . data . is_zero () { NoSign } else { Plus } ; } } self } } impl < 'a > Not for & 'a BigInt { type Output = BigInt ; fn not (self) -> BigInt { match self . sign { NoSign | Plus => BigInt :: from_biguint (Minus , & self . data + 1u32) , Minus => BigInt :: from_biguint (Plus , & self . data - 1u32) , } } } fn bitand_pos_neg (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_b = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_b = negate_carry (bi , & mut carry_b) ; * ai &= twos_b ; } debug_assert ! (b . len () > a . len () || carry_b == 0) ; } fn bitand_neg_pos (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_a = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_a = negate_carry (* ai , & mut carry_a) ; * ai = twos_a & bi ; } debug_assert ! (a . len () > b . len () || carry_a == 0) ; if a . len () > b . len () { a . truncate (b . len ()) ; } else if b . len () > a . len () { let extra = & b [a . len () ..] ; a . extend (extra . iter () . cloned ()) ; } } fn bitand_neg_neg (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_a = 1 ; let mut carry_b = 1 ; let mut carry_and = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_a = negate_carry (* ai , & mut carry_a) ; let twos_b = negate_carry (bi , & mut carry_b) ; * ai = negate_carry (twos_a & twos_b , & mut carry_and) ; } debug_assert ! (a . len () > b . len () || carry_a == 0) ; debug_assert ! (b . len () > a . len () || carry_b == 0) ; if a . len () > b . len () { for ai in a [b . len () ..] . iter_mut () { let twos_a = negate_carry (* ai , & mut carry_a) ; * ai = negate_carry (twos_a , & mut carry_and) ; } debug_assert ! (carry_a == 0) ; } else if b . len () > a . len () { let extra = & b [a . len () ..] ; a . extend (extra . iter () . map (| & bi | { let twos_b = negate_carry (bi , & mut carry_b) ; negate_carry (twos_b , & mut carry_and) })) ; debug_assert ! (carry_b == 0) ; } if carry_and != 0 { a . push (1) ; } } forward_val_val_binop ! (impl BitAnd for BigInt , bitand) ; forward_ref_val_binop ! (impl BitAnd for BigInt , bitand) ; impl < 'a , 'b > BitAnd < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn bitand (self , other : & BigInt) -> BigInt { match (self . sign , other . sign) { (NoSign , _) | (_ , NoSign) => BigInt :: from_slice (NoSign , & []) , (Plus , Plus) => BigInt :: from_biguint (Plus , & self . data & & other . data) , (Plus , Minus) => self . clone () & other , (Minus , Plus) => other . clone () & self , (Minus , Minus) => { if self . len () >= other . len () { self . clone () & other } else { other . clone () & self } } } } } impl < 'a > BitAnd < & 'a BigInt > for BigInt { type Output = BigInt ; # [inline] fn bitand (mut self , other : & BigInt) -> BigInt { self &= other ; self } } forward_val_assign ! (impl BitAndAssign for BigInt , bitand_assign) ; impl < 'a > BitAndAssign < & 'a BigInt > for BigInt { fn bitand_assign (& mut self , other : & BigInt) { match (self . sign , other . sign) { (NoSign , _) => { } (_ , NoSign) => self . assign_from_slice (NoSign , & []) , (Plus , Plus) => { self . data &= & other . data ; if self . data . is_zero () { self . sign = NoSign ; } } (Plus , Minus) => { bitand_pos_neg (self . digits_mut () , other . digits ()) ; self . normalize () ; } (Minus , Plus) => { bitand_neg_pos (self . digits_mut () , other . digits ()) ; self . sign = Plus ; self . normalize () ; } (Minus , Minus) => { bitand_neg_neg (self . digits_mut () , other . digits ()) ; self . normalize () ; } } } } fn bitor_pos_neg (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_b = 1 ; let mut carry_or = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_b = negate_carry (bi , & mut carry_b) ; * ai = negate_carry (* ai | twos_b , & mut carry_or) ; } debug_assert ! (b . len () > a . len () || carry_b == 0) ; if a . len () > b . len () { a . truncate (b . len ()) ; } else if b . len () > a . len () { let extra = & b [a . len () ..] ; a . extend (extra . iter () . map (| & bi | { let twos_b = negate_carry (bi , & mut carry_b) ; negate_carry (twos_b , & mut carry_or) })) ; debug_assert ! (carry_b == 0) ; } debug_assert ! (carry_or == 0) ; } fn bitor_neg_pos (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_a = 1 ; let mut carry_or = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_a = negate_carry (* ai , & mut carry_a) ; * ai = negate_carry (twos_a | bi , & mut carry_or) ; } debug_assert ! (a . len () > b . len () || carry_a == 0) ; if a . len () > b . len () { for ai in a [b . len () ..] . iter_mut () { let twos_a = negate_carry (* ai , & mut carry_a) ; * ai = negate_carry (twos_a , & mut carry_or) ; } debug_assert ! (carry_a == 0) ; } debug_assert ! (carry_or == 0) ; } fn bitor_neg_neg (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_a = 1 ; let mut carry_b = 1 ; let mut carry_or = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_a = negate_carry (* ai , & mut carry_a) ; let twos_b = negate_carry (bi , & mut carry_b) ; * ai = negate_carry (twos_a | twos_b , & mut carry_or) ; } debug_assert ! (a . len () > b . len () || carry_a == 0) ; debug_assert ! (b . len () > a . len () || carry_b == 0) ; if a . len () > b . len () { a . truncate (b . len ()) ; } debug_assert ! (carry_or == 0) ; } forward_val_val_binop ! (impl BitOr for BigInt , bitor) ; forward_ref_val_binop ! (impl BitOr for BigInt , bitor) ; impl < 'a , 'b > BitOr < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn bitor (self , other : & BigInt) -> BigInt { match (self . sign , other . sign) { (NoSign , _) => other . clone () , (_ , NoSign) => self . clone () , (Plus , Plus) => BigInt :: from_biguint (Plus , & self . data | & other . data) , (Plus , Minus) => other . clone () | self , (Minus , Plus) => self . clone () | other , (Minus , Minus) => { if self . len () <= other . len () { self . clone () | other } else { other . clone () | self } } } } } impl < 'a > BitOr < & 'a BigInt > for BigInt { type Output = BigInt ; # [inline] fn bitor (mut self , other : & BigInt) -> BigInt { self |= other ; self } } forward_val_assign ! (impl BitOrAssign for BigInt , bitor_assign) ; impl < 'a > BitOrAssign < & 'a BigInt > for BigInt { fn bitor_assign (& mut self , other : & BigInt) { match (self . sign , other . sign) { (_ , NoSign) => { } (NoSign , _) => self . assign_from_slice (other . sign , other . digits ()) , (Plus , Plus) => self . data |= & other . data , (Plus , Minus) => { bitor_pos_neg (self . digits_mut () , other . digits ()) ; self . sign = Minus ; self . normalize () ; } (Minus , Plus) => { bitor_neg_pos (self . digits_mut () , other . digits ()) ; self . normalize () ; } (Minus , Minus) => { bitor_neg_neg (self . digits_mut () , other . digits ()) ; self . normalize () ; } } } } fn bitxor_pos_neg (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_b = 1 ; let mut carry_xor = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_b = negate_carry (bi , & mut carry_b) ; * ai = negate_carry (* ai ^ twos_b , & mut carry_xor) ; } debug_assert ! (b . len () > a . len () || carry_b == 0) ; if a . len () > b . len () { for ai in a [b . len () ..] . iter_mut () { let twos_b = ! 0 ; * ai = negate_carry (* ai ^ twos_b , & mut carry_xor) ; } } else if b . len () > a . len () { let extra = & b [a . len () ..] ; a . extend (extra . iter () . map (| & bi | { let twos_b = negate_carry (bi , & mut carry_b) ; negate_carry (twos_b , & mut carry_xor) })) ; debug_assert ! (carry_b == 0) ; } if carry_xor != 0 { a . push (1) ; } } fn bitxor_neg_pos (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_a = 1 ; let mut carry_xor = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_a = negate_carry (* ai , & mut carry_a) ; * ai = negate_carry (twos_a ^ bi , & mut carry_xor) ; } debug_assert ! (a . len () > b . len () || carry_a == 0) ; if a . len () > b . len () { for ai in a [b . len () ..] . iter_mut () { let twos_a = negate_carry (* ai , & mut carry_a) ; * ai = negate_carry (twos_a , & mut carry_xor) ; } debug_assert ! (carry_a == 0) ; } else if b . len () > a . len () { let extra = & b [a . len () ..] ; a . extend (extra . iter () . map (| & bi | { let twos_a = ! 0 ; negate_carry (twos_a ^ bi , & mut carry_xor) })) ; } if carry_xor != 0 { a . push (1) ; } } fn bitxor_neg_neg (a : & mut Vec < BigDigit > , b : & [BigDigit]) { let mut carry_a = 1 ; let mut carry_b = 1 ; for (ai , & bi) in a . iter_mut () . zip (b . iter ()) { let twos_a = negate_carry (* ai , & mut carry_a) ; let twos_b = negate_carry (bi , & mut carry_b) ; * ai = twos_a ^ twos_b ; } debug_assert ! (a . len () > b . len () || carry_a == 0) ; debug_assert ! (b . len () > a . len () || carry_b == 0) ; if a . len () > b . len () { for ai in a [b . len () ..] . iter_mut () { let twos_a = negate_carry (* ai , & mut carry_a) ; let twos_b = ! 0 ; * ai = twos_a ^ twos_b ; } debug_assert ! (carry_a == 0) ; } else if b . len () > a . len () { let extra = & b [a . len () ..] ; a . extend (extra . iter () . map (| & bi | { let twos_a = ! 0 ; let twos_b = negate_carry (bi , & mut carry_b) ; twos_a ^ twos_b })) ; debug_assert ! (carry_b == 0) ; } } forward_all_binop_to_val_ref_commutative ! (impl BitXor for BigInt , bitxor) ; impl < 'a > BitXor < & 'a BigInt > for BigInt { type Output = BigInt ; # [inline] fn bitxor (mut self , other : & BigInt) -> BigInt { self ^= other ; self } } forward_val_assign ! (impl BitXorAssign for BigInt , bitxor_assign) ; impl < 'a > BitXorAssign < & 'a BigInt > for BigInt { fn bitxor_assign (& mut self , other : & BigInt) { match (self . sign , other . sign) { (_ , NoSign) => { } (NoSign , _) => self . assign_from_slice (other . sign , other . digits ()) , (Plus , Plus) => { self . data ^= & other . data ; if self . data . is_zero () { self . sign = NoSign ; } } (Plus , Minus) => { bitxor_pos_neg (self . digits_mut () , other . digits ()) ; self . sign = Minus ; self . normalize () ; } (Minus , Plus) => { bitxor_neg_pos (self . digits_mut () , other . digits ()) ; self . normalize () ; } (Minus , Minus) => { bitxor_neg_neg (self . digits_mut () , other . digits ()) ; self . sign = Plus ; self . normalize () ; } } } } impl FromStr for BigInt { type Err = ParseBigIntError ; # [inline] fn from_str (s : & str) -> Result < BigInt , ParseBigIntError > { BigInt :: from_str_radix (s , 10) } } impl Num for BigInt { type FromStrRadixErr = ParseBigIntError ; # [doc = " Creates and initializes a BigInt."] # [inline] fn from_str_radix (mut s : & str , radix : u32) -> Result < BigInt , ParseBigIntError > { let sign = if s . starts_with ('-') { let tail = & s [1 ..] ; if ! tail . starts_with ('+') { s = tail } Minus } else { Plus } ; let bu = BigUint :: from_str_radix (s , radix) ? ; Ok (BigInt :: from_biguint (sign , bu)) } } impl Shl < usize > for BigInt { type Output = BigInt ; # [inline] fn shl (mut self , rhs : usize) -> BigInt { self <<= rhs ; self } } impl < 'a > Shl < usize > for & 'a BigInt { type Output = BigInt ; # [inline] fn shl (self , rhs : usize) -> BigInt { BigInt :: from_biguint (self . sign , & self . data << rhs) } } impl ShlAssign < usize > for BigInt { # [inline] fn shl_assign (& mut self , rhs : usize) { self . data <<= rhs ; } } fn shr_round_down (i : & BigInt , rhs : usize) -> bool { i . is_negative () && biguint :: trailing_zeros (& i . data) . map (| n | n < rhs) . unwrap_or (false) } impl Shr < usize > for BigInt { type Output = BigInt ; # [inline] fn shr (mut self , rhs : usize) -> BigInt { self >>= rhs ; self } } impl < 'a > Shr < usize > for & 'a BigInt { type Output = BigInt ; # [inline] fn shr (self , rhs : usize) -> BigInt { let round_down = shr_round_down (self , rhs) ; let data = & self . data >> rhs ; BigInt :: from_biguint (self . sign , if round_down { data + 1u8 } else { data }) } } impl ShrAssign < usize > for BigInt { # [inline] fn shr_assign (& mut self , rhs : usize) { let round_down = shr_round_down (self , rhs) ; self . data >>= rhs ; if round_down { self . data += 1u8 ; } else if self . data . is_zero () { self . sign = NoSign ; } } } impl Zero for BigInt { # [inline] fn zero () -> BigInt { BigInt :: from_biguint (NoSign , Zero :: zero ()) } # [inline] fn set_zero (& mut self) { self . data . set_zero () ; self . sign = NoSign ; } # [inline] fn is_zero (& self) -> bool { self . sign == NoSign } } impl One for BigInt { # [inline] fn one () -> BigInt { BigInt :: from_biguint (Plus , One :: one ()) } # [inline] fn set_one (& mut self) { self . data . set_one () ; self . sign = Plus ; } # [inline] fn is_one (& self) -> bool { self . sign == Plus && self . data . is_one () } } impl Signed for BigInt { # [inline] fn abs (& self) -> BigInt { match self . sign { Plus | NoSign => self . clone () , Minus => BigInt :: from_biguint (Plus , self . data . clone ()) , } } # [inline] fn abs_sub (& self , other : & BigInt) -> BigInt { if * self <= * other { Zero :: zero () } else { self - other } } # [inline] fn signum (& self) -> BigInt { match self . sign { Plus => BigInt :: from_biguint (Plus , One :: one ()) , Minus => BigInt :: from_biguint (Minus , One :: one ()) , NoSign => Zero :: zero () , } } # [inline] fn is_positive (& self) -> bool { self . sign == Plus } # [inline] fn is_negative (& self) -> bool { self . sign == Minus } } # [doc = " Help function for pow"] # [doc = ""] # [doc = " Computes the effect of the exponent on the sign."] # [inline] fn powsign < T : Integer > (sign : Sign , other : & T) -> Sign { if other . is_zero () { Plus } else if sign != Minus { sign } else if other . is_odd () { sign } else { - sign } } macro_rules ! pow_impl { ($ T : ty) => { impl <'a > Pow <$ T > for &'a BigInt { type Output = BigInt ; # [inline] fn pow (self , rhs : $ T) -> BigInt { BigInt :: from_biguint (powsign (self . sign , & rhs) , (& self . data) . pow (rhs)) } } impl <'a , 'b > Pow <&'b $ T > for &'a BigInt { type Output = BigInt ; # [inline] fn pow (self , rhs : &$ T) -> BigInt { BigInt :: from_biguint (powsign (self . sign , rhs) , (& self . data) . pow (rhs)) } } } ; } pow_impl ! (u8) ; pow_impl ! (u16) ; pow_impl ! (u32) ; pow_impl ! (u64) ; pow_impl ! (usize) ; # [cfg (has_i128)] pow_impl ! (u128) ; pow_impl ! (BigUint) ; # [inline] fn i32_abs_as_u32 (a : i32) -> u32 { if a == i32 :: min_value () { a as u32 } else { a . abs () as u32 } } # [inline] fn i64_abs_as_u64 (a : i64) -> u64 { if a == i64 :: min_value () { a as u64 } else { a . abs () as u64 } } # [cfg (has_i128)] # [inline] fn i128_abs_as_u128 (a : i128) -> u128 { if a == i128 :: min_value () { a as u128 } else { a . abs () as u128 } } macro_rules ! bigint_add { ($ a : expr , $ a_owned : expr , $ a_data : expr , $ b : expr , $ b_owned : expr , $ b_data : expr) => { match ($ a . sign , $ b . sign) { (_ , NoSign) => $ a_owned , (NoSign , _) => $ b_owned , (Plus , Plus) | (Minus , Minus) => BigInt :: from_biguint ($ a . sign , $ a_data + $ b_data) , (Plus , Minus) | (Minus , Plus) => match $ a . data . cmp (&$ b . data) { Less => BigInt :: from_biguint ($ b . sign , $ b_data - $ a_data) , Greater => BigInt :: from_biguint ($ a . sign , $ a_data - $ b_data) , Equal => Zero :: zero () , } , } } ; } impl < 'a , 'b > Add < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn add (self , other : & BigInt) -> BigInt { bigint_add ! (self , self . clone () , & self . data , other , other . clone () , & other . data) } } impl < 'a > Add < BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn add (self , other : BigInt) -> BigInt { bigint_add ! (self , self . clone () , & self . data , other , other , other . data) } } impl < 'a > Add < & 'a BigInt > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : & BigInt) -> BigInt { bigint_add ! (self , self , self . data , other , other . clone () , & other . data) } } impl Add < BigInt > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : BigInt) -> BigInt { bigint_add ! (self , self , self . data , other , other , other . data) } } impl < 'a > AddAssign < & 'a BigInt > for BigInt { # [inline] fn add_assign (& mut self , other : & BigInt) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n + other ; } } forward_val_assign ! (impl AddAssign for BigInt , add_assign) ; promote_all_scalars ! (impl Add for BigInt , add) ; promote_all_scalars_assign ! (impl AddAssign for BigInt , add_assign) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Add < u32 > for BigInt , add) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Add < u64 > for BigInt , add) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val_commutative ! (impl Add < u128 > for BigInt , add) ; impl Add < u32 > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : u32) -> BigInt { match self . sign { NoSign => From :: from (other) , Plus => BigInt :: from_biguint (Plus , self . data + other) , Minus => match self . data . cmp (& From :: from (other)) { Equal => Zero :: zero () , Less => BigInt :: from_biguint (Plus , other - self . data) , Greater => BigInt :: from_biguint (Minus , self . data - other) , } , } } } impl AddAssign < u32 > for BigInt { # [inline] fn add_assign (& mut self , other : u32) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n + other ; } } impl Add < u64 > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : u64) -> BigInt { match self . sign { NoSign => From :: from (other) , Plus => BigInt :: from_biguint (Plus , self . data + other) , Minus => match self . data . cmp (& From :: from (other)) { Equal => Zero :: zero () , Less => BigInt :: from_biguint (Plus , other - self . data) , Greater => BigInt :: from_biguint (Minus , self . data - other) , } , } } } impl AddAssign < u64 > for BigInt { # [inline] fn add_assign (& mut self , other : u64) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n + other ; } } # [cfg (has_i128)] impl Add < u128 > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : u128) -> BigInt { match self . sign { NoSign => From :: from (other) , Plus => BigInt :: from_biguint (Plus , self . data + other) , Minus => match self . data . cmp (& From :: from (other)) { Equal => Zero :: zero () , Less => BigInt :: from_biguint (Plus , other - self . data) , Greater => BigInt :: from_biguint (Minus , self . data - other) , } , } } } # [cfg (has_i128)] impl AddAssign < u128 > for BigInt { # [inline] fn add_assign (& mut self , other : u128) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n + other ; } } forward_all_scalar_binop_to_val_val_commutative ! (impl Add < i32 > for BigInt , add) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Add < i64 > for BigInt , add) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val_commutative ! (impl Add < i128 > for BigInt , add) ; impl Add < i32 > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : i32) -> BigInt { if other >= 0 { self + other as u32 } else { self - i32_abs_as_u32 (other) } } } impl AddAssign < i32 > for BigInt { # [inline] fn add_assign (& mut self , other : i32) { if other >= 0 { * self += other as u32 ; } else { * self -= i32_abs_as_u32 (other) ; } } } impl Add < i64 > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : i64) -> BigInt { if other >= 0 { self + other as u64 } else { self - i64_abs_as_u64 (other) } } } impl AddAssign < i64 > for BigInt { # [inline] fn add_assign (& mut self , other : i64) { if other >= 0 { * self += other as u64 ; } else { * self -= i64_abs_as_u64 (other) ; } } } # [cfg (has_i128)] impl Add < i128 > for BigInt { type Output = BigInt ; # [inline] fn add (self , other : i128) -> BigInt { if other >= 0 { self + other as u128 } else { self - i128_abs_as_u128 (other) } } } # [cfg (has_i128)] impl AddAssign < i128 > for BigInt { # [inline] fn add_assign (& mut self , other : i128) { if other >= 0 { * self += other as u128 ; } else { * self -= i128_abs_as_u128 (other) ; } } } macro_rules ! bigint_sub { ($ a : expr , $ a_owned : expr , $ a_data : expr , $ b : expr , $ b_owned : expr , $ b_data : expr) => { match ($ a . sign , $ b . sign) { (_ , NoSign) => $ a_owned , (NoSign , _) => -$ b_owned , (Plus , Minus) | (Minus , Plus) => BigInt :: from_biguint ($ a . sign , $ a_data + $ b_data) , (Plus , Plus) | (Minus , Minus) => match $ a . data . cmp (&$ b . data) { Less => BigInt :: from_biguint (-$ a . sign , $ b_data - $ a_data) , Greater => BigInt :: from_biguint ($ a . sign , $ a_data - $ b_data) , Equal => Zero :: zero () , } , } } ; } impl < 'a , 'b > Sub < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn sub (self , other : & BigInt) -> BigInt { bigint_sub ! (self , self . clone () , & self . data , other , other . clone () , & other . data) } } impl < 'a > Sub < BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { bigint_sub ! (self , self . clone () , & self . data , other , other , other . data) } } impl < 'a > Sub < & 'a BigInt > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : & BigInt) -> BigInt { bigint_sub ! (self , self , self . data , other , other . clone () , & other . data) } } impl Sub < BigInt > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { bigint_sub ! (self , self , self . data , other , other , other . data) } } impl < 'a > SubAssign < & 'a BigInt > for BigInt { # [inline] fn sub_assign (& mut self , other : & BigInt) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n - other ; } } forward_val_assign ! (impl SubAssign for BigInt , sub_assign) ; promote_all_scalars ! (impl Sub for BigInt , sub) ; promote_all_scalars_assign ! (impl SubAssign for BigInt , sub_assign) ; forward_all_scalar_binop_to_val_val ! (impl Sub < u32 > for BigInt , sub) ; forward_all_scalar_binop_to_val_val ! (impl Sub < u64 > for BigInt , sub) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Sub < u128 > for BigInt , sub) ; impl Sub < u32 > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : u32) -> BigInt { match self . sign { NoSign => BigInt :: from_biguint (Minus , From :: from (other)) , Minus => BigInt :: from_biguint (Minus , self . data + other) , Plus => match self . data . cmp (& From :: from (other)) { Equal => Zero :: zero () , Greater => BigInt :: from_biguint (Plus , self . data - other) , Less => BigInt :: from_biguint (Minus , other - self . data) , } , } } } impl SubAssign < u32 > for BigInt { # [inline] fn sub_assign (& mut self , other : u32) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n - other ; } } impl Sub < BigInt > for u32 { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { - (other - self) } } impl Sub < BigInt > for u64 { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { - (other - self) } } # [cfg (has_i128)] impl Sub < BigInt > for u128 { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { - (other - self) } } impl Sub < u64 > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : u64) -> BigInt { match self . sign { NoSign => BigInt :: from_biguint (Minus , From :: from (other)) , Minus => BigInt :: from_biguint (Minus , self . data + other) , Plus => match self . data . cmp (& From :: from (other)) { Equal => Zero :: zero () , Greater => BigInt :: from_biguint (Plus , self . data - other) , Less => BigInt :: from_biguint (Minus , other - self . data) , } , } } } impl SubAssign < u64 > for BigInt { # [inline] fn sub_assign (& mut self , other : u64) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n - other ; } } # [cfg (has_i128)] impl Sub < u128 > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : u128) -> BigInt { match self . sign { NoSign => BigInt :: from_biguint (Minus , From :: from (other)) , Minus => BigInt :: from_biguint (Minus , self . data + other) , Plus => match self . data . cmp (& From :: from (other)) { Equal => Zero :: zero () , Greater => BigInt :: from_biguint (Plus , self . data - other) , Less => BigInt :: from_biguint (Minus , other - self . data) , } , } } } # [cfg (has_i128)] impl SubAssign < u128 > for BigInt { # [inline] fn sub_assign (& mut self , other : u128) { let n = mem :: replace (self , BigInt :: zero ()) ; * self = n - other ; } } forward_all_scalar_binop_to_val_val ! (impl Sub < i32 > for BigInt , sub) ; forward_all_scalar_binop_to_val_val ! (impl Sub < i64 > for BigInt , sub) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Sub < i128 > for BigInt , sub) ; impl Sub < i32 > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : i32) -> BigInt { if other >= 0 { self - other as u32 } else { self + i32_abs_as_u32 (other) } } } impl SubAssign < i32 > for BigInt { # [inline] fn sub_assign (& mut self , other : i32) { if other >= 0 { * self -= other as u32 ; } else { * self += i32_abs_as_u32 (other) ; } } } impl Sub < BigInt > for i32 { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { if self >= 0 { self as u32 - other } else { - other - i32_abs_as_u32 (self) } } } impl Sub < i64 > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : i64) -> BigInt { if other >= 0 { self - other as u64 } else { self + i64_abs_as_u64 (other) } } } impl SubAssign < i64 > for BigInt { # [inline] fn sub_assign (& mut self , other : i64) { if other >= 0 { * self -= other as u64 ; } else { * self += i64_abs_as_u64 (other) ; } } } impl Sub < BigInt > for i64 { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { if self >= 0 { self as u64 - other } else { - other - i64_abs_as_u64 (self) } } } # [cfg (has_i128)] impl Sub < i128 > for BigInt { type Output = BigInt ; # [inline] fn sub (self , other : i128) -> BigInt { if other >= 0 { self - other as u128 } else { self + i128_abs_as_u128 (other) } } } # [cfg (has_i128)] impl SubAssign < i128 > for BigInt { # [inline] fn sub_assign (& mut self , other : i128) { if other >= 0 { * self -= other as u128 ; } else { * self += i128_abs_as_u128 (other) ; } } } # [cfg (has_i128)] impl Sub < BigInt > for i128 { type Output = BigInt ; # [inline] fn sub (self , other : BigInt) -> BigInt { if self >= 0 { self as u128 - other } else { - other - i128_abs_as_u128 (self) } } } forward_all_binop_to_ref_ref ! (impl Mul for BigInt , mul) ; impl < 'a , 'b > Mul < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn mul (self , other : & BigInt) -> BigInt { BigInt :: from_biguint (self . sign * other . sign , & self . data * & other . data) } } impl < 'a > MulAssign < & 'a BigInt > for BigInt { # [inline] fn mul_assign (& mut self , other : & BigInt) { * self = & * self * other ; } } forward_val_assign ! (impl MulAssign for BigInt , mul_assign) ; promote_all_scalars ! (impl Mul for BigInt , mul) ; promote_all_scalars_assign ! (impl MulAssign for BigInt , mul_assign) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < u32 > for BigInt , mul) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < u64 > for BigInt , mul) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < u128 > for BigInt , mul) ; impl Mul < u32 > for BigInt { type Output = BigInt ; # [inline] fn mul (self , other : u32) -> BigInt { BigInt :: from_biguint (self . sign , self . data * other) } } impl MulAssign < u32 > for BigInt { # [inline] fn mul_assign (& mut self , other : u32) { self . data *= other ; if self . data . is_zero () { self . sign = NoSign ; } } } impl Mul < u64 > for BigInt { type Output = BigInt ; # [inline] fn mul (self , other : u64) -> BigInt { BigInt :: from_biguint (self . sign , self . data * other) } } impl MulAssign < u64 > for BigInt { # [inline] fn mul_assign (& mut self , other : u64) { self . data *= other ; if self . data . is_zero () { self . sign = NoSign ; } } } # [cfg (has_i128)] impl Mul < u128 > for BigInt { type Output = BigInt ; # [inline] fn mul (self , other : u128) -> BigInt { BigInt :: from_biguint (self . sign , self . data * other) } } # [cfg (has_i128)] impl MulAssign < u128 > for BigInt { # [inline] fn mul_assign (& mut self , other : u128) { self . data *= other ; if self . data . is_zero () { self . sign = NoSign ; } } } forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < i32 > for BigInt , mul) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < i64 > for BigInt , mul) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < i128 > for BigInt , mul) ; impl Mul < i32 > for BigInt { type Output = BigInt ; # [inline] fn mul (self , other : i32) -> BigInt { if other >= 0 { self * other as u32 } else { - (self * i32_abs_as_u32 (other)) } } } impl MulAssign < i32 > for BigInt { # [inline] fn mul_assign (& mut self , other : i32) { if other >= 0 { * self *= other as u32 ; } else { self . sign = - self . sign ; * self *= i32_abs_as_u32 (other) ; } } } impl Mul < i64 > for BigInt { type Output = BigInt ; # [inline] fn mul (self , other : i64) -> BigInt { if other >= 0 { self * other as u64 } else { - (self * i64_abs_as_u64 (other)) } } } impl MulAssign < i64 > for BigInt { # [inline] fn mul_assign (& mut self , other : i64) { if other >= 0 { * self *= other as u64 ; } else { self . sign = - self . sign ; * self *= i64_abs_as_u64 (other) ; } } } # [cfg (has_i128)] impl Mul < i128 > for BigInt { type Output = BigInt ; # [inline] fn mul (self , other : i128) -> BigInt { if other >= 0 { self * other as u128 } else { - (self * i128_abs_as_u128 (other)) } } } # [cfg (has_i128)] impl MulAssign < i128 > for BigInt { # [inline] fn mul_assign (& mut self , other : i128) { if other >= 0 { * self *= other as u128 ; } else { self . sign = - self . sign ; * self *= i128_abs_as_u128 (other) ; } } } forward_all_binop_to_ref_ref ! (impl Div for BigInt , div) ; impl < 'a , 'b > Div < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn div (self , other : & BigInt) -> BigInt { let (q , _) = self . div_rem (other) ; q } } impl < 'a > DivAssign < & 'a BigInt > for BigInt { # [inline] fn div_assign (& mut self , other : & BigInt) { * self = & * self / other ; } } forward_val_assign ! (impl DivAssign for BigInt , div_assign) ; promote_all_scalars ! (impl Div for BigInt , div) ; promote_all_scalars_assign ! (impl DivAssign for BigInt , div_assign) ; forward_all_scalar_binop_to_val_val ! (impl Div < u32 > for BigInt , div) ; forward_all_scalar_binop_to_val_val ! (impl Div < u64 > for BigInt , div) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Div < u128 > for BigInt , div) ; impl Div < u32 > for BigInt { type Output = BigInt ; # [inline] fn div (self , other : u32) -> BigInt { BigInt :: from_biguint (self . sign , self . data / other) } } impl DivAssign < u32 > for BigInt { # [inline] fn div_assign (& mut self , other : u32) { self . data /= other ; if self . data . is_zero () { self . sign = NoSign ; } } } impl Div < BigInt > for u32 { type Output = BigInt ; # [inline] fn div (self , other : BigInt) -> BigInt { BigInt :: from_biguint (other . sign , self / other . data) } } impl Div < u64 > for BigInt { type Output = BigInt ; # [inline] fn div (self , other : u64) -> BigInt { BigInt :: from_biguint (self . sign , self . data / other) } } impl DivAssign < u64 > for BigInt { # [inline] fn div_assign (& mut self , other : u64) { self . data /= other ; if self . data . is_zero () { self . sign = NoSign ; } } } impl Div < BigInt > for u64 { type Output = BigInt ; # [inline] fn div (self , other : BigInt) -> BigInt { BigInt :: from_biguint (other . sign , self / other . data) } } # [cfg (has_i128)] impl Div < u128 > for BigInt { type Output = BigInt ; # [inline] fn div (self , other : u128) -> BigInt { BigInt :: from_biguint (self . sign , self . data / other) } } # [cfg (has_i128)] impl DivAssign < u128 > for BigInt { # [inline] fn div_assign (& mut self , other : u128) { self . data /= other ; if self . data . is_zero () { self . sign = NoSign ; } } } # [cfg (has_i128)] impl Div < BigInt > for u128 { type Output = BigInt ; # [inline] fn div (self , other : BigInt) -> BigInt { BigInt :: from_biguint (other . sign , self / other . data) } } forward_all_scalar_binop_to_val_val ! (impl Div < i32 > for BigInt , div) ; forward_all_scalar_binop_to_val_val ! (impl Div < i64 > for BigInt , div) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Div < i128 > for BigInt , div) ; impl Div < i32 > for BigInt { type Output = BigInt ; # [inline] fn div (self , other : i32) -> BigInt { if other >= 0 { self / other as u32 } else { - (self / i32_abs_as_u32 (other)) } } } impl DivAssign < i32 > for BigInt { # [inline] fn div_assign (& mut self , other : i32) { if other >= 0 { * self /= other as u32 ; } else { self . sign = - self . sign ; * self /= i32_abs_as_u32 (other) ; } } } impl Div < BigInt > for i32 { type Output = BigInt ; # [inline] fn div (self , other : BigInt) -> BigInt { if self >= 0 { self as u32 / other } else { - (i32_abs_as_u32 (self) / other) } } } impl Div < i64 > for BigInt { type Output = BigInt ; # [inline] fn div (self , other : i64) -> BigInt { if other >= 0 { self / other as u64 } else { - (self / i64_abs_as_u64 (other)) } } } impl DivAssign < i64 > for BigInt { # [inline] fn div_assign (& mut self , other : i64) { if other >= 0 { * self /= other as u64 ; } else { self . sign = - self . sign ; * self /= i64_abs_as_u64 (other) ; } } } impl Div < BigInt > for i64 { type Output = BigInt ; # [inline] fn div (self , other : BigInt) -> BigInt { if self >= 0 { self as u64 / other } else { - (i64_abs_as_u64 (self) / other) } } } # [cfg (has_i128)] impl Div < i128 > for BigInt { type Output = BigInt ; # [inline] fn div (self , other : i128) -> BigInt { if other >= 0 { self / other as u128 } else { - (self / i128_abs_as_u128 (other)) } } } # [cfg (has_i128)] impl DivAssign < i128 > for BigInt { # [inline] fn div_assign (& mut self , other : i128) { if other >= 0 { * self /= other as u128 ; } else { self . sign = - self . sign ; * self /= i128_abs_as_u128 (other) ; } } } # [cfg (has_i128)] impl Div < BigInt > for i128 { type Output = BigInt ; # [inline] fn div (self , other : BigInt) -> BigInt { if self >= 0 { self as u128 / other } else { - (i128_abs_as_u128 (self) / other) } } } forward_all_binop_to_ref_ref ! (impl Rem for BigInt , rem) ; impl < 'a , 'b > Rem < & 'b BigInt > for & 'a BigInt { type Output = BigInt ; # [inline] fn rem (self , other : & BigInt) -> BigInt { let (_ , r) = self . div_rem (other) ; r } } impl < 'a > RemAssign < & 'a BigInt > for BigInt { # [inline] fn rem_assign (& mut self , other : & BigInt) { * self = & * self % other ; } } forward_val_assign ! (impl RemAssign for BigInt , rem_assign) ; promote_all_scalars ! (impl Rem for BigInt , rem) ; promote_all_scalars_assign ! (impl RemAssign for BigInt , rem_assign) ; forward_all_scalar_binop_to_val_val ! (impl Rem < u32 > for BigInt , rem) ; forward_all_scalar_binop_to_val_val ! (impl Rem < u64 > for BigInt , rem) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Rem < u128 > for BigInt , rem) ; impl Rem < u32 > for BigInt { type Output = BigInt ; # [inline] fn rem (self , other : u32) -> BigInt { BigInt :: from_biguint (self . sign , self . data % other) } } impl RemAssign < u32 > for BigInt { # [inline] fn rem_assign (& mut self , other : u32) { self . data %= other ; if self . data . is_zero () { self . sign = NoSign ; } } } impl Rem < BigInt > for u32 { type Output = BigInt ; # [inline] fn rem (self , other : BigInt) -> BigInt { BigInt :: from_biguint (Plus , self % other . data) } } impl Rem < u64 > for BigInt { type Output = BigInt ; # [inline] fn rem (self , other : u64) -> BigInt { BigInt :: from_biguint (self . sign , self . data % other) } } impl RemAssign < u64 > for BigInt { # [inline] fn rem_assign (& mut self , other : u64) { self . data %= other ; if self . data . is_zero () { self . sign = NoSign ; } } } impl Rem < BigInt > for u64 { type Output = BigInt ; # [inline] fn rem (self , other : BigInt) -> BigInt { BigInt :: from_biguint (Plus , self % other . data) } } # [cfg (has_i128)] impl Rem < u128 > for BigInt { type Output = BigInt ; # [inline] fn rem (self , other : u128) -> BigInt { BigInt :: from_biguint (self . sign , self . data % other) } } # [cfg (has_i128)] impl RemAssign < u128 > for BigInt { # [inline] fn rem_assign (& mut self , other : u128) { self . data %= other ; if self . data . is_zero () { self . sign = NoSign ; } } } # [cfg (has_i128)] impl Rem < BigInt > for u128 { type Output = BigInt ; # [inline] fn rem (self , other : BigInt) -> BigInt { BigInt :: from_biguint (Plus , self % other . data) } } forward_all_scalar_binop_to_val_val ! (impl Rem < i32 > for BigInt , rem) ; forward_all_scalar_binop_to_val_val ! (impl Rem < i64 > for BigInt , rem) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Rem < i128 > for BigInt , rem) ; impl Rem < i32 > for BigInt { type Output = BigInt ; # [inline] fn rem (self , other : i32) -> BigInt { if other >= 0 { self % other as u32 } else { self % i32_abs_as_u32 (other) } } } impl RemAssign < i32 > for BigInt { # [inline] fn rem_assign (& mut self , other : i32) { if other >= 0 { * self %= other as u32 ; } else { * self %= i32_abs_as_u32 (other) ; } } } impl Rem < BigInt > for i32 { type Output = BigInt ; # [inline] fn rem (self , other : BigInt) -> BigInt { if self >= 0 { self as u32 % other } else { - (i32_abs_as_u32 (self) % other) } } } impl Rem < i64 > for BigInt { type Output = BigInt ; # [inline] fn rem (self , other : i64) -> BigInt { if other >= 0 { self % other as u64 } else { self % i64_abs_as_u64 (other) } } } impl RemAssign < i64 > for BigInt { # [inline] fn rem_assign (& mut self , other : i64) { if other >= 0 { * self %= other as u64 ; } else { * self %= i64_abs_as_u64 (other) ; } } } impl Rem < BigInt > for i64 { type Output = BigInt ; # [inline] fn rem (self , other : BigInt) -> BigInt { if self >= 0 { self as u64 % other } else { - (i64_abs_as_u64 (self) % other) } } } # [cfg (has_i128)] impl Rem < i128 > for BigInt { type Output = BigInt ; # [inline] fn rem (self , other : i128) -> BigInt { if other >= 0 { self % other as u128 } else { self % i128_abs_as_u128 (other) } } } # [cfg (has_i128)] impl RemAssign < i128 > for BigInt { # [inline] fn rem_assign (& mut self , other : i128) { if other >= 0 { * self %= other as u128 ; } else { * self %= i128_abs_as_u128 (other) ; } } } # [cfg (has_i128)] impl Rem < BigInt > for i128 { type Output = BigInt ; # [inline] fn rem (self , other : BigInt) -> BigInt { if self >= 0 { self as u128 % other } else { - (i128_abs_as_u128 (self) % other) } } } impl Neg for BigInt { type Output = BigInt ; # [inline] fn neg (mut self) -> BigInt { self . sign = - self . sign ; self } } impl < 'a > Neg for & 'a BigInt { type Output = BigInt ; # [inline] fn neg (self) -> BigInt { - self . clone () } } impl CheckedAdd for BigInt { # [inline] fn checked_add (& self , v : & BigInt) -> Option < BigInt > { Some (self . add (v)) } } impl CheckedSub for BigInt { # [inline] fn checked_sub (& self , v : & BigInt) -> Option < BigInt > { Some (self . sub (v)) } } impl CheckedMul for BigInt { # [inline] fn checked_mul (& self , v : & BigInt) -> Option < BigInt > { Some (self . mul (v)) } } impl CheckedDiv for BigInt { # [inline] fn checked_div (& self , v : & BigInt) -> Option < BigInt > { if v . is_zero () { return None ; } Some (self . div (v)) } } impl Integer for BigInt { # [inline] fn div_rem (& self , other : & BigInt) -> (BigInt , BigInt) { let (d_ui , r_ui) = self . data . div_mod_floor (& other . data) ; let d = BigInt :: from_biguint (self . sign , d_ui) ; let r = BigInt :: from_biguint (self . sign , r_ui) ; if other . is_negative () { (- d , r) } else { (d , r) } } # [inline] fn div_floor (& self , other : & BigInt) -> BigInt { let (d , _) = self . div_mod_floor (other) ; d } # [inline] fn mod_floor (& self , other : & BigInt) -> BigInt { let (_ , m) = self . div_mod_floor (other) ; m } fn div_mod_floor (& self , other : & BigInt) -> (BigInt , BigInt) { let (d_ui , m_ui) = self . data . div_rem (& other . data) ; let d = BigInt :: from_biguint (Plus , d_ui) ; let m = BigInt :: from_biguint (Plus , m_ui) ; let one : BigInt = One :: one () ; match (self . sign , other . sign) { (_ , NoSign) => panic ! () , (Plus , Plus) | (NoSign , Plus) => (d , m) , (Plus , Minus) | (NoSign , Minus) => { if m . is_zero () { (- d , Zero :: zero ()) } else { (- d - one , m + other) } } (Minus , Plus) => { if m . is_zero () { (- d , Zero :: zero ()) } else { (- d - one , other - m) } } (Minus , Minus) => (d , - m) , } } # [doc = " Calculates the Greatest Common Divisor (GCD) of the number and `other`."] # [doc = ""] # [doc = " The result is always positive."] # [inline] fn gcd (& self , other : & BigInt) -> BigInt { BigInt :: from_biguint (Plus , self . data . gcd (& other . data)) } # [doc = " Calculates the Lowest Common Multiple (LCM) of the number and `other`."] # [inline] fn lcm (& self , other : & BigInt) -> BigInt { BigInt :: from_biguint (Plus , self . data . lcm (& other . data)) } # [doc = " Deprecated, use `is_multiple_of` instead."] # [inline] fn divides (& self , other : & BigInt) -> bool { self . is_multiple_of (other) } # [doc = " Returns `true` if the number is a multiple of `other`."] # [inline] fn is_multiple_of (& self , other : & BigInt) -> bool { self . data . is_multiple_of (& other . data) } # [doc = " Returns `true` if the number is divisible by `2`."] # [inline] fn is_even (& self) -> bool { self . data . is_even () } # [doc = " Returns `true` if the number is not divisible by `2`."] # [inline] fn is_odd (& self) -> bool { self . data . is_odd () } } impl Roots for BigInt { fn nth_root (& self , n : u32) -> Self { assert ! (! (self . is_negative () && n . is_even ()) , "root of degree {} is imaginary" , n) ; BigInt :: from_biguint (self . sign , self . data . nth_root (n)) } fn sqrt (& self) -> Self { assert ! (! self . is_negative () , "square root is imaginary") ; BigInt :: from_biguint (self . sign , self . data . sqrt ()) } fn cbrt (& self) -> Self { BigInt :: from_biguint (self . sign , self . data . cbrt ()) } } impl ToPrimitive for BigInt { # [inline] fn to_i64 (& self) -> Option < i64 > { match self . sign { Plus => self . data . to_i64 () , NoSign => Some (0) , Minus => self . data . to_u64 () . and_then (| n | { let m : u64 = 1 << 63 ; if n < m { Some (- (n as i64)) } else if n == m { Some (i64 :: MIN) } else { None } }) , } } # [inline] # [cfg (has_i128)] fn to_i128 (& self) -> Option < i128 > { match self . sign { Plus => self . data . to_i128 () , NoSign => Some (0) , Minus => self . data . to_u128 () . and_then (| n | { let m : u128 = 1 << 127 ; if n < m { Some (- (n as i128)) } else if n == m { Some (i128 :: MIN) } else { None } }) , } } # [inline] fn to_u64 (& self) -> Option < u64 > { match self . sign { Plus => self . data . to_u64 () , NoSign => Some (0) , Minus => None , } } # [inline] # [cfg (has_i128)] fn to_u128 (& self) -> Option < u128 > { match self . sign { Plus => self . data . to_u128 () , NoSign => Some (0) , Minus => None , } } # [inline] fn to_f32 (& self) -> Option < f32 > { self . data . to_f32 () . map (| n | if self . sign == Minus { - n } else { n }) } # [inline] fn to_f64 (& self) -> Option < f64 > { self . data . to_f64 () . map (| n | if self . sign == Minus { - n } else { n }) } } impl FromPrimitive for BigInt { # [inline] fn from_i64 (n : i64) -> Option < BigInt > { Some (BigInt :: from (n)) } # [inline] # [cfg (has_i128)] fn from_i128 (n : i128) -> Option < BigInt > { Some (BigInt :: from (n)) } # [inline] fn from_u64 (n : u64) -> Option < BigInt > { Some (BigInt :: from (n)) } # [inline] # [cfg (has_i128)] fn from_u128 (n : u128) -> Option < BigInt > { Some (BigInt :: from (n)) } # [inline] fn from_f64 (n : f64) -> Option < BigInt > { if n >= 0.0 { BigUint :: from_f64 (n) . map (| x | BigInt :: from_biguint (Plus , x)) } else { BigUint :: from_f64 (- n) . map (| x | BigInt :: from_biguint (Minus , x)) } } } impl From < i64 > for BigInt { # [inline] fn from (n : i64) -> Self { if n >= 0 { BigInt :: from (n as u64) } else { let u = u64 :: MAX - (n as u64) + 1 ; BigInt { sign : Minus , data : BigUint :: from (u) , } } } } # [cfg (has_i128)] impl From < i128 > for BigInt { # [inline] fn from (n : i128) -> Self { if n >= 0 { BigInt :: from (n as u128) } else { let u = u128 :: MAX - (n as u128) + 1 ; BigInt { sign : Minus , data : BigUint :: from (u) , } } } } macro_rules ! impl_bigint_from_int { ($ T : ty) => { impl From <$ T > for BigInt { # [inline] fn from (n : $ T) -> Self { BigInt :: from (n as i64) } } } ; } impl_bigint_from_int ! (i8) ; impl_bigint_from_int ! (i16) ; impl_bigint_from_int ! (i32) ; impl_bigint_from_int ! (isize) ; impl From < u64 > for BigInt { # [inline] fn from (n : u64) -> Self { if n > 0 { BigInt { sign : Plus , data : BigUint :: from (n) , } } else { BigInt :: zero () } } } # [cfg (has_i128)] impl From < u128 > for BigInt { # [inline] fn from (n : u128) -> Self { if n > 0 { BigInt { sign : Plus , data : BigUint :: from (n) , } } else { BigInt :: zero () } } } macro_rules ! impl_bigint_from_uint { ($ T : ty) => { impl From <$ T > for BigInt { # [inline] fn from (n : $ T) -> Self { BigInt :: from (n as u64) } } } ; } impl_bigint_from_uint ! (u8) ; impl_bigint_from_uint ! (u16) ; impl_bigint_from_uint ! (u32) ; impl_bigint_from_uint ! (usize) ; impl From < BigUint > for BigInt { # [inline] fn from (n : BigUint) -> Self { if n . is_zero () { BigInt :: zero () } else { BigInt { sign : Plus , data : n , } } } } impl IntDigits for BigInt { # [inline] fn digits (& self) -> & [BigDigit] { self . data . digits () } # [inline] fn digits_mut (& mut self) -> & mut Vec < BigDigit > { self . data . digits_mut () } # [inline] fn normalize (& mut self) { self . data . normalize () ; if self . data . is_zero () { self . sign = NoSign ; } } # [inline] fn capacity (& self) -> usize { self . data . capacity () } # [inline] fn len (& self) -> usize { self . data . len () } } # [cfg (feature = "serde")] impl serde :: Serialize for BigInt { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : serde :: Serializer , { (self . sign , & self . data) . serialize (serializer) } } # [cfg (feature = "serde")] impl < 'de > serde :: Deserialize < 'de > for BigInt { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : serde :: Deserializer < 'de > , { let (sign , data) = serde :: Deserialize :: deserialize (deserializer) ? ; Ok (BigInt :: from_biguint (sign , data)) } } # [doc = " A generic trait for converting a value to a `BigInt`. This may return"] # [doc = " `None` when converting from `f32` or `f64`, and will always succeed"] # [doc = " when converting from any integer or unsigned primitive, or `BigUint`."] pub trait ToBigInt { # [doc = " Converts the value of `self` to a `BigInt`."] fn to_bigint (& self) -> Option < BigInt > ; } impl ToBigInt for BigInt { # [inline] fn to_bigint (& self) -> Option < BigInt > { Some (self . clone ()) } } impl ToBigInt for BigUint { # [inline] fn to_bigint (& self) -> Option < BigInt > { if self . is_zero () { Some (Zero :: zero ()) } else { Some (BigInt { sign : Plus , data : self . clone () , }) } } } impl biguint :: ToBigUint for BigInt { # [inline] fn to_biguint (& self) -> Option < BigUint > { match self . sign () { Plus => Some (self . data . clone ()) , NoSign => Some (Zero :: zero ()) , Minus => None , } } } macro_rules ! impl_to_bigint { ($ T : ty , $ from_ty : path) => { impl ToBigInt for $ T { # [inline] fn to_bigint (& self) -> Option < BigInt > { $ from_ty (* self) } } } ; } impl_to_bigint ! (isize , FromPrimitive :: from_isize) ; impl_to_bigint ! (i8 , FromPrimitive :: from_i8) ; impl_to_bigint ! (i16 , FromPrimitive :: from_i16) ; impl_to_bigint ! (i32 , FromPrimitive :: from_i32) ; impl_to_bigint ! (i64 , FromPrimitive :: from_i64) ; # [cfg (has_i128)] impl_to_bigint ! (i128 , FromPrimitive :: from_i128) ; impl_to_bigint ! (usize , FromPrimitive :: from_usize) ; impl_to_bigint ! (u8 , FromPrimitive :: from_u8) ; impl_to_bigint ! (u16 , FromPrimitive :: from_u16) ; impl_to_bigint ! (u32 , FromPrimitive :: from_u32) ; impl_to_bigint ! (u64 , FromPrimitive :: from_u64) ; # [cfg (has_i128)] impl_to_bigint ! (u128 , FromPrimitive :: from_u128) ; impl_to_bigint ! (f32 , FromPrimitive :: from_f32) ; impl_to_bigint ! (f64 , FromPrimitive :: from_f64) ; impl BigInt { # [doc = " Creates and initializes a BigInt."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn new (sign : Sign , digits : Vec < u32 >) -> BigInt { BigInt :: from_biguint (sign , BigUint :: new (digits)) } # [doc = " Creates and initializes a `BigInt`."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn from_biguint (mut sign : Sign , mut data : BigUint) -> BigInt { if sign == NoSign { data . assign_from_slice (& []) ; } else if data . is_zero () { sign = NoSign ; } BigInt { sign : sign , data : data , } } # [doc = " Creates and initializes a `BigInt`."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn from_slice (sign : Sign , slice : & [u32]) -> BigInt { BigInt :: from_biguint (sign , BigUint :: from_slice (slice)) } # [doc = " Reinitializes a `BigInt`."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn assign_from_slice (& mut self , sign : Sign , slice : & [u32]) { if sign == NoSign { self . data . assign_from_slice (& []) ; self . sign = NoSign ; } else { self . data . assign_from_slice (slice) ; self . sign = match self . data . is_zero () { true => NoSign , false => sign , } } } # [doc = " Creates and initializes a `BigInt`."] # [doc = ""] # [doc = " The bytes are in big-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, Sign};"] # [doc = ""] # [doc = " assert_eq!(BigInt::from_bytes_be(Sign::Plus, b\"A\"),"] # [doc = "            BigInt::parse_bytes(b\"65\", 10).unwrap());"] # [doc = " assert_eq!(BigInt::from_bytes_be(Sign::Plus, b\"AA\"),"] # [doc = "            BigInt::parse_bytes(b\"16705\", 10).unwrap());"] # [doc = " assert_eq!(BigInt::from_bytes_be(Sign::Plus, b\"AB\"),"] # [doc = "            BigInt::parse_bytes(b\"16706\", 10).unwrap());"] # [doc = " assert_eq!(BigInt::from_bytes_be(Sign::Plus, b\"Hello world!\"),"] # [doc = "            BigInt::parse_bytes(b\"22405534230753963835153736737\", 10).unwrap());"] # [doc = " ```"] # [inline] pub fn from_bytes_be (sign : Sign , bytes : & [u8]) -> BigInt { BigInt :: from_biguint (sign , BigUint :: from_bytes_be (bytes)) } # [doc = " Creates and initializes a `BigInt`."] # [doc = ""] # [doc = " The bytes are in little-endian byte order."] # [inline] pub fn from_bytes_le (sign : Sign , bytes : & [u8]) -> BigInt { BigInt :: from_biguint (sign , BigUint :: from_bytes_le (bytes)) } # [doc = " Creates and initializes a `BigInt` from an array of bytes in"] # [doc = " two's complement binary representation."] # [doc = ""] # [doc = " The digits are in big-endian base 2<sup>8</sup>."] # [inline] pub fn from_signed_bytes_be (digits : & [u8]) -> BigInt { let sign = match digits . first () { Some (v) if * v > 0x7f => Sign :: Minus , Some (_) => Sign :: Plus , None => return BigInt :: zero () , } ; if sign == Sign :: Minus { let mut digits = Vec :: from (digits) ; twos_complement_be (& mut digits) ; BigInt :: from_biguint (sign , BigUint :: from_bytes_be (& * digits)) } else { BigInt :: from_biguint (sign , BigUint :: from_bytes_be (digits)) } } # [doc = " Creates and initializes a `BigInt` from an array of bytes in two's complement."] # [doc = ""] # [doc = " The digits are in little-endian base 2<sup>8</sup>."] # [inline] pub fn from_signed_bytes_le (digits : & [u8]) -> BigInt { let sign = match digits . last () { Some (v) if * v > 0x7f => Sign :: Minus , Some (_) => Sign :: Plus , None => return BigInt :: zero () , } ; if sign == Sign :: Minus { let mut digits = Vec :: from (digits) ; twos_complement_le (& mut digits) ; BigInt :: from_biguint (sign , BigUint :: from_bytes_le (& * digits)) } else { BigInt :: from_biguint (sign , BigUint :: from_bytes_le (digits)) } } # [doc = " Creates and initializes a `BigInt`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, ToBigInt};"] # [doc = ""] # [doc = " assert_eq!(BigInt::parse_bytes(b\"1234\", 10), ToBigInt::to_bigint(&1234));"] # [doc = " assert_eq!(BigInt::parse_bytes(b\"ABCD\", 16), ToBigInt::to_bigint(&0xABCD));"] # [doc = " assert_eq!(BigInt::parse_bytes(b\"G\", 16), None);"] # [doc = " ```"] # [inline] pub fn parse_bytes (buf : & [u8] , radix : u32) -> Option < BigInt > { str :: from_utf8 (buf) . ok () . and_then (| s | BigInt :: from_str_radix (s , radix) . ok ()) } # [doc = " Creates and initializes a `BigInt`. Each u8 of the input slice is"] # [doc = " interpreted as one digit of the number"] # [doc = " and must therefore be less than `radix`."] # [doc = ""] # [doc = " The bytes are in big-endian byte order."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, Sign};"] # [doc = ""] # [doc = " let inbase190 = vec![15, 33, 125, 12, 14];"] # [doc = " let a = BigInt::from_radix_be(Sign::Minus, &inbase190, 190).unwrap();"] # [doc = " assert_eq!(a.to_radix_be(190), (Sign:: Minus, inbase190));"] # [doc = " ```"] pub fn from_radix_be (sign : Sign , buf : & [u8] , radix : u32) -> Option < BigInt > { BigUint :: from_radix_be (buf , radix) . map (| u | BigInt :: from_biguint (sign , u)) } # [doc = " Creates and initializes a `BigInt`. Each u8 of the input slice is"] # [doc = " interpreted as one digit of the number"] # [doc = " and must therefore be less than `radix`."] # [doc = ""] # [doc = " The bytes are in little-endian byte order."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, Sign};"] # [doc = ""] # [doc = " let inbase190 = vec![14, 12, 125, 33, 15];"] # [doc = " let a = BigInt::from_radix_be(Sign::Minus, &inbase190, 190).unwrap();"] # [doc = " assert_eq!(a.to_radix_be(190), (Sign::Minus, inbase190));"] # [doc = " ```"] pub fn from_radix_le (sign : Sign , buf : & [u8] , radix : u32) -> Option < BigInt > { BigUint :: from_radix_le (buf , radix) . map (| u | BigInt :: from_biguint (sign , u)) } # [doc = " Returns the sign and the byte representation of the `BigInt` in big-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{ToBigInt, Sign};"] # [doc = ""] # [doc = " let i = -1125.to_bigint().unwrap();"] # [doc = " assert_eq!(i.to_bytes_be(), (Sign::Minus, vec![4, 101]));"] # [doc = " ```"] # [inline] pub fn to_bytes_be (& self) -> (Sign , Vec < u8 >) { (self . sign , self . data . to_bytes_be ()) } # [doc = " Returns the sign and the byte representation of the `BigInt` in little-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{ToBigInt, Sign};"] # [doc = ""] # [doc = " let i = -1125.to_bigint().unwrap();"] # [doc = " assert_eq!(i.to_bytes_le(), (Sign::Minus, vec![101, 4]));"] # [doc = " ```"] # [inline] pub fn to_bytes_le (& self) -> (Sign , Vec < u8 >) { (self . sign , self . data . to_bytes_le ()) } # [doc = " Returns the sign and the `u32` digits representation of the `BigInt` ordered least"] # [doc = " significant digit first."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, Sign};"] # [doc = ""] # [doc = " assert_eq!(BigInt::from(-1125).to_u32_digits(), (Sign::Minus, vec![1125]));"] # [doc = " assert_eq!(BigInt::from(4294967295u32).to_u32_digits(), (Sign::Plus, vec![4294967295]));"] # [doc = " assert_eq!(BigInt::from(4294967296u64).to_u32_digits(), (Sign::Plus, vec![0, 1]));"] # [doc = " assert_eq!(BigInt::from(-112500000000i64).to_u32_digits(), (Sign::Minus, vec![830850304, 26]));"] # [doc = " assert_eq!(BigInt::from(112500000000i64).to_u32_digits(), (Sign::Plus, vec![830850304, 26]));"] # [doc = " ```"] # [inline] pub fn to_u32_digits (& self) -> (Sign , Vec < u32 >) { (self . sign , self . data . to_u32_digits ()) } # [doc = " Returns the two's-complement byte representation of the `BigInt` in big-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::ToBigInt;"] # [doc = ""] # [doc = " let i = -1125.to_bigint().unwrap();"] # [doc = " assert_eq!(i.to_signed_bytes_be(), vec![251, 155]);"] # [doc = " ```"] # [inline] pub fn to_signed_bytes_be (& self) -> Vec < u8 > { let mut bytes = self . data . to_bytes_be () ; let first_byte = bytes . first () . cloned () . unwrap_or (0) ; if first_byte > 0x7f && ! (first_byte == 0x80 && bytes . iter () . skip (1) . all (Zero :: is_zero) && self . sign == Sign :: Minus) { bytes . insert (0 , 0) ; } if self . sign == Sign :: Minus { twos_complement_be (& mut bytes) ; } bytes } # [doc = " Returns the two's-complement byte representation of the `BigInt` in little-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::ToBigInt;"] # [doc = ""] # [doc = " let i = -1125.to_bigint().unwrap();"] # [doc = " assert_eq!(i.to_signed_bytes_le(), vec![155, 251]);"] # [doc = " ```"] # [inline] pub fn to_signed_bytes_le (& self) -> Vec < u8 > { let mut bytes = self . data . to_bytes_le () ; let last_byte = bytes . last () . cloned () . unwrap_or (0) ; if last_byte > 0x7f && ! (last_byte == 0x80 && bytes . iter () . rev () . skip (1) . all (Zero :: is_zero) && self . sign == Sign :: Minus) { bytes . push (0) ; } if self . sign == Sign :: Minus { twos_complement_le (& mut bytes) ; } bytes } # [doc = " Returns the integer formatted as a string in the given radix."] # [doc = " `radix` must be in the range `2...36`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigInt;"] # [doc = ""] # [doc = " let i = BigInt::parse_bytes(b\"ff\", 16).unwrap();"] # [doc = " assert_eq!(i.to_str_radix(16), \"ff\");"] # [doc = " ```"] # [inline] pub fn to_str_radix (& self , radix : u32) -> String { let mut v = to_str_radix_reversed (& self . data , radix) ; if self . is_negative () { v . push (b'-') ; } v . reverse () ; unsafe { String :: from_utf8_unchecked (v) } } # [doc = " Returns the integer in the requested base in big-endian digit order."] # [doc = " The output is not given in a human readable alphabet but as a zero"] # [doc = " based u8 number."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, Sign};"] # [doc = ""] # [doc = " assert_eq!(BigInt::from(-0xFFFFi64).to_radix_be(159),"] # [doc = "            (Sign::Minus, vec![2, 94, 27]));"] # [doc = " // 0xFFFF = 65535 = 2*(159^2) + 94*159 + 27"] # [doc = " ```"] # [inline] pub fn to_radix_be (& self , radix : u32) -> (Sign , Vec < u8 >) { (self . sign , self . data . to_radix_be (radix)) } # [doc = " Returns the integer in the requested base in little-endian digit order."] # [doc = " The output is not given in a human readable alphabet but as a zero"] # [doc = " based u8 number."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigInt, Sign};"] # [doc = ""] # [doc = " assert_eq!(BigInt::from(-0xFFFFi64).to_radix_le(159),"] # [doc = "            (Sign::Minus, vec![27, 94, 2]));"] # [doc = " // 0xFFFF = 65535 = 27 + 94*159 + 2*(159^2)"] # [doc = " ```"] # [inline] pub fn to_radix_le (& self , radix : u32) -> (Sign , Vec < u8 >) { (self . sign , self . data . to_radix_le (radix)) } # [doc = " Returns the sign of the `BigInt` as a `Sign`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{ToBigInt, Sign};"] # [doc = ""] # [doc = " assert_eq!(ToBigInt::to_bigint(&1234).unwrap().sign(), Sign::Plus);"] # [doc = " assert_eq!(ToBigInt::to_bigint(&-4321).unwrap().sign(), Sign::Minus);"] # [doc = " assert_eq!(ToBigInt::to_bigint(&0).unwrap().sign(), Sign::NoSign);"] # [doc = " ```"] # [inline] pub fn sign (& self) -> Sign { self . sign } # [doc = " Determines the fewest bits necessary to express the `BigInt`,"] # [doc = " not including the sign."] # [inline] pub fn bits (& self) -> usize { self . data . bits () } # [doc = " Converts this `BigInt` into a `BigUint`, if it's not negative."] # [inline] pub fn to_biguint (& self) -> Option < BigUint > { match self . sign { Plus => Some (self . data . clone ()) , NoSign => Some (Zero :: zero ()) , Minus => None , } } # [inline] pub fn checked_add (& self , v : & BigInt) -> Option < BigInt > { Some (self . add (v)) } # [inline] pub fn checked_sub (& self , v : & BigInt) -> Option < BigInt > { Some (self . sub (v)) } # [inline] pub fn checked_mul (& self , v : & BigInt) -> Option < BigInt > { Some (self . mul (v)) } # [inline] pub fn checked_div (& self , v : & BigInt) -> Option < BigInt > { if v . is_zero () { return None ; } Some (self . div (v)) } # [doc = " Returns `(self ^ exponent) mod modulus`"] # [doc = ""] # [doc = " Note that this rounds like `mod_floor`, not like the `%` operator,"] # [doc = " which makes a difference when given a negative `self` or `modulus`."] # [doc = " The result will be in the interval `[0, modulus)` for `modulus > 0`,"] # [doc = " or in the interval `(modulus, 0]` for `modulus < 0`"] # [doc = ""] # [doc = " Panics if the exponent is negative or the modulus is zero."] pub fn modpow (& self , exponent : & Self , modulus : & Self) -> Self { assert ! (! exponent . is_negative () , "negative exponentiation is not supported!") ; assert ! (! modulus . is_zero () , "divide by zero!") ; let result = self . data . modpow (& exponent . data , & modulus . data) ; if result . is_zero () { return BigInt :: zero () ; } let (sign , mag) = match (self . is_negative () && exponent . is_odd () , modulus . is_negative () ,) { (false , false) => (Plus , result) , (true , false) => (Plus , & modulus . data - result) , (false , true) => (Minus , & modulus . data - result) , (true , true) => (Minus , result) , } ; BigInt :: from_biguint (sign , mag) } # [doc = " Returns the truncated principal square root of `self` --"] # [doc = " see [Roots::sqrt](https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#method.sqrt)."] pub fn sqrt (& self) -> Self { Roots :: sqrt (self) } # [doc = " Returns the truncated principal cube root of `self` --"] # [doc = " see [Roots::cbrt](https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#method.cbrt)."] pub fn cbrt (& self) -> Self { Roots :: cbrt (self) } # [doc = " Returns the truncated principal `n`th root of `self` --"] # [doc = " See [Roots::nth_root](https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#tymethod.nth_root)."] pub fn nth_root (& self , n : u32) -> Self { Roots :: nth_root (self , n) } } impl_sum_iter_type ! (BigInt) ; impl_product_iter_type ! (BigInt) ; # [doc = " Perform in-place two's complement of the given binary representation,"] # [doc = " in little-endian byte order."] # [inline] fn twos_complement_le (digits : & mut [u8]) { twos_complement (digits) } # [doc = " Perform in-place two's complement of the given binary representation"] # [doc = " in big-endian byte order."] # [inline] fn twos_complement_be (digits : & mut [u8]) { twos_complement (digits . iter_mut () . rev ()) } # [doc = " Perform in-place two's complement of the given digit iterator"] # [doc = " starting from the least significant byte."] # [inline] fn twos_complement < 'a , I > (digits : I) where I : IntoIterator < Item = & 'a mut u8 > , { let mut carry = true ; for d in digits { * d = d . not () ; if carry { * d = d . wrapping_add (1) ; carry = d . is_zero () ; } } } # [test] fn test_from_biguint () { fn check (inp_s : Sign , inp_n : usize , ans_s : Sign , ans_n : usize) { let inp = BigInt :: from_biguint (inp_s , FromPrimitive :: from_usize (inp_n) . unwrap ()) ; let ans = BigInt { sign : ans_s , data : FromPrimitive :: from_usize (ans_n) . unwrap () , } ; assert_eq ! (inp , ans) ; } check (Plus , 1 , Plus , 1) ; check (Plus , 0 , NoSign , 0) ; check (Minus , 1 , Minus , 1) ; check (NoSign , 1 , NoSign , 0) ; } # [test] fn test_from_slice () { fn check (inp_s : Sign , inp_n : u32 , ans_s : Sign , ans_n : u32) { let inp = BigInt :: from_slice (inp_s , & [inp_n]) ; let ans = BigInt { sign : ans_s , data : FromPrimitive :: from_u32 (ans_n) . unwrap () , } ; assert_eq ! (inp , ans) ; } check (Plus , 1 , Plus , 1) ; check (Plus , 0 , NoSign , 0) ; check (Minus , 1 , Minus , 1) ; check (NoSign , 1 , NoSign , 0) ; } # [test] fn test_assign_from_slice () { fn check (inp_s : Sign , inp_n : u32 , ans_s : Sign , ans_n : u32) { let mut inp = BigInt :: from_slice (Minus , & [2627_u32 , 0_u32 , 9182_u32 , 42_u32]) ; inp . assign_from_slice (inp_s , & [inp_n]) ; let ans = BigInt { sign : ans_s , data : FromPrimitive :: from_u32 (ans_n) . unwrap () , } ; assert_eq ! (inp , ans) ; } check (Plus , 1 , Plus , 1) ; check (Plus , 0 , NoSign , 0) ; check (Minus , 1 , Minus , 1) ; check (NoSign , 1 , NoSign , 0) ; } } mod biguint { # [allow (deprecated , unused_imports)] use std :: ascii :: AsciiExt ; use std :: borrow :: Cow ; use std :: cmp ; use std :: cmp :: Ordering :: { self , Equal , Greater , Less } ; use std :: default :: Default ; use std :: fmt ; use std :: iter :: { Product , Sum } ; use std :: mem ; use std :: ops :: { Add , AddAssign , BitAnd , BitAndAssign , BitOr , BitOrAssign , BitXor , BitXorAssign , Div , DivAssign , Mul , MulAssign , Neg , Rem , RemAssign , Shl , ShlAssign , Shr , ShrAssign , Sub , SubAssign , } ; use std :: str :: { self , FromStr } ; use std :: { f32 , f64 } ; use std :: { u64 , u8 } ; # [cfg (feature = "serde")] use serde ; use integer :: { Integer , Roots } ; use traits :: { CheckedAdd , CheckedDiv , CheckedMul , CheckedSub , Float , FromPrimitive , Num , One , Pow , ToPrimitive , Unsigned , Zero , } ; use big_digit :: { self , BigDigit } ; # [path = "algorithms.rs"] mod algorithms { use std :: borrow :: Cow ; use std :: cmp ; use std :: cmp :: Ordering :: { self , Equal , Greater , Less } ; use std :: iter :: repeat ; use std :: mem ; use traits ; use traits :: { One , Zero } ; use biguint :: BigUint ; use bigint :: BigInt ; use bigint :: Sign ; use bigint :: Sign :: { Minus , NoSign , Plus } ; use big_digit :: { self , BigDigit , DoubleBigDigit , SignedDoubleBigDigit } ; # [inline] fn adc (a : BigDigit , b : BigDigit , acc : & mut DoubleBigDigit) -> BigDigit { * acc += DoubleBigDigit :: from (a) ; * acc += DoubleBigDigit :: from (b) ; let lo = * acc as BigDigit ; * acc >>= big_digit :: BITS ; lo } # [inline] fn sbb (a : BigDigit , b : BigDigit , acc : & mut SignedDoubleBigDigit) -> BigDigit { * acc += SignedDoubleBigDigit :: from (a) ; * acc -= SignedDoubleBigDigit :: from (b) ; let lo = * acc as BigDigit ; * acc >>= big_digit :: BITS ; lo } # [inline] pub fn mac_with_carry (a : BigDigit , b : BigDigit , c : BigDigit , acc : & mut DoubleBigDigit) -> BigDigit { * acc += DoubleBigDigit :: from (a) ; * acc += DoubleBigDigit :: from (b) * DoubleBigDigit :: from (c) ; let lo = * acc as BigDigit ; * acc >>= big_digit :: BITS ; lo } # [inline] pub fn mul_with_carry (a : BigDigit , b : BigDigit , acc : & mut DoubleBigDigit) -> BigDigit { * acc += DoubleBigDigit :: from (a) * DoubleBigDigit :: from (b) ; let lo = * acc as BigDigit ; * acc >>= big_digit :: BITS ; lo } # [doc = " Divide a two digit numerator by a one digit divisor, returns quotient and remainder:"] # [doc = ""] # [doc = " Note: the caller must ensure that both the quotient and remainder will fit into a single digit."] # [doc = " This is _not_ true for an arbitrary numerator/denominator."] # [doc = ""] # [doc = " (This function also matches what the x86 divide instruction does)."] # [inline] fn div_wide (hi : BigDigit , lo : BigDigit , divisor : BigDigit) -> (BigDigit , BigDigit) { debug_assert ! (hi < divisor) ; let lhs = big_digit :: to_doublebigdigit (hi , lo) ; let rhs = DoubleBigDigit :: from (divisor) ; ((lhs / rhs) as BigDigit , (lhs % rhs) as BigDigit) } pub fn div_rem_digit (mut a : BigUint , b : BigDigit) -> (BigUint , BigDigit) { let mut rem = 0 ; for d in a . data . iter_mut () . rev () { let (q , r) = div_wide (rem , * d , b) ; * d = q ; rem = r ; } (a . normalized () , rem) } pub fn rem_digit (a : & BigUint , b : BigDigit) -> BigDigit { let mut rem : DoubleBigDigit = 0 ; for & digit in a . data . iter () . rev () { rem = (rem << big_digit :: BITS) + DoubleBigDigit :: from (digit) ; rem %= DoubleBigDigit :: from (b) ; } rem as BigDigit } # [inline] pub fn __add2 (a : & mut [BigDigit] , b : & [BigDigit]) -> BigDigit { debug_assert ! (a . len () >= b . len ()) ; let mut carry = 0 ; let (a_lo , a_hi) = a . split_at_mut (b . len ()) ; for (a , b) in a_lo . iter_mut () . zip (b) { * a = adc (* a , * b , & mut carry) ; } if carry != 0 { for a in a_hi { * a = adc (* a , 0 , & mut carry) ; if carry == 0 { break ; } } } carry as BigDigit } # [doc = " Two argument addition of raw slices:"] # [doc = " a += b"] # [doc = ""] # [doc = " The caller _must_ ensure that a is big enough to store the result - typically this means"] # [doc = " resizing a to max(a.len(), b.len()) + 1, to fit a possible carry."] pub fn add2 (a : & mut [BigDigit] , b : & [BigDigit]) { let carry = __add2 (a , b) ; debug_assert ! (carry == 0) ; } pub fn sub2 (a : & mut [BigDigit] , b : & [BigDigit]) { let mut borrow = 0 ; let len = cmp :: min (a . len () , b . len ()) ; let (a_lo , a_hi) = a . split_at_mut (len) ; let (b_lo , b_hi) = b . split_at (len) ; for (a , b) in a_lo . iter_mut () . zip (b_lo) { * a = sbb (* a , * b , & mut borrow) ; } if borrow != 0 { for a in a_hi { * a = sbb (* a , 0 , & mut borrow) ; if borrow == 0 { break ; } } } assert ! (borrow == 0 && b_hi . iter () . all (| x | * x == 0) , "Cannot subtract b from a because b is larger than a.") ; } # [inline] pub fn __sub2rev (a : & [BigDigit] , b : & mut [BigDigit]) -> BigDigit { debug_assert ! (b . len () == a . len ()) ; let mut borrow = 0 ; for (ai , bi) in a . iter () . zip (b) { * bi = sbb (* ai , * bi , & mut borrow) ; } borrow as BigDigit } pub fn sub2rev (a : & [BigDigit] , b : & mut [BigDigit]) { debug_assert ! (b . len () >= a . len ()) ; let len = cmp :: min (a . len () , b . len ()) ; let (a_lo , a_hi) = a . split_at (len) ; let (b_lo , b_hi) = b . split_at_mut (len) ; let borrow = __sub2rev (a_lo , b_lo) ; assert ! (a_hi . is_empty ()) ; assert ! (borrow == 0 && b_hi . iter () . all (| x | * x == 0) , "Cannot subtract b from a because b is larger than a.") ; } pub fn sub_sign (a : & [BigDigit] , b : & [BigDigit]) -> (Sign , BigUint) { let a = & a [.. a . iter () . rposition (| & x | x != 0) . map_or (0 , | i | i + 1)] ; let b = & b [.. b . iter () . rposition (| & x | x != 0) . map_or (0 , | i | i + 1)] ; match cmp_slice (a , b) { Greater => { let mut a = a . to_vec () ; sub2 (& mut a , b) ; (Plus , BigUint :: new (a)) } Less => { let mut b = b . to_vec () ; sub2 (& mut b , a) ; (Minus , BigUint :: new (b)) } _ => (NoSign , Zero :: zero ()) , } } # [doc = " Three argument multiply accumulate:"] # [doc = " acc += b * c"] pub fn mac_digit (acc : & mut [BigDigit] , b : & [BigDigit] , c : BigDigit) { if c == 0 { return ; } let mut carry = 0 ; let (a_lo , a_hi) = acc . split_at_mut (b . len ()) ; for (a , & b) in a_lo . iter_mut () . zip (b) { * a = mac_with_carry (* a , b , c , & mut carry) ; } let mut a = a_hi . iter_mut () ; while carry != 0 { let a = a . next () . expect ("carry overflow during multiplication!") ; * a = adc (* a , 0 , & mut carry) ; } } # [doc = " Three argument multiply accumulate:"] # [doc = " acc += b * c"] fn mac3 (acc : & mut [BigDigit] , b : & [BigDigit] , c : & [BigDigit]) { let (x , y) = if b . len () < c . len () { (b , c) } else { (c , b) } ; if x . len () <= 32 { for (i , xi) in x . iter () . enumerate () { mac_digit (& mut acc [i ..] , y , * xi) ; } } else if x . len () <= 256 { let b = x . len () / 2 ; let (x0 , x1) = x . split_at (b) ; let (y0 , y1) = y . split_at (b) ; let len = x1 . len () + y1 . len () + 1 ; let mut p = BigUint { data : vec ! [0 ; len] } ; mac3 (& mut p . data [..] , x1 , y1) ; p . normalize () ; add2 (& mut acc [b ..] , & p . data [..]) ; add2 (& mut acc [b * 2 ..] , & p . data [..]) ; p . data . truncate (0) ; p . data . extend (repeat (0) . take (len)) ; mac3 (& mut p . data [..] , x0 , y0) ; p . normalize () ; add2 (& mut acc [..] , & p . data [..]) ; add2 (& mut acc [b ..] , & p . data [..]) ; let (j0_sign , j0) = sub_sign (x1 , x0) ; let (j1_sign , j1) = sub_sign (y1 , y0) ; match j0_sign * j1_sign { Plus => { p . data . truncate (0) ; p . data . extend (repeat (0) . take (len)) ; mac3 (& mut p . data [..] , & j0 . data [..] , & j1 . data [..]) ; p . normalize () ; sub2 (& mut acc [b ..] , & p . data [..]) ; } Minus => { mac3 (& mut acc [b ..] , & j0 . data [..] , & j1 . data [..]) ; } NoSign => () , } } else { let i = y . len () / 3 + 1 ; let x0_len = cmp :: min (x . len () , i) ; let x1_len = cmp :: min (x . len () - x0_len , i) ; let y0_len = i ; let y1_len = cmp :: min (y . len () - y0_len , i) ; let x0 = BigInt :: from_slice (Plus , & x [.. x0_len]) ; let x1 = BigInt :: from_slice (Plus , & x [x0_len .. x0_len + x1_len]) ; let x2 = BigInt :: from_slice (Plus , & x [x0_len + x1_len ..]) ; let y0 = BigInt :: from_slice (Plus , & y [.. y0_len]) ; let y1 = BigInt :: from_slice (Plus , & y [y0_len .. y0_len + y1_len]) ; let y2 = BigInt :: from_slice (Plus , & y [y0_len + y1_len ..]) ; let p = & x0 + & x2 ; let q = & y0 + & y2 ; let p2 = & p - & x1 ; let q2 = & q - & y1 ; let r0 = & x0 * & y0 ; let r4 = & x2 * & y2 ; let r1 = (p + x1) * (q + y1) ; let r2 = & p2 * & q2 ; let r3 = ((p2 + x2) * 2 - x0) * ((q2 + y2) * 2 - y0) ; let mut comp3 : BigInt = (r3 - & r1) / 3 ; let mut comp1 : BigInt = (r1 - & r2) / 2 ; let mut comp2 : BigInt = r2 - & r0 ; comp3 = (& comp2 - comp3) / 2 + & r4 * 2 ; comp2 += & comp1 - & r4 ; comp1 -= & comp3 ; let result = r0 + (comp1 << (32 * i)) + (comp2 << (2 * 32 * i)) + (comp3 << (3 * 32 * i)) + (r4 << (4 * 32 * i)) ; let result_pos = result . to_biguint () . unwrap () ; add2 (& mut acc [..] , & result_pos . data) ; } } pub fn mul3 (x : & [BigDigit] , y : & [BigDigit]) -> BigUint { let len = x . len () + y . len () + 1 ; let mut prod = BigUint { data : vec ! [0 ; len] } ; mac3 (& mut prod . data [..] , x , y) ; prod . normalized () } pub fn scalar_mul (a : & mut [BigDigit] , b : BigDigit) -> BigDigit { let mut carry = 0 ; for a in a . iter_mut () { * a = mul_with_carry (* a , b , & mut carry) ; } carry as BigDigit } pub fn div_rem (mut u : BigUint , mut d : BigUint) -> (BigUint , BigUint) { if d . is_zero () { panic ! () } if u . is_zero () { return (Zero :: zero () , Zero :: zero ()) ; } if d . data . len () == 1 { if d . data == [1] { return (u , Zero :: zero ()) ; } let (div , rem) = div_rem_digit (u , d . data [0]) ; d . data . clear () ; d += rem ; return (div , d) ; } match u . cmp (& d) { Less => return (Zero :: zero () , u) , Equal => { u . set_one () ; return (u , Zero :: zero ()) ; } Greater => { } } let shift = d . data . last () . unwrap () . leading_zeros () as usize ; let (q , r) = if shift == 0 { div_rem_core (u , & d) } else { div_rem_core (u << shift , & (d << shift)) } ; (q , r >> shift) } pub fn div_rem_ref (u : & BigUint , d : & BigUint) -> (BigUint , BigUint) { if d . is_zero () { panic ! () } if u . is_zero () { return (Zero :: zero () , Zero :: zero ()) ; } if d . data . len () == 1 { if d . data == [1] { return (u . clone () , Zero :: zero ()) ; } let (div , rem) = div_rem_digit (u . clone () , d . data [0]) ; return (div , rem . into ()) ; } match u . cmp (d) { Less => return (Zero :: zero () , u . clone ()) , Equal => return (One :: one () , Zero :: zero ()) , Greater => { } } let shift = d . data . last () . unwrap () . leading_zeros () as usize ; let (q , r) = if shift == 0 { div_rem_core (u . clone () , d) } else { div_rem_core (u << shift , & (d << shift)) } ; (q , r >> shift) } # [doc = " an implementation of Knuth, TAOCP vol 2 section 4.3, algorithm D"] # [doc = ""] # [doc = " # Correctness"] # [doc = ""] # [doc = " This function requires the following conditions to run correctly and/or effectively"] # [doc = ""] # [doc = " - `a > b`"] # [doc = " - `d.data.len() > 1`"] # [doc = " - `d.data.last().unwrap().leading_zeros() == 0`"] fn div_rem_core (mut a : BigUint , b : & BigUint) -> (BigUint , BigUint) { let bn = * b . data . last () . unwrap () ; let q_len = a . data . len () - b . data . len () + 1 ; let mut q = BigUint { data : vec ! [0 ; q_len] , } ; let mut tmp = BigUint { data : Vec :: with_capacity (2) , } ; for j in (0 .. q_len) . rev () { let offset = j + b . data . len () - 1 ; if offset >= a . data . len () { continue ; } let mut a0 = tmp ; a0 . data . truncate (0) ; a0 . data . extend (a . data [offset ..] . iter () . cloned ()) ; let (mut q0 , _) = div_rem_digit (a0 , bn) ; let mut prod = b * & q0 ; while cmp_slice (& prod . data [..] , & a . data [j ..]) == Greater { let one : BigUint = One :: one () ; q0 -= one ; prod -= b ; } add2 (& mut q . data [j ..] , & q0 . data [..]) ; sub2 (& mut a . data [j ..] , & prod . data [..]) ; a . normalize () ; tmp = q0 ; } debug_assert ! (a < * b) ; (q . normalized () , a) } # [doc = " Find last set bit"] # [doc = " fls(0) == 0, fls(u32::MAX) == 32"] pub fn fls < T : traits :: PrimInt > (v : T) -> usize { mem :: size_of :: < T > () * 8 - v . leading_zeros () as usize } pub fn ilog2 < T : traits :: PrimInt > (v : T) -> usize { fls (v) - 1 } # [inline] pub fn biguint_shl (n : Cow < BigUint > , bits : usize) -> BigUint { let n_unit = bits / big_digit :: BITS ; let mut data = match n_unit { 0 => n . into_owned () . data , _ => { let len = n_unit + n . data . len () + 1 ; let mut data = Vec :: with_capacity (len) ; data . extend (repeat (0) . take (n_unit)) ; data . extend (n . data . iter () . cloned ()) ; data } } ; let n_bits = bits % big_digit :: BITS ; if n_bits > 0 { let mut carry = 0 ; for elem in data [n_unit ..] . iter_mut () { let new_carry = * elem >> (big_digit :: BITS - n_bits) ; * elem = (* elem << n_bits) | carry ; carry = new_carry ; } if carry != 0 { data . push (carry) ; } } BigUint :: new (data) } # [inline] pub fn biguint_shr (n : Cow < BigUint > , bits : usize) -> BigUint { let n_unit = bits / big_digit :: BITS ; if n_unit >= n . data . len () { return Zero :: zero () ; } let mut data = match n { Cow :: Borrowed (n) => n . data [n_unit ..] . to_vec () , Cow :: Owned (mut n) => { n . data . drain (.. n_unit) ; n . data } } ; let n_bits = bits % big_digit :: BITS ; if n_bits > 0 { let mut borrow = 0 ; for elem in data . iter_mut () . rev () { let new_borrow = * elem << (big_digit :: BITS - n_bits) ; * elem = (* elem >> n_bits) | borrow ; borrow = new_borrow ; } } BigUint :: new (data) } pub fn cmp_slice (a : & [BigDigit] , b : & [BigDigit]) -> Ordering { debug_assert ! (a . last () != Some (& 0)) ; debug_assert ! (b . last () != Some (& 0)) ; let (a_len , b_len) = (a . len () , b . len ()) ; if a_len < b_len { return Less ; } if a_len > b_len { return Greater ; } for (& ai , & bi) in a . iter () . rev () . zip (b . iter () . rev ()) { if ai < bi { return Less ; } if ai > bi { return Greater ; } } Equal } # [cfg (test)] mod algorithm_tests { use big_digit :: BigDigit ; use traits :: Num ; use Sign :: Plus ; use { BigInt , BigUint } ; # [test] fn test_sub_sign () { use super :: sub_sign ; fn sub_sign_i (a : & [BigDigit] , b : & [BigDigit]) -> BigInt { let (sign , val) = sub_sign (a , b) ; BigInt :: from_biguint (sign , val) } let a = BigUint :: from_str_radix ("265252859812191058636308480000000" , 10) . unwrap () ; let b = BigUint :: from_str_radix ("26525285981219105863630848000000" , 10) . unwrap () ; let a_i = BigInt :: from_biguint (Plus , a . clone ()) ; let b_i = BigInt :: from_biguint (Plus , b . clone ()) ; assert_eq ! (sub_sign_i (& a . data [..] , & b . data [..]) , & a_i - & b_i) ; assert_eq ! (sub_sign_i (& b . data [..] , & a . data [..]) , & b_i - & a_i) ; } } } # [path = "monty.rs"] mod monty { use integer :: Integer ; use traits :: Zero ; use biguint :: BigUint ; struct MontyReducer < 'a > { n : & 'a BigUint , n0inv : u32 , } fn inv_mod_u32 (num : u32) -> u32 { assert ! (num % 2 != 0) ; let mut a : i64 = i64 :: from (num) ; let mut b : i64 = i64 :: from (u32 :: max_value ()) + 1 ; let mut u = 1 ; let mut w = 0 ; while b != 0 { let q = a / b ; let r = a % b ; a = b ; b = r ; let m = u - w * q ; u = w ; w = m ; } assert ! (a == 1) ; u as u32 } impl < 'a > MontyReducer < 'a > { fn new (n : & 'a BigUint) -> Self { let n0inv = inv_mod_u32 (n . data [0]) ; MontyReducer { n : n , n0inv : n0inv } } } fn monty_redc (a : BigUint , mr : & MontyReducer) -> BigUint { let mut c = a . data ; let n = & mr . n . data ; let n_size = n . len () ; c . resize (2 * n_size + 2 , 0) ; let mu = 0u32 . wrapping_sub (mr . n0inv) ; for i in 0 .. n_size { let q_i = c [i] . wrapping_mul (mu) ; super :: algorithms :: mac_digit (& mut c [i ..] , n , q_i) ; } let ret = BigUint :: new (c [n_size ..] . to_vec ()) ; if ret < * mr . n { ret } else { ret - mr . n } } fn monty_mult (a : BigUint , b : & BigUint , mr : & MontyReducer) -> BigUint { monty_redc (a * b , mr) } fn monty_sqr (a : BigUint , mr : & MontyReducer) -> BigUint { monty_redc (& a * & a , mr) } pub fn monty_modpow (a : & BigUint , exp : & BigUint , modulus : & BigUint) -> BigUint { let mr = MontyReducer :: new (modulus) ; let mut v = vec ! [0 ; modulus . data . len ()] ; v . push (1) ; let r = BigUint :: new (v) ; let mut apri = a * & r % modulus ; let mut ans = & r % modulus ; let mut e = exp . clone () ; while ! e . is_zero () { if e . is_odd () { ans = monty_mult (ans , & apri , & mr) ; } apri = monty_sqr (apri , & mr) ; e >>= 1 ; } monty_redc (ans , & mr) } } use self :: algorithms :: { __add2 , __sub2rev , add2 , sub2 , sub2rev } ; use self :: algorithms :: { biguint_shl , biguint_shr } ; use self :: algorithms :: { cmp_slice , fls , ilog2 } ; use self :: algorithms :: { div_rem , div_rem_digit , div_rem_ref , rem_digit } ; use self :: algorithms :: { mac_with_carry , mul3 , scalar_mul } ; use self :: monty :: monty_modpow ; use UsizePromotion ; use ParseBigIntError ; # [cfg (feature = "quickcheck")] use quickcheck :: { Arbitrary , Gen } ; # [doc = " A big unsigned integer type."] # [derive (Clone , Debug , Hash)] pub struct BigUint { data : Vec < BigDigit > , } # [cfg (feature = "quickcheck")] impl Arbitrary for BigUint { fn arbitrary < G : Gen > (g : & mut G) -> Self { Self :: new (Vec :: < u32 > :: arbitrary (g)) } # [allow (bare_trait_objects)] fn shrink (& self) -> Box < Iterator < Item = Self > > { Box :: new (self . data . shrink () . map (BigUint :: new)) } } impl PartialEq for BigUint { # [inline] fn eq (& self , other : & BigUint) -> bool { match self . cmp (other) { Equal => true , _ => false , } } } impl Eq for BigUint { } impl PartialOrd for BigUint { # [inline] fn partial_cmp (& self , other : & BigUint) -> Option < Ordering > { Some (self . cmp (other)) } } impl Ord for BigUint { # [inline] fn cmp (& self , other : & BigUint) -> Ordering { cmp_slice (& self . data [..] , & other . data [..]) } } impl Default for BigUint { # [inline] fn default () -> BigUint { Zero :: zero () } } impl fmt :: Display for BigUint { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (true , "" , & self . to_str_radix (10)) } } impl fmt :: LowerHex for BigUint { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (true , "0x" , & self . to_str_radix (16)) } } impl fmt :: UpperHex for BigUint { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { let mut s = self . to_str_radix (16) ; s . make_ascii_uppercase () ; f . pad_integral (true , "0x" , & s) } } impl fmt :: Binary for BigUint { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (true , "0b" , & self . to_str_radix (2)) } } impl fmt :: Octal for BigUint { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { f . pad_integral (true , "0o" , & self . to_str_radix (8)) } } impl FromStr for BigUint { type Err = ParseBigIntError ; # [inline] fn from_str (s : & str) -> Result < BigUint , ParseBigIntError > { BigUint :: from_str_radix (s , 10) } } fn from_bitwise_digits_le (v : & [u8] , bits : usize) -> BigUint { debug_assert ! (! v . is_empty () && bits <= 8 && big_digit :: BITS % bits == 0) ; debug_assert ! (v . iter () . all (|& c | BigDigit :: from (c) < (1 << bits))) ; let digits_per_big_digit = big_digit :: BITS / bits ; let data = v . chunks (digits_per_big_digit) . map (| chunk | { chunk . iter () . rev () . fold (0 , | acc , & c | (acc << bits) | BigDigit :: from (c)) }) . collect () ; BigUint :: new (data) } fn from_inexact_bitwise_digits_le (v : & [u8] , bits : usize) -> BigUint { debug_assert ! (! v . is_empty () && bits <= 8 && big_digit :: BITS % bits != 0) ; debug_assert ! (v . iter () . all (|& c | BigDigit :: from (c) < (1 << bits))) ; let big_digits = (v . len () * bits + big_digit :: BITS - 1) / big_digit :: BITS ; let mut data = Vec :: with_capacity (big_digits) ; let mut d = 0 ; let mut dbits = 0 ; for & c in v { d |= BigDigit :: from (c) << dbits ; dbits += bits ; if dbits >= big_digit :: BITS { data . push (d) ; dbits -= big_digit :: BITS ; d = BigDigit :: from (c) >> (bits - dbits) ; } } if dbits > 0 { debug_assert ! (dbits < big_digit :: BITS) ; data . push (d as BigDigit) ; } BigUint :: new (data) } fn from_radix_digits_be (v : & [u8] , radix : u32) -> BigUint { debug_assert ! (! v . is_empty () && ! radix . is_power_of_two ()) ; debug_assert ! (v . iter () . all (|& c | u32 :: from (c) < radix)) ; let bits = f64 :: from (radix) . log2 () * v . len () as f64 ; let big_digits = (bits / big_digit :: BITS as f64) . ceil () ; let mut data = Vec :: with_capacity (big_digits as usize) ; let (base , power) = get_radix_base (radix) ; let radix = radix as BigDigit ; let r = v . len () % power ; let i = if r == 0 { power } else { r } ; let (head , tail) = v . split_at (i) ; let first = head . iter () . fold (0 , | acc , & d | acc * radix + BigDigit :: from (d)) ; data . push (first) ; debug_assert ! (tail . len () % power == 0) ; for chunk in tail . chunks (power) { if data . last () != Some (& 0) { data . push (0) ; } let mut carry = 0 ; for d in data . iter_mut () { * d = mac_with_carry (0 , * d , base , & mut carry) ; } debug_assert ! (carry == 0) ; let n = chunk . iter () . fold (0 , | acc , & d | acc * radix + BigDigit :: from (d)) ; add2 (& mut data , & [n]) ; } BigUint :: new (data) } impl Num for BigUint { type FromStrRadixErr = ParseBigIntError ; # [doc = " Creates and initializes a `BigUint`."] fn from_str_radix (s : & str , radix : u32) -> Result < BigUint , ParseBigIntError > { assert ! (2 <= radix && radix <= 36 , "The radix must be within 2...36") ; let mut s = s ; if s . starts_with ('+') { let tail = & s [1 ..] ; if ! tail . starts_with ('+') { s = tail } } if s . is_empty () { return Err (ParseBigIntError :: empty ()) ; } if s . starts_with ('_') { return Err (ParseBigIntError :: invalid ()) ; } let mut v = Vec :: with_capacity (s . len ()) ; for b in s . bytes () { # [allow (unknown_lints , ellipsis_inclusive_range_patterns)] let d = match b { b'0' ..= b'9' => b - b'0' , b'a' ..= b'z' => b - b'a' + 10 , b'A' ..= b'Z' => b - b'A' + 10 , b'_' => continue , _ => u8 :: MAX , } ; if d < radix as u8 { v . push (d) ; } else { return Err (ParseBigIntError :: invalid ()) ; } } let res = if radix . is_power_of_two () { let bits = ilog2 (radix) ; v . reverse () ; if big_digit :: BITS % bits == 0 { from_bitwise_digits_le (& v , bits) } else { from_inexact_bitwise_digits_le (& v , bits) } } else { from_radix_digits_be (& v , radix) } ; Ok (res) } } forward_val_val_binop ! (impl BitAnd for BigUint , bitand) ; forward_ref_val_binop ! (impl BitAnd for BigUint , bitand) ; impl < 'a , 'b > BitAnd < & 'b BigUint > for & 'a BigUint { type Output = BigUint ; # [inline] fn bitand (self , other : & BigUint) -> BigUint { if self . data . len () <= other . data . len () { self . clone () & other } else { other . clone () & self } } } forward_val_assign ! (impl BitAndAssign for BigUint , bitand_assign) ; impl < 'a > BitAnd < & 'a BigUint > for BigUint { type Output = BigUint ; # [inline] fn bitand (mut self , other : & BigUint) -> BigUint { self &= other ; self } } impl < 'a > BitAndAssign < & 'a BigUint > for BigUint { # [inline] fn bitand_assign (& mut self , other : & BigUint) { for (ai , & bi) in self . data . iter_mut () . zip (other . data . iter ()) { * ai &= bi ; } self . data . truncate (other . data . len ()) ; self . normalize () ; } } forward_all_binop_to_val_ref_commutative ! (impl BitOr for BigUint , bitor) ; forward_val_assign ! (impl BitOrAssign for BigUint , bitor_assign) ; impl < 'a > BitOr < & 'a BigUint > for BigUint { type Output = BigUint ; fn bitor (mut self , other : & BigUint) -> BigUint { self |= other ; self } } impl < 'a > BitOrAssign < & 'a BigUint > for BigUint { # [inline] fn bitor_assign (& mut self , other : & BigUint) { for (ai , & bi) in self . data . iter_mut () . zip (other . data . iter ()) { * ai |= bi ; } if other . data . len () > self . data . len () { let extra = & other . data [self . data . len () ..] ; self . data . extend (extra . iter () . cloned ()) ; } } } forward_all_binop_to_val_ref_commutative ! (impl BitXor for BigUint , bitxor) ; forward_val_assign ! (impl BitXorAssign for BigUint , bitxor_assign) ; impl < 'a > BitXor < & 'a BigUint > for BigUint { type Output = BigUint ; fn bitxor (mut self , other : & BigUint) -> BigUint { self ^= other ; self } } impl < 'a > BitXorAssign < & 'a BigUint > for BigUint { # [inline] fn bitxor_assign (& mut self , other : & BigUint) { for (ai , & bi) in self . data . iter_mut () . zip (other . data . iter ()) { * ai ^= bi ; } if other . data . len () > self . data . len () { let extra = & other . data [self . data . len () ..] ; self . data . extend (extra . iter () . cloned ()) ; } self . normalize () ; } } impl Shl < usize > for BigUint { type Output = BigUint ; # [inline] fn shl (self , rhs : usize) -> BigUint { biguint_shl (Cow :: Owned (self) , rhs) } } impl < 'a > Shl < usize > for & 'a BigUint { type Output = BigUint ; # [inline] fn shl (self , rhs : usize) -> BigUint { biguint_shl (Cow :: Borrowed (self) , rhs) } } impl ShlAssign < usize > for BigUint { # [inline] fn shl_assign (& mut self , rhs : usize) { let n = mem :: replace (self , BigUint :: zero ()) ; * self = n << rhs ; } } impl Shr < usize > for BigUint { type Output = BigUint ; # [inline] fn shr (self , rhs : usize) -> BigUint { biguint_shr (Cow :: Owned (self) , rhs) } } impl < 'a > Shr < usize > for & 'a BigUint { type Output = BigUint ; # [inline] fn shr (self , rhs : usize) -> BigUint { biguint_shr (Cow :: Borrowed (self) , rhs) } } impl ShrAssign < usize > for BigUint { # [inline] fn shr_assign (& mut self , rhs : usize) { let n = mem :: replace (self , BigUint :: zero ()) ; * self = n >> rhs ; } } impl Zero for BigUint { # [inline] fn zero () -> BigUint { BigUint :: new (Vec :: new ()) } # [inline] fn set_zero (& mut self) { self . data . clear () ; } # [inline] fn is_zero (& self) -> bool { self . data . is_empty () } } impl One for BigUint { # [inline] fn one () -> BigUint { BigUint :: new (vec ! [1]) } # [inline] fn set_one (& mut self) { self . data . clear () ; self . data . push (1) ; } # [inline] fn is_one (& self) -> bool { self . data [..] == [1] } } impl Unsigned for BigUint { } impl < 'a > Pow < BigUint > for & 'a BigUint { type Output = BigUint ; # [inline] fn pow (self , exp : BigUint) -> Self :: Output { self . pow (& exp) } } impl < 'a , 'b > Pow < & 'b BigUint > for & 'a BigUint { type Output = BigUint ; # [inline] fn pow (self , exp : & BigUint) -> Self :: Output { if self . is_one () || exp . is_zero () { BigUint :: one () } else if self . is_zero () { BigUint :: zero () } else if let Some (exp) = exp . to_u64 () { self . pow (exp) } else { panic ! ("memory overflow") } } } macro_rules ! pow_impl { ($ T : ty) => { impl <'a > Pow <$ T > for &'a BigUint { type Output = BigUint ; # [inline] fn pow (self , mut exp : $ T) -> Self :: Output { if exp == 0 { return BigUint :: one () ; } let mut base = self . clone () ; while exp & 1 == 0 { base = & base * & base ; exp >>= 1 ; } if exp == 1 { return base ; } let mut acc = base . clone () ; while exp > 1 { exp >>= 1 ; base = & base * & base ; if exp & 1 == 1 { acc = & acc * & base ; } } acc } } impl <'a , 'b > Pow <&'b $ T > for &'a BigUint { type Output = BigUint ; # [inline] fn pow (self , exp : &$ T) -> Self :: Output { self . pow (* exp) } } } ; } pow_impl ! (u8) ; pow_impl ! (u16) ; pow_impl ! (u32) ; pow_impl ! (u64) ; pow_impl ! (usize) ; # [cfg (has_i128)] pow_impl ! (u128) ; forward_all_binop_to_val_ref_commutative ! (impl Add for BigUint , add) ; forward_val_assign ! (impl AddAssign for BigUint , add_assign) ; impl < 'a > Add < & 'a BigUint > for BigUint { type Output = BigUint ; fn add (mut self , other : & BigUint) -> BigUint { self += other ; self } } impl < 'a > AddAssign < & 'a BigUint > for BigUint { # [inline] fn add_assign (& mut self , other : & BigUint) { let self_len = self . data . len () ; let carry = if self_len < other . data . len () { let lo_carry = __add2 (& mut self . data [..] , & other . data [.. self_len]) ; self . data . extend_from_slice (& other . data [self_len ..]) ; __add2 (& mut self . data [self_len ..] , & [lo_carry]) } else { __add2 (& mut self . data [..] , & other . data [..]) } ; if carry != 0 { self . data . push (carry) ; } } } promote_unsigned_scalars ! (impl Add for BigUint , add) ; promote_unsigned_scalars_assign ! (impl AddAssign for BigUint , add_assign) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Add < u32 > for BigUint , add) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Add < u64 > for BigUint , add) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val_commutative ! (impl Add < u128 > for BigUint , add) ; impl Add < u32 > for BigUint { type Output = BigUint ; # [inline] fn add (mut self , other : u32) -> BigUint { self += other ; self } } impl AddAssign < u32 > for BigUint { # [inline] fn add_assign (& mut self , other : u32) { if other != 0 { if self . data . is_empty () { self . data . push (0) ; } let carry = __add2 (& mut self . data , & [other as BigDigit]) ; if carry != 0 { self . data . push (carry) ; } } } } impl Add < u64 > for BigUint { type Output = BigUint ; # [inline] fn add (mut self , other : u64) -> BigUint { self += other ; self } } impl AddAssign < u64 > for BigUint { # [inline] fn add_assign (& mut self , other : u64) { let (hi , lo) = big_digit :: from_doublebigdigit (other) ; if hi == 0 { * self += lo ; } else { while self . data . len () < 2 { self . data . push (0) ; } let carry = __add2 (& mut self . data , & [lo , hi]) ; if carry != 0 { self . data . push (carry) ; } } } } # [cfg (has_i128)] impl Add < u128 > for BigUint { type Output = BigUint ; # [inline] fn add (mut self , other : u128) -> BigUint { self += other ; self } } # [cfg (has_i128)] impl AddAssign < u128 > for BigUint { # [inline] fn add_assign (& mut self , other : u128) { if other <= u128 :: from (u64 :: max_value ()) { * self += other as u64 } else { let (a , b , c , d) = u32_from_u128 (other) ; let carry = if a > 0 { while self . data . len () < 4 { self . data . push (0) ; } __add2 (& mut self . data , & [d , c , b , a]) } else { debug_assert ! (b > 0) ; while self . data . len () < 3 { self . data . push (0) ; } __add2 (& mut self . data , & [d , c , b]) } ; if carry != 0 { self . data . push (carry) ; } } } } forward_val_val_binop ! (impl Sub for BigUint , sub) ; forward_ref_ref_binop ! (impl Sub for BigUint , sub) ; forward_val_assign ! (impl SubAssign for BigUint , sub_assign) ; impl < 'a > Sub < & 'a BigUint > for BigUint { type Output = BigUint ; fn sub (mut self , other : & BigUint) -> BigUint { self -= other ; self } } impl < 'a > SubAssign < & 'a BigUint > for BigUint { fn sub_assign (& mut self , other : & 'a BigUint) { sub2 (& mut self . data [..] , & other . data [..]) ; self . normalize () ; } } impl < 'a > Sub < BigUint > for & 'a BigUint { type Output = BigUint ; fn sub (self , mut other : BigUint) -> BigUint { let other_len = other . data . len () ; if other_len < self . data . len () { let lo_borrow = __sub2rev (& self . data [.. other_len] , & mut other . data) ; other . data . extend_from_slice (& self . data [other_len ..]) ; if lo_borrow != 0 { sub2 (& mut other . data [other_len ..] , & [1]) } } else { sub2rev (& self . data [..] , & mut other . data [..]) ; } other . normalized () } } promote_unsigned_scalars ! (impl Sub for BigUint , sub) ; promote_unsigned_scalars_assign ! (impl SubAssign for BigUint , sub_assign) ; forward_all_scalar_binop_to_val_val ! (impl Sub < u32 > for BigUint , sub) ; forward_all_scalar_binop_to_val_val ! (impl Sub < u64 > for BigUint , sub) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Sub < u128 > for BigUint , sub) ; impl Sub < u32 > for BigUint { type Output = BigUint ; # [inline] fn sub (mut self , other : u32) -> BigUint { self -= other ; self } } impl SubAssign < u32 > for BigUint { fn sub_assign (& mut self , other : u32) { sub2 (& mut self . data [..] , & [other as BigDigit]) ; self . normalize () ; } } impl Sub < BigUint > for u32 { type Output = BigUint ; # [inline] fn sub (self , mut other : BigUint) -> BigUint { if other . data . is_empty () { other . data . push (self as BigDigit) ; } else { sub2rev (& [self as BigDigit] , & mut other . data [..]) ; } other . normalized () } } impl Sub < u64 > for BigUint { type Output = BigUint ; # [inline] fn sub (mut self , other : u64) -> BigUint { self -= other ; self } } impl SubAssign < u64 > for BigUint { # [inline] fn sub_assign (& mut self , other : u64) { let (hi , lo) = big_digit :: from_doublebigdigit (other) ; sub2 (& mut self . data [..] , & [lo , hi]) ; self . normalize () ; } } impl Sub < BigUint > for u64 { type Output = BigUint ; # [inline] fn sub (self , mut other : BigUint) -> BigUint { while other . data . len () < 2 { other . data . push (0) ; } let (hi , lo) = big_digit :: from_doublebigdigit (self) ; sub2rev (& [lo , hi] , & mut other . data [..]) ; other . normalized () } } # [cfg (has_i128)] impl Sub < u128 > for BigUint { type Output = BigUint ; # [inline] fn sub (mut self , other : u128) -> BigUint { self -= other ; self } } # [cfg (has_i128)] impl SubAssign < u128 > for BigUint { fn sub_assign (& mut self , other : u128) { let (a , b , c , d) = u32_from_u128 (other) ; sub2 (& mut self . data [..] , & [d , c , b , a]) ; self . normalize () ; } } # [cfg (has_i128)] impl Sub < BigUint > for u128 { type Output = BigUint ; # [inline] fn sub (self , mut other : BigUint) -> BigUint { while other . data . len () < 4 { other . data . push (0) ; } let (a , b , c , d) = u32_from_u128 (self) ; sub2rev (& [d , c , b , a] , & mut other . data [..]) ; other . normalized () } } forward_all_binop_to_ref_ref ! (impl Mul for BigUint , mul) ; forward_val_assign ! (impl MulAssign for BigUint , mul_assign) ; impl < 'a , 'b > Mul < & 'b BigUint > for & 'a BigUint { type Output = BigUint ; # [inline] fn mul (self , other : & BigUint) -> BigUint { mul3 (& self . data [..] , & other . data [..]) } } impl < 'a > MulAssign < & 'a BigUint > for BigUint { # [inline] fn mul_assign (& mut self , other : & 'a BigUint) { * self = & * self * other } } promote_unsigned_scalars ! (impl Mul for BigUint , mul) ; promote_unsigned_scalars_assign ! (impl MulAssign for BigUint , mul_assign) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < u32 > for BigUint , mul) ; forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < u64 > for BigUint , mul) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val_commutative ! (impl Mul < u128 > for BigUint , mul) ; impl Mul < u32 > for BigUint { type Output = BigUint ; # [inline] fn mul (mut self , other : u32) -> BigUint { self *= other ; self } } impl MulAssign < u32 > for BigUint { # [inline] fn mul_assign (& mut self , other : u32) { if other == 0 { self . data . clear () ; } else { let carry = scalar_mul (& mut self . data [..] , other as BigDigit) ; if carry != 0 { self . data . push (carry) ; } } } } impl Mul < u64 > for BigUint { type Output = BigUint ; # [inline] fn mul (mut self , other : u64) -> BigUint { self *= other ; self } } impl MulAssign < u64 > for BigUint { # [inline] fn mul_assign (& mut self , other : u64) { if other == 0 { self . data . clear () ; } else if other <= u64 :: from (BigDigit :: max_value ()) { * self *= other as BigDigit } else { let (hi , lo) = big_digit :: from_doublebigdigit (other) ; * self = mul3 (& self . data [..] , & [lo , hi]) } } } # [cfg (has_i128)] impl Mul < u128 > for BigUint { type Output = BigUint ; # [inline] fn mul (mut self , other : u128) -> BigUint { self *= other ; self } } # [cfg (has_i128)] impl MulAssign < u128 > for BigUint { # [inline] fn mul_assign (& mut self , other : u128) { if other == 0 { self . data . clear () ; } else if other <= u128 :: from (BigDigit :: max_value ()) { * self *= other as BigDigit } else { let (a , b , c , d) = u32_from_u128 (other) ; * self = mul3 (& self . data [..] , & [d , c , b , a]) } } } forward_val_ref_binop ! (impl Div for BigUint , div) ; forward_ref_val_binop ! (impl Div for BigUint , div) ; forward_val_assign ! (impl DivAssign for BigUint , div_assign) ; impl Div < BigUint > for BigUint { type Output = BigUint ; # [inline] fn div (self , other : BigUint) -> BigUint { let (q , _) = div_rem (self , other) ; q } } impl < 'a , 'b > Div < & 'b BigUint > for & 'a BigUint { type Output = BigUint ; # [inline] fn div (self , other : & BigUint) -> BigUint { let (q , _) = self . div_rem (other) ; q } } impl < 'a > DivAssign < & 'a BigUint > for BigUint { # [inline] fn div_assign (& mut self , other : & 'a BigUint) { * self = & * self / other ; } } promote_unsigned_scalars ! (impl Div for BigUint , div) ; promote_unsigned_scalars_assign ! (impl DivAssign for BigUint , div_assign) ; forward_all_scalar_binop_to_val_val ! (impl Div < u32 > for BigUint , div) ; forward_all_scalar_binop_to_val_val ! (impl Div < u64 > for BigUint , div) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Div < u128 > for BigUint , div) ; impl Div < u32 > for BigUint { type Output = BigUint ; # [inline] fn div (self , other : u32) -> BigUint { let (q , _) = div_rem_digit (self , other as BigDigit) ; q } } impl DivAssign < u32 > for BigUint { # [inline] fn div_assign (& mut self , other : u32) { * self = & * self / other ; } } impl Div < BigUint > for u32 { type Output = BigUint ; # [inline] fn div (self , other : BigUint) -> BigUint { match other . data . len () { 0 => panic ! () , 1 => From :: from (self as BigDigit / other . data [0]) , _ => Zero :: zero () , } } } impl Div < u64 > for BigUint { type Output = BigUint ; # [inline] fn div (self , other : u64) -> BigUint { let (q , _) = div_rem (self , From :: from (other)) ; q } } impl DivAssign < u64 > for BigUint { # [inline] fn div_assign (& mut self , other : u64) { let temp = mem :: replace (self , Zero :: zero ()) ; * self = temp / other ; } } impl Div < BigUint > for u64 { type Output = BigUint ; # [inline] fn div (self , other : BigUint) -> BigUint { match other . data . len () { 0 => panic ! () , 1 => From :: from (self / u64 :: from (other . data [0])) , 2 => From :: from (self / big_digit :: to_doublebigdigit (other . data [1] , other . data [0])) , _ => Zero :: zero () , } } } # [cfg (has_i128)] impl Div < u128 > for BigUint { type Output = BigUint ; # [inline] fn div (self , other : u128) -> BigUint { let (q , _) = div_rem (self , From :: from (other)) ; q } } # [cfg (has_i128)] impl DivAssign < u128 > for BigUint { # [inline] fn div_assign (& mut self , other : u128) { * self = & * self / other ; } } # [cfg (has_i128)] impl Div < BigUint > for u128 { type Output = BigUint ; # [inline] fn div (self , other : BigUint) -> BigUint { match other . data . len () { 0 => panic ! () , 1 => From :: from (self / u128 :: from (other . data [0])) , 2 => From :: from (self / u128 :: from (big_digit :: to_doublebigdigit (other . data [1] , other . data [0])) ,) , 3 => From :: from (self / u32_to_u128 (0 , other . data [2] , other . data [1] , other . data [0])) , 4 => From :: from (self / u32_to_u128 (other . data [3] , other . data [2] , other . data [1] , other . data [0]) ,) , _ => Zero :: zero () , } } } forward_val_ref_binop ! (impl Rem for BigUint , rem) ; forward_ref_val_binop ! (impl Rem for BigUint , rem) ; forward_val_assign ! (impl RemAssign for BigUint , rem_assign) ; impl Rem < BigUint > for BigUint { type Output = BigUint ; # [inline] fn rem (self , other : BigUint) -> BigUint { let (_ , r) = div_rem (self , other) ; r } } impl < 'a , 'b > Rem < & 'b BigUint > for & 'a BigUint { type Output = BigUint ; # [inline] fn rem (self , other : & BigUint) -> BigUint { let (_ , r) = self . div_rem (other) ; r } } impl < 'a > RemAssign < & 'a BigUint > for BigUint { # [inline] fn rem_assign (& mut self , other : & BigUint) { * self = & * self % other ; } } promote_unsigned_scalars ! (impl Rem for BigUint , rem) ; promote_unsigned_scalars_assign ! (impl RemAssign for BigUint , rem_assign) ; forward_all_scalar_binop_to_ref_val ! (impl Rem < u32 > for BigUint , rem) ; forward_all_scalar_binop_to_val_val ! (impl Rem < u64 > for BigUint , rem) ; # [cfg (has_i128)] forward_all_scalar_binop_to_val_val ! (impl Rem < u128 > for BigUint , rem) ; impl < 'a > Rem < u32 > for & 'a BigUint { type Output = BigUint ; # [inline] fn rem (self , other : u32) -> BigUint { From :: from (rem_digit (self , other as BigDigit)) } } impl RemAssign < u32 > for BigUint { # [inline] fn rem_assign (& mut self , other : u32) { * self = & * self % other ; } } impl < 'a > Rem < & 'a BigUint > for u32 { type Output = BigUint ; # [inline] fn rem (mut self , other : & 'a BigUint) -> BigUint { self %= other ; From :: from (self) } } macro_rules ! impl_rem_assign_scalar { ($ scalar : ty , $ to_scalar : ident) => { forward_val_assign_scalar ! (impl RemAssign for BigUint , $ scalar , rem_assign) ; impl <'a > RemAssign <&'a BigUint > for $ scalar { # [inline] fn rem_assign (& mut self , other : & BigUint) { * self = match other .$ to_scalar () { None => * self , Some (0) => panic ! () , Some (v) => * self % v } ; } } } } # [cfg (has_i128)] impl_rem_assign_scalar ! (u128 , to_u128) ; impl_rem_assign_scalar ! (usize , to_usize) ; impl_rem_assign_scalar ! (u64 , to_u64) ; impl_rem_assign_scalar ! (u32 , to_u32) ; impl_rem_assign_scalar ! (u16 , to_u16) ; impl_rem_assign_scalar ! (u8 , to_u8) ; # [cfg (has_i128)] impl_rem_assign_scalar ! (i128 , to_i128) ; impl_rem_assign_scalar ! (isize , to_isize) ; impl_rem_assign_scalar ! (i64 , to_i64) ; impl_rem_assign_scalar ! (i32 , to_i32) ; impl_rem_assign_scalar ! (i16 , to_i16) ; impl_rem_assign_scalar ! (i8 , to_i8) ; impl Rem < u64 > for BigUint { type Output = BigUint ; # [inline] fn rem (self , other : u64) -> BigUint { let (_ , r) = div_rem (self , From :: from (other)) ; r } } impl RemAssign < u64 > for BigUint { # [inline] fn rem_assign (& mut self , other : u64) { * self = & * self % other ; } } impl Rem < BigUint > for u64 { type Output = BigUint ; # [inline] fn rem (mut self , other : BigUint) -> BigUint { self %= other ; From :: from (self) } } # [cfg (has_i128)] impl Rem < u128 > for BigUint { type Output = BigUint ; # [inline] fn rem (self , other : u128) -> BigUint { let (_ , r) = div_rem (self , From :: from (other)) ; r } } # [cfg (has_i128)] impl RemAssign < u128 > for BigUint { # [inline] fn rem_assign (& mut self , other : u128) { * self = & * self % other ; } } # [cfg (has_i128)] impl Rem < BigUint > for u128 { type Output = BigUint ; # [inline] fn rem (mut self , other : BigUint) -> BigUint { self %= other ; From :: from (self) } } impl Neg for BigUint { type Output = BigUint ; # [inline] fn neg (self) -> BigUint { panic ! () } } impl < 'a > Neg for & 'a BigUint { type Output = BigUint ; # [inline] fn neg (self) -> BigUint { panic ! () } } impl CheckedAdd for BigUint { # [inline] fn checked_add (& self , v : & BigUint) -> Option < BigUint > { Some (self . add (v)) } } impl CheckedSub for BigUint { # [inline] fn checked_sub (& self , v : & BigUint) -> Option < BigUint > { match self . cmp (v) { Less => None , Equal => Some (Zero :: zero ()) , Greater => Some (self . sub (v)) , } } } impl CheckedMul for BigUint { # [inline] fn checked_mul (& self , v : & BigUint) -> Option < BigUint > { Some (self . mul (v)) } } impl CheckedDiv for BigUint { # [inline] fn checked_div (& self , v : & BigUint) -> Option < BigUint > { if v . is_zero () { return None ; } Some (self . div (v)) } } impl Integer for BigUint { # [inline] fn div_rem (& self , other : & BigUint) -> (BigUint , BigUint) { div_rem_ref (self , other) } # [inline] fn div_floor (& self , other : & BigUint) -> BigUint { let (d , _) = div_rem_ref (self , other) ; d } # [inline] fn mod_floor (& self , other : & BigUint) -> BigUint { let (_ , m) = div_rem_ref (self , other) ; m } # [inline] fn div_mod_floor (& self , other : & BigUint) -> (BigUint , BigUint) { div_rem_ref (self , other) } # [doc = " Calculates the Greatest Common Divisor (GCD) of the number and `other`."] # [doc = ""] # [doc = " The result is always positive."] # [inline] fn gcd (& self , other : & Self) -> Self { # [inline] fn twos (x : & BigUint) -> usize { trailing_zeros (x) . unwrap_or (0) } if self . is_zero () { return other . clone () ; } if other . is_zero () { return self . clone () ; } let mut m = self . clone () ; let mut n = other . clone () ; let shift = cmp :: min (twos (& n) , twos (& m)) ; n >>= twos (& n) ; while ! m . is_zero () { m >>= twos (& m) ; if n > m { mem :: swap (& mut n , & mut m) } m -= & n ; } n << shift } # [doc = " Calculates the Lowest Common Multiple (LCM) of the number and `other`."] # [inline] fn lcm (& self , other : & BigUint) -> BigUint { if self . is_zero () && other . is_zero () { Self :: zero () } else { self / self . gcd (other) * other } } # [doc = " Deprecated, use `is_multiple_of` instead."] # [inline] fn divides (& self , other : & BigUint) -> bool { self . is_multiple_of (other) } # [doc = " Returns `true` if the number is a multiple of `other`."] # [inline] fn is_multiple_of (& self , other : & BigUint) -> bool { (self % other) . is_zero () } # [doc = " Returns `true` if the number is divisible by `2`."] # [inline] fn is_even (& self) -> bool { match self . data . first () { Some (x) => x . is_even () , None => true , } } # [doc = " Returns `true` if the number is not divisible by `2`."] # [inline] fn is_odd (& self) -> bool { ! self . is_even () } } # [inline] fn fixpoint < F > (mut x : BigUint , max_bits : usize , f : F) -> BigUint where F : Fn (& BigUint) -> BigUint , { let mut xn = f (& x) ; while x < xn { x = if xn . bits () > max_bits { BigUint :: one () << max_bits } else { xn } ; xn = f (& x) ; } while x > xn { x = xn ; xn = f (& x) ; } x } impl Roots for BigUint { fn nth_root (& self , n : u32) -> Self { assert ! (n > 0 , "root degree n must be at least 1") ; if self . is_zero () || self . is_one () { return self . clone () ; } match n { 1 => return self . clone () , 2 => return self . sqrt () , 3 => return self . cbrt () , _ => () , } let bits = self . bits () ; if bits <= n as usize { return BigUint :: one () ; } if let Some (x) = self . to_u64 () { return x . nth_root (n) . into () ; } let max_bits = bits / n as usize + 1 ; let guess = if let Some (f) = self . to_f64 () { BigUint :: from_f64 ((f . ln () / f64 :: from (n)) . exp ()) . unwrap () } else { let nsz = n as usize ; let extra_bits = bits - (f64 :: MAX_EXP as usize - 1) ; let root_scale = (extra_bits + (nsz - 1)) / nsz ; let scale = root_scale * nsz ; if scale < bits && bits - scale > nsz { (self >> scale) . nth_root (n) << root_scale } else { BigUint :: one () << max_bits } } ; let n_min_1 = n - 1 ; fixpoint (guess , max_bits , move | s | { let q = self / s . pow (n_min_1) ; let t = n_min_1 * s + q ; t / n }) } fn sqrt (& self) -> Self { if self . is_zero () || self . is_one () { return self . clone () ; } if let Some (x) = self . to_u64 () { return x . sqrt () . into () ; } let bits = self . bits () ; let max_bits = bits / 2 as usize + 1 ; let guess = if let Some (f) = self . to_f64 () { BigUint :: from_f64 (f . sqrt ()) . unwrap () } else { let extra_bits = bits - (f64 :: MAX_EXP as usize - 1) ; let root_scale = (extra_bits + 1) / 2 ; let scale = root_scale * 2 ; (self >> scale) . sqrt () << root_scale } ; fixpoint (guess , max_bits , move | s | { let q = self / s ; let t = s + q ; t >> 1 }) } fn cbrt (& self) -> Self { if self . is_zero () || self . is_one () { return self . clone () ; } if let Some (x) = self . to_u64 () { return x . cbrt () . into () ; } let bits = self . bits () ; let max_bits = bits / 3 as usize + 1 ; let guess = if let Some (f) = self . to_f64 () { BigUint :: from_f64 (f . cbrt ()) . unwrap () } else { let extra_bits = bits - (f64 :: MAX_EXP as usize - 1) ; let root_scale = (extra_bits + 2) / 3 ; let scale = root_scale * 3 ; (self >> scale) . cbrt () << root_scale } ; fixpoint (guess , max_bits , move | s | { let q = self / (s * s) ; let t = (s << 1) + q ; t / 3u32 }) } } fn high_bits_to_u64 (v : & BigUint) -> u64 { match v . data . len () { 0 => 0 , 1 => u64 :: from (v . data [0]) , _ => { let mut bits = v . bits () ; let mut ret = 0u64 ; let mut ret_bits = 0 ; for d in v . data . iter () . rev () { let digit_bits = (bits - 1) % big_digit :: BITS + 1 ; let bits_want = cmp :: min (64 - ret_bits , digit_bits) ; if bits_want != 64 { ret <<= bits_want ; } ret |= u64 :: from (* d) >> (digit_bits - bits_want) ; ret_bits += bits_want ; bits -= bits_want ; if ret_bits == 64 { break ; } } ret } } } impl ToPrimitive for BigUint { # [inline] fn to_i64 (& self) -> Option < i64 > { self . to_u64 () . as_ref () . and_then (u64 :: to_i64) } # [inline] # [cfg (has_i128)] fn to_i128 (& self) -> Option < i128 > { self . to_u128 () . as_ref () . and_then (u128 :: to_i128) } # [inline] fn to_u64 (& self) -> Option < u64 > { let mut ret : u64 = 0 ; let mut bits = 0 ; for i in self . data . iter () { if bits >= 64 { return None ; } ret += u64 :: from (* i) << bits ; bits += big_digit :: BITS ; } Some (ret) } # [inline] # [cfg (has_i128)] fn to_u128 (& self) -> Option < u128 > { let mut ret : u128 = 0 ; let mut bits = 0 ; for i in self . data . iter () { if bits >= 128 { return None ; } ret |= u128 :: from (* i) << bits ; bits += big_digit :: BITS ; } Some (ret) } # [inline] fn to_f32 (& self) -> Option < f32 > { let mantissa = high_bits_to_u64 (self) ; let exponent = self . bits () - fls (mantissa) ; if exponent > f32 :: MAX_EXP as usize { None } else { let ret = (mantissa as f32) * 2.0f32 . powi (exponent as i32) ; if ret . is_infinite () { None } else { Some (ret) } } } # [inline] fn to_f64 (& self) -> Option < f64 > { let mantissa = high_bits_to_u64 (self) ; let exponent = self . bits () - fls (mantissa) ; if exponent > f64 :: MAX_EXP as usize { None } else { let ret = (mantissa as f64) * 2.0f64 . powi (exponent as i32) ; if ret . is_infinite () { None } else { Some (ret) } } } } impl FromPrimitive for BigUint { # [inline] fn from_i64 (n : i64) -> Option < BigUint > { if n >= 0 { Some (BigUint :: from (n as u64)) } else { None } } # [inline] # [cfg (has_i128)] fn from_i128 (n : i128) -> Option < BigUint > { if n >= 0 { Some (BigUint :: from (n as u128)) } else { None } } # [inline] fn from_u64 (n : u64) -> Option < BigUint > { Some (BigUint :: from (n)) } # [inline] # [cfg (has_i128)] fn from_u128 (n : u128) -> Option < BigUint > { Some (BigUint :: from (n)) } # [inline] fn from_f64 (mut n : f64) -> Option < BigUint > { if ! n . is_finite () { return None ; } n = n . trunc () ; if n . is_zero () { return Some (BigUint :: zero ()) ; } let (mantissa , exponent , sign) = Float :: integer_decode (n) ; if sign == - 1 { return None ; } let mut ret = BigUint :: from (mantissa) ; if exponent > 0 { ret <<= exponent as usize ; } else if exponent < 0 { ret >>= (- exponent) as usize ; } Some (ret) } } impl From < u64 > for BigUint { # [inline] fn from (mut n : u64) -> Self { let mut ret : BigUint = Zero :: zero () ; while n != 0 { ret . data . push (n as BigDigit) ; n = (n >> 1) >> (big_digit :: BITS - 1) ; } ret } } # [cfg (has_i128)] impl From < u128 > for BigUint { # [inline] fn from (mut n : u128) -> Self { let mut ret : BigUint = Zero :: zero () ; while n != 0 { ret . data . push (n as BigDigit) ; n >>= big_digit :: BITS ; } ret } } macro_rules ! impl_biguint_from_uint { ($ T : ty) => { impl From <$ T > for BigUint { # [inline] fn from (n : $ T) -> Self { BigUint :: from (n as u64) } } } ; } impl_biguint_from_uint ! (u8) ; impl_biguint_from_uint ! (u16) ; impl_biguint_from_uint ! (u32) ; impl_biguint_from_uint ! (usize) ; # [doc = " A generic trait for converting a value to a `BigUint`."] pub trait ToBigUint { # [doc = " Converts the value of `self` to a `BigUint`."] fn to_biguint (& self) -> Option < BigUint > ; } impl ToBigUint for BigUint { # [inline] fn to_biguint (& self) -> Option < BigUint > { Some (self . clone ()) } } macro_rules ! impl_to_biguint { ($ T : ty , $ from_ty : path) => { impl ToBigUint for $ T { # [inline] fn to_biguint (& self) -> Option < BigUint > { $ from_ty (* self) } } } ; } impl_to_biguint ! (isize , FromPrimitive :: from_isize) ; impl_to_biguint ! (i8 , FromPrimitive :: from_i8) ; impl_to_biguint ! (i16 , FromPrimitive :: from_i16) ; impl_to_biguint ! (i32 , FromPrimitive :: from_i32) ; impl_to_biguint ! (i64 , FromPrimitive :: from_i64) ; # [cfg (has_i128)] impl_to_biguint ! (i128 , FromPrimitive :: from_i128) ; impl_to_biguint ! (usize , FromPrimitive :: from_usize) ; impl_to_biguint ! (u8 , FromPrimitive :: from_u8) ; impl_to_biguint ! (u16 , FromPrimitive :: from_u16) ; impl_to_biguint ! (u32 , FromPrimitive :: from_u32) ; impl_to_biguint ! (u64 , FromPrimitive :: from_u64) ; # [cfg (has_i128)] impl_to_biguint ! (u128 , FromPrimitive :: from_u128) ; impl_to_biguint ! (f32 , FromPrimitive :: from_f32) ; impl_to_biguint ! (f64 , FromPrimitive :: from_f64) ; fn to_bitwise_digits_le (u : & BigUint , bits : usize) -> Vec < u8 > { debug_assert ! (! u . is_zero () && bits <= 8 && big_digit :: BITS % bits == 0) ; let last_i = u . data . len () - 1 ; let mask : BigDigit = (1 << bits) - 1 ; let digits_per_big_digit = big_digit :: BITS / bits ; let digits = (u . bits () + bits - 1) / bits ; let mut res = Vec :: with_capacity (digits) ; for mut r in u . data [.. last_i] . iter () . cloned () { for _ in 0 .. digits_per_big_digit { res . push ((r & mask) as u8) ; r >>= bits ; } } let mut r = u . data [last_i] ; while r != 0 { res . push ((r & mask) as u8) ; r >>= bits ; } res } fn to_inexact_bitwise_digits_le (u : & BigUint , bits : usize) -> Vec < u8 > { debug_assert ! (! u . is_zero () && bits <= 8 && big_digit :: BITS % bits != 0) ; let mask : BigDigit = (1 << bits) - 1 ; let digits = (u . bits () + bits - 1) / bits ; let mut res = Vec :: with_capacity (digits) ; let mut r = 0 ; let mut rbits = 0 ; for c in & u . data { r |= * c << rbits ; rbits += big_digit :: BITS ; while rbits >= bits { res . push ((r & mask) as u8) ; r >>= bits ; if rbits > big_digit :: BITS { r = * c >> (big_digit :: BITS - (rbits - bits)) ; } rbits -= bits ; } } if rbits != 0 { res . push (r as u8) ; } while let Some (& 0) = res . last () { res . pop () ; } res } # [inline (always)] fn to_radix_digits_le (u : & BigUint , radix : u32) -> Vec < u8 > { debug_assert ! (! u . is_zero () && ! radix . is_power_of_two ()) ; let radix_digits = ((u . bits () as f64) / f64 :: from (radix) . log2 ()) . ceil () ; let mut res = Vec :: with_capacity (radix_digits as usize) ; let mut digits = u . clone () ; let (base , power) = get_radix_base (radix) ; let radix = radix as BigDigit ; while digits . data . len () > 1 { let (q , mut r) = div_rem_digit (digits , base) ; for _ in 0 .. power { res . push ((r % radix) as u8) ; r /= radix ; } digits = q ; } let mut r = digits . data [0] ; while r != 0 { res . push ((r % radix) as u8) ; r /= radix ; } res } pub fn to_radix_le (u : & BigUint , radix : u32) -> Vec < u8 > { if u . is_zero () { vec ! [0] } else if radix . is_power_of_two () { let bits = ilog2 (radix) ; if big_digit :: BITS % bits == 0 { to_bitwise_digits_le (u , bits) } else { to_inexact_bitwise_digits_le (u , bits) } } else if radix == 10 { to_radix_digits_le (u , 10) } else { to_radix_digits_le (u , radix) } } pub fn to_str_radix_reversed (u : & BigUint , radix : u32) -> Vec < u8 > { assert ! (2 <= radix && radix <= 36 , "The radix must be within 2...36") ; if u . is_zero () { return vec ! [b'0'] ; } let mut res = to_radix_le (u , radix) ; for r in & mut res { debug_assert ! (u32 :: from (* r) < radix) ; if * r < 10 { * r += b'0' ; } else { * r += b'a' - 10 ; } } res } impl BigUint { # [doc = " Creates and initializes a `BigUint`."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn new (digits : Vec < u32 >) -> BigUint { BigUint { data : digits } . normalized () } # [doc = " Creates and initializes a `BigUint`."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn from_slice (slice : & [u32]) -> BigUint { BigUint :: new (slice . to_vec ()) } # [doc = " Assign a value to a `BigUint`."] # [doc = ""] # [doc = " The base 2<sup>32</sup> digits are ordered least significant digit first."] # [inline] pub fn assign_from_slice (& mut self , slice : & [u32]) { self . data . resize (slice . len () , 0) ; self . data . clone_from_slice (slice) ; self . normalize () ; } # [doc = " Creates and initializes a `BigUint`."] # [doc = ""] # [doc = " The bytes are in big-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " assert_eq!(BigUint::from_bytes_be(b\"A\"),"] # [doc = "            BigUint::parse_bytes(b\"65\", 10).unwrap());"] # [doc = " assert_eq!(BigUint::from_bytes_be(b\"AA\"),"] # [doc = "            BigUint::parse_bytes(b\"16705\", 10).unwrap());"] # [doc = " assert_eq!(BigUint::from_bytes_be(b\"AB\"),"] # [doc = "            BigUint::parse_bytes(b\"16706\", 10).unwrap());"] # [doc = " assert_eq!(BigUint::from_bytes_be(b\"Hello world!\"),"] # [doc = "            BigUint::parse_bytes(b\"22405534230753963835153736737\", 10).unwrap());"] # [doc = " ```"] # [inline] pub fn from_bytes_be (bytes : & [u8]) -> BigUint { if bytes . is_empty () { Zero :: zero () } else { let mut v = bytes . to_vec () ; v . reverse () ; BigUint :: from_bytes_le (& * v) } } # [doc = " Creates and initializes a `BigUint`."] # [doc = ""] # [doc = " The bytes are in little-endian byte order."] # [inline] pub fn from_bytes_le (bytes : & [u8]) -> BigUint { if bytes . is_empty () { Zero :: zero () } else { from_bitwise_digits_le (bytes , 8) } } # [doc = " Creates and initializes a `BigUint`. The input slice must contain"] # [doc = " ascii/utf8 characters in [0-9a-zA-Z]."] # [doc = " `radix` must be in the range `2...36`."] # [doc = ""] # [doc = " The function `from_str_radix` from the `Num` trait provides the same logic"] # [doc = " for `&str` buffers."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigUint, ToBigUint};"] # [doc = ""] # [doc = " assert_eq!(BigUint::parse_bytes(b\"1234\", 10), ToBigUint::to_biguint(&1234));"] # [doc = " assert_eq!(BigUint::parse_bytes(b\"ABCD\", 16), ToBigUint::to_biguint(&0xABCD));"] # [doc = " assert_eq!(BigUint::parse_bytes(b\"G\", 16), None);"] # [doc = " ```"] # [inline] pub fn parse_bytes (buf : & [u8] , radix : u32) -> Option < BigUint > { str :: from_utf8 (buf) . ok () . and_then (| s | BigUint :: from_str_radix (s , radix) . ok ()) } # [doc = " Creates and initializes a `BigUint`. Each u8 of the input slice is"] # [doc = " interpreted as one digit of the number"] # [doc = " and must therefore be less than `radix`."] # [doc = ""] # [doc = " The bytes are in big-endian byte order."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigUint};"] # [doc = ""] # [doc = " let inbase190 = &[15, 33, 125, 12, 14];"] # [doc = " let a = BigUint::from_radix_be(inbase190, 190).unwrap();"] # [doc = " assert_eq!(a.to_radix_be(190), inbase190);"] # [doc = " ```"] pub fn from_radix_be (buf : & [u8] , radix : u32) -> Option < BigUint > { assert ! (2 <= radix && radix <= 256 , "The radix must be within 2...256") ; if radix != 256 && buf . iter () . any (| & b | b >= radix as u8) { return None ; } let res = if radix . is_power_of_two () { let bits = ilog2 (radix) ; let mut v = Vec :: from (buf) ; v . reverse () ; if big_digit :: BITS % bits == 0 { from_bitwise_digits_le (& v , bits) } else { from_inexact_bitwise_digits_le (& v , bits) } } else { from_radix_digits_be (buf , radix) } ; Some (res) } # [doc = " Creates and initializes a `BigUint`. Each u8 of the input slice is"] # [doc = " interpreted as one digit of the number"] # [doc = " and must therefore be less than `radix`."] # [doc = ""] # [doc = " The bytes are in little-endian byte order."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::{BigUint};"] # [doc = ""] # [doc = " let inbase190 = &[14, 12, 125, 33, 15];"] # [doc = " let a = BigUint::from_radix_be(inbase190, 190).unwrap();"] # [doc = " assert_eq!(a.to_radix_be(190), inbase190);"] # [doc = " ```"] pub fn from_radix_le (buf : & [u8] , radix : u32) -> Option < BigUint > { assert ! (2 <= radix && radix <= 256 , "The radix must be within 2...256") ; if radix != 256 && buf . iter () . any (| & b | b >= radix as u8) { return None ; } let res = if radix . is_power_of_two () { let bits = ilog2 (radix) ; if big_digit :: BITS % bits == 0 { from_bitwise_digits_le (buf , bits) } else { from_inexact_bitwise_digits_le (buf , bits) } } else { let mut v = Vec :: from (buf) ; v . reverse () ; from_radix_digits_be (& v , radix) } ; Some (res) } # [doc = " Returns the byte representation of the `BigUint` in big-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " let i = BigUint::parse_bytes(b\"1125\", 10).unwrap();"] # [doc = " assert_eq!(i.to_bytes_be(), vec![4, 101]);"] # [doc = " ```"] # [inline] pub fn to_bytes_be (& self) -> Vec < u8 > { let mut v = self . to_bytes_le () ; v . reverse () ; v } # [doc = " Returns the byte representation of the `BigUint` in little-endian byte order."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " let i = BigUint::parse_bytes(b\"1125\", 10).unwrap();"] # [doc = " assert_eq!(i.to_bytes_le(), vec![101, 4]);"] # [doc = " ```"] # [inline] pub fn to_bytes_le (& self) -> Vec < u8 > { if self . is_zero () { vec ! [0] } else { to_bitwise_digits_le (self , 8) } } # [doc = " Returns the `u32` digits representation of the `BigUint` ordered least significant digit"] # [doc = " first."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " assert_eq!(BigUint::from(1125u32).to_u32_digits(), vec![1125]);"] # [doc = " assert_eq!(BigUint::from(4294967295u32).to_u32_digits(), vec![4294967295]);"] # [doc = " assert_eq!(BigUint::from(4294967296u64).to_u32_digits(), vec![0, 1]);"] # [doc = " assert_eq!(BigUint::from(112500000000u64).to_u32_digits(), vec![830850304, 26]);"] # [doc = " ```"] # [inline] pub fn to_u32_digits (& self) -> Vec < u32 > { self . data . clone () } # [doc = " Returns the integer formatted as a string in the given radix."] # [doc = " `radix` must be in the range `2...36`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " let i = BigUint::parse_bytes(b\"ff\", 16).unwrap();"] # [doc = " assert_eq!(i.to_str_radix(16), \"ff\");"] # [doc = " ```"] # [inline] pub fn to_str_radix (& self , radix : u32) -> String { let mut v = to_str_radix_reversed (self , radix) ; v . reverse () ; unsafe { String :: from_utf8_unchecked (v) } } # [doc = " Returns the integer in the requested base in big-endian digit order."] # [doc = " The output is not given in a human readable alphabet but as a zero"] # [doc = " based u8 number."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " assert_eq!(BigUint::from(0xFFFFu64).to_radix_be(159),"] # [doc = "            vec![2, 94, 27]);"] # [doc = " // 0xFFFF = 65535 = 2*(159^2) + 94*159 + 27"] # [doc = " ```"] # [inline] pub fn to_radix_be (& self , radix : u32) -> Vec < u8 > { let mut v = to_radix_le (self , radix) ; v . reverse () ; v } # [doc = " Returns the integer in the requested base in little-endian digit order."] # [doc = " The output is not given in a human readable alphabet but as a zero"] # [doc = " based u8 number."] # [doc = " `radix` must be in the range `2...256`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_bigint::BigUint;"] # [doc = ""] # [doc = " assert_eq!(BigUint::from(0xFFFFu64).to_radix_le(159),"] # [doc = "            vec![27, 94, 2]);"] # [doc = " // 0xFFFF = 65535 = 27 + 94*159 + 2*(159^2)"] # [doc = " ```"] # [inline] pub fn to_radix_le (& self , radix : u32) -> Vec < u8 > { to_radix_le (self , radix) } # [doc = " Determines the fewest bits necessary to express the `BigUint`."] # [inline] pub fn bits (& self) -> usize { if self . is_zero () { return 0 ; } let zeros = self . data . last () . unwrap () . leading_zeros () ; self . data . len () * big_digit :: BITS - zeros as usize } # [doc = " Strips off trailing zero bigdigits - comparisons require the last element in the vector to"] # [doc = " be nonzero."] # [inline] fn normalize (& mut self) { while let Some (& 0) = self . data . last () { self . data . pop () ; } } # [doc = " Returns a normalized `BigUint`."] # [inline] fn normalized (mut self) -> BigUint { self . normalize () ; self } # [doc = " Returns `(self ^ exponent) % modulus`."] # [doc = ""] # [doc = " Panics if the modulus is zero."] pub fn modpow (& self , exponent : & Self , modulus : & Self) -> Self { assert ! (! modulus . is_zero () , "divide by zero!") ; if modulus . is_odd () { monty_modpow (self , exponent , modulus) } else { plain_modpow (self , & exponent . data , modulus) } } # [doc = " Returns the truncated principal square root of `self` --"] # [doc = " see [Roots::sqrt](https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#method.sqrt)"] pub fn sqrt (& self) -> Self { Roots :: sqrt (self) } # [doc = " Returns the truncated principal cube root of `self` --"] # [doc = " see [Roots::cbrt](https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#method.cbrt)."] pub fn cbrt (& self) -> Self { Roots :: cbrt (self) } # [doc = " Returns the truncated principal `n`th root of `self` --"] # [doc = " see [Roots::nth_root](https://docs.rs/num-integer/0.1/num_integer/trait.Roots.html#tymethod.nth_root)."] pub fn nth_root (& self , n : u32) -> Self { Roots :: nth_root (self , n) } } fn plain_modpow (base : & BigUint , exp_data : & [BigDigit] , modulus : & BigUint) -> BigUint { assert ! (! modulus . is_zero () , "divide by zero!") ; let i = match exp_data . iter () . position (| & r | r != 0) { None => return BigUint :: one () , Some (i) => i , } ; let mut base = base % modulus ; for _ in 0 .. i { for _ in 0 .. big_digit :: BITS { base = & base * & base % modulus ; } } let mut r = exp_data [i] ; let mut b = 0usize ; while r . is_even () { base = & base * & base % modulus ; r >>= 1 ; b += 1 ; } let mut exp_iter = exp_data [i + 1 ..] . iter () ; if exp_iter . len () == 0 && r . is_one () { return base ; } let mut acc = base . clone () ; r >>= 1 ; b += 1 ; { let mut unit = | exp_is_odd | { base = & base * & base % modulus ; if exp_is_odd { acc = & acc * & base % modulus ; } } ; if let Some (& last) = exp_iter . next_back () { for _ in b .. big_digit :: BITS { unit (r . is_odd ()) ; r >>= 1 ; } for & r in exp_iter { let mut r = r ; for _ in 0 .. big_digit :: BITS { unit (r . is_odd ()) ; r >>= 1 ; } } r = last ; } debug_assert_ne ! (r , 0) ; while ! r . is_zero () { unit (r . is_odd ()) ; r >>= 1 ; } } acc } # [test] fn test_plain_modpow () { let two = BigUint :: from (2u32) ; let modulus = BigUint :: from (0x1100u32) ; let exp = vec ! [0 , 0b1] ; assert_eq ! (two . pow (0b1_00000000_u32) % & modulus , plain_modpow (& two , & exp , & modulus)) ; let exp = vec ! [0 , 0b10] ; assert_eq ! (two . pow (0b10_00000000_u32) % & modulus , plain_modpow (& two , & exp , & modulus)) ; let exp = vec ! [0 , 0b110010] ; assert_eq ! (two . pow (0b110010_00000000_u32) % & modulus , plain_modpow (& two , & exp , & modulus)) ; let exp = vec ! [0b1 , 0b1] ; assert_eq ! (two . pow (0b1_00000001_u32) % & modulus , plain_modpow (& two , & exp , & modulus)) ; let exp = vec ! [0b1100 , 0 , 0b1] ; assert_eq ! (two . pow (0b1_00000000_00001100_u32) % & modulus , plain_modpow (& two , & exp , & modulus)) ; } # [doc = " Returns the number of least-significant bits that are zero,"] # [doc = " or `None` if the entire number is zero."] pub fn trailing_zeros (u : & BigUint) -> Option < usize > { u . data . iter () . enumerate () . find (| & (_ , & digit) | digit != 0) . map (| (i , digit) | i * big_digit :: BITS + digit . trailing_zeros () as usize) } impl_sum_iter_type ! (BigUint) ; impl_product_iter_type ! (BigUint) ; pub trait IntDigits { fn digits (& self) -> & [BigDigit] ; fn digits_mut (& mut self) -> & mut Vec < BigDigit > ; fn normalize (& mut self) ; fn capacity (& self) -> usize ; fn len (& self) -> usize ; } impl IntDigits for BigUint { # [inline] fn digits (& self) -> & [BigDigit] { & self . data } # [inline] fn digits_mut (& mut self) -> & mut Vec < BigDigit > { & mut self . data } # [inline] fn normalize (& mut self) { self . normalize () ; } # [inline] fn capacity (& self) -> usize { self . data . capacity () } # [inline] fn len (& self) -> usize { self . data . len () } } # [doc = " Combine four `u32`s into a single `u128`."] # [cfg (has_i128)] # [inline] fn u32_to_u128 (a : u32 , b : u32 , c : u32 , d : u32) -> u128 { u128 :: from (d) | (u128 :: from (c) << 32) | (u128 :: from (b) << 64) | (u128 :: from (a) << 96) } # [doc = " Split a single `u128` into four `u32`."] # [cfg (has_i128)] # [inline] fn u32_from_u128 (n : u128) -> (u32 , u32 , u32 , u32) { ((n >> 96) as u32 , (n >> 64) as u32 , (n >> 32) as u32 , n as u32 ,) } # [cfg (feature = "serde")] impl serde :: Serialize for BigUint { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : serde :: Serializer , { let data : & Vec < u32 > = & self . data ; data . serialize (serializer) } } # [cfg (feature = "serde")] impl < 'de > serde :: Deserialize < 'de > for BigUint { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : serde :: Deserializer < 'de > , { let data : Vec < u32 > = Vec :: deserialize (deserializer) ? ; Ok (BigUint :: new (data)) } } # [doc = " Returns the greatest power of the radix <= big_digit::BASE"] # [inline] fn get_radix_base (radix : u32) -> (BigDigit , usize) { debug_assert ! (2 <= radix && radix <= 256 , "The radix must be within 2...256") ; debug_assert ! (! radix . is_power_of_two ()) ; match big_digit :: BITS { 32 => { const BASES : [(u32 , usize) ; 257] = [(0 , 0) , (0 , 0) , (0 , 0) , (3486784401 , 20) , (0 , 0) , (1220703125 , 13) , (2176782336 , 12) , (1977326743 , 11) , (0 , 0) , (3486784401 , 10) , (1000000000 , 9) , (2357947691 , 9) , (429981696 , 8) , (815730721 , 8) , (1475789056 , 8) , (2562890625 , 8) , (0 , 0) , (410338673 , 7) , (612220032 , 7) , (893871739 , 7) , (1280000000 , 7) , (1801088541 , 7) , (2494357888 , 7) , (3404825447 , 7) , (191102976 , 6) , (244140625 , 6) , (308915776 , 6) , (387420489 , 6) , (481890304 , 6) , (594823321 , 6) , (729000000 , 6) , (887503681 , 6) , (0 , 0) , (1291467969 , 6) , (1544804416 , 6) , (1838265625 , 6) , (2176782336 , 6) , (2565726409 , 6) , (3010936384 , 6) , (3518743761 , 6) , (4096000000 , 6) , (115856201 , 5) , (130691232 , 5) , (147008443 , 5) , (164916224 , 5) , (184528125 , 5) , (205962976 , 5) , (229345007 , 5) , (254803968 , 5) , (282475249 , 5) , (312500000 , 5) , (345025251 , 5) , (380204032 , 5) , (418195493 , 5) , (459165024 , 5) , (503284375 , 5) , (550731776 , 5) , (601692057 , 5) , (656356768 , 5) , (714924299 , 5) , (777600000 , 5) , (844596301 , 5) , (916132832 , 5) , (992436543 , 5) , (0 , 0) , (1160290625 , 5) , (1252332576 , 5) , (1350125107 , 5) , (1453933568 , 5) , (1564031349 , 5) , (1680700000 , 5) , (1804229351 , 5) , (1934917632 , 5) , (2073071593 , 5) , (2219006624 , 5) , (2373046875 , 5) , (2535525376 , 5) , (2706784157 , 5) , (2887174368 , 5) , (3077056399 , 5) , (3276800000 , 5) , (3486784401 , 5) , (3707398432 , 5) , (3939040643 , 5) , (4182119424 , 5) , (52200625 , 4) , (54700816 , 4) , (57289761 , 4) , (59969536 , 4) , (62742241 , 4) , (65610000 , 4) , (68574961 , 4) , (71639296 , 4) , (74805201 , 4) , (78074896 , 4) , (81450625 , 4) , (84934656 , 4) , (88529281 , 4) , (92236816 , 4) , (96059601 , 4) , (100000000 , 4) , (104060401 , 4) , (108243216 , 4) , (112550881 , 4) , (116985856 , 4) , (121550625 , 4) , (126247696 , 4) , (131079601 , 4) , (136048896 , 4) , (141158161 , 4) , (146410000 , 4) , (151807041 , 4) , (157351936 , 4) , (163047361 , 4) , (168896016 , 4) , (174900625 , 4) , (181063936 , 4) , (187388721 , 4) , (193877776 , 4) , (200533921 , 4) , (207360000 , 4) , (214358881 , 4) , (221533456 , 4) , (228886641 , 4) , (236421376 , 4) , (244140625 , 4) , (252047376 , 4) , (260144641 , 4) , (0 , 0) , (276922881 , 4) , (285610000 , 4) , (294499921 , 4) , (303595776 , 4) , (312900721 , 4) , (322417936 , 4) , (332150625 , 4) , (342102016 , 4) , (352275361 , 4) , (362673936 , 4) , (373301041 , 4) , (384160000 , 4) , (395254161 , 4) , (406586896 , 4) , (418161601 , 4) , (429981696 , 4) , (442050625 , 4) , (454371856 , 4) , (466948881 , 4) , (479785216 , 4) , (492884401 , 4) , (506250000 , 4) , (519885601 , 4) , (533794816 , 4) , (547981281 , 4) , (562448656 , 4) , (577200625 , 4) , (592240896 , 4) , (607573201 , 4) , (623201296 , 4) , (639128961 , 4) , (655360000 , 4) , (671898241 , 4) , (688747536 , 4) , (705911761 , 4) , (723394816 , 4) , (741200625 , 4) , (759333136 , 4) , (777796321 , 4) , (796594176 , 4) , (815730721 , 4) , (835210000 , 4) , (855036081 , 4) , (875213056 , 4) , (895745041 , 4) , (916636176 , 4) , (937890625 , 4) , (959512576 , 4) , (981506241 , 4) , (1003875856 , 4) , (1026625681 , 4) , (1049760000 , 4) , (1073283121 , 4) , (1097199376 , 4) , (1121513121 , 4) , (1146228736 , 4) , (1171350625 , 4) , (1196883216 , 4) , (1222830961 , 4) , (1249198336 , 4) , (1275989841 , 4) , (1303210000 , 4) , (1330863361 , 4) , (1358954496 , 4) , (1387488001 , 4) , (1416468496 , 4) , (1445900625 , 4) , (1475789056 , 4) , (1506138481 , 4) , (1536953616 , 4) , (1568239201 , 4) , (1600000000 , 4) , (1632240801 , 4) , (1664966416 , 4) , (1698181681 , 4) , (1731891456 , 4) , (1766100625 , 4) , (1800814096 , 4) , (1836036801 , 4) , (1871773696 , 4) , (1908029761 , 4) , (1944810000 , 4) , (1982119441 , 4) , (2019963136 , 4) , (2058346161 , 4) , (2097273616 , 4) , (2136750625 , 4) , (2176782336 , 4) , (2217373921 , 4) , (2258530576 , 4) , (2300257521 , 4) , (2342560000 , 4) , (2385443281 , 4) , (2428912656 , 4) , (2472973441 , 4) , (2517630976 , 4) , (2562890625 , 4) , (2608757776 , 4) , (2655237841 , 4) , (2702336256 , 4) , (2750058481 , 4) , (2798410000 , 4) , (2847396321 , 4) , (2897022976 , 4) , (2947295521 , 4) , (2998219536 , 4) , (3049800625 , 4) , (3102044416 , 4) , (3154956561 , 4) , (3208542736 , 4) , (3262808641 , 4) , (3317760000 , 4) , (3373402561 , 4) , (3429742096 , 4) , (3486784401 , 4) , (3544535296 , 4) , (3603000625 , 4) , (3662186256 , 4) , (3722098081 , 4) , (3782742016 , 4) , (3844124001 , 4) , (3906250000 , 4) , (3969126001 , 4) , (4032758016 , 4) , (4097152081 , 4) , (4162314256 , 4) , (4228250625 , 4) , (0 , 0) ,] ; let (base , power) = BASES [radix as usize] ; (base as BigDigit , power) } 64 => { const BASES : [(u64 , usize) ; 257] = [(0 , 0) , (0 , 0) , (9223372036854775808 , 63) , (12157665459056928801 , 40) , (4611686018427387904 , 31) , (7450580596923828125 , 27) , (4738381338321616896 , 24) , (3909821048582988049 , 22) , (9223372036854775808 , 21) , (12157665459056928801 , 20) , (10000000000000000000 , 19) , (5559917313492231481 , 18) , (2218611106740436992 , 17) , (8650415919381337933 , 17) , (2177953337809371136 , 16) , (6568408355712890625 , 16) , (1152921504606846976 , 15) , (2862423051509815793 , 15) , (6746640616477458432 , 15) , (15181127029874798299 , 15) , (1638400000000000000 , 14) , (3243919932521508681 , 14) , (6221821273427820544 , 14) , (11592836324538749809 , 14) , (876488338465357824 , 13) , (1490116119384765625 , 13) , (2481152873203736576 , 13) , (4052555153018976267 , 13) , (6502111422497947648 , 13) , (10260628712958602189 , 13) , (15943230000000000000 , 13) , (787662783788549761 , 12) , (1152921504606846976 , 12) , (1667889514952984961 , 12) , (2386420683693101056 , 12) , (3379220508056640625 , 12) , (4738381338321616896 , 12) , (6582952005840035281 , 12) , (9065737908494995456 , 12) , (12381557655576425121 , 12) , (16777216000000000000 , 12) , (550329031716248441 , 11) , (717368321110468608 , 11) , (929293739471222707 , 11) , (1196683881290399744 , 11) , (1532278301220703125 , 11) , (1951354384207722496 , 11) , (2472159215084012303 , 11) , (3116402981210161152 , 11) , (3909821048582988049 , 11) , (4882812500000000000 , 11) , (6071163615208263051 , 11) , (7516865509350965248 , 11) , (9269035929372191597 , 11) , (11384956040305711104 , 11) , (13931233916552734375 , 11) , (16985107389382393856 , 11) , (362033331456891249 , 10) , (430804206899405824 , 10) , (511116753300641401 , 10) , (604661760000000000 , 10) , (713342911662882601 , 10) , (839299365868340224 , 10) , (984930291881790849 , 10) , (1152921504606846976 , 10) , (1346274334462890625 , 10) , (1568336880910795776 , 10) , (1822837804551761449 , 10) , (2113922820157210624 , 10) , (2446194060654759801 , 10) , (2824752490000000000 , 10) , (3255243551009881201 , 10) , (3743906242624487424 , 10) , (4297625829703557649 , 10) , (4923990397355877376 , 10) , (5631351470947265625 , 10) , (6428888932339941376 , 10) , (7326680472586200649 , 10) , (8335775831236199424 , 10) , (9468276082626847201 , 10) , (10737418240000000000 , 10) , (12157665459056928801 , 10) , (13744803133596058624 , 10) , (15516041187205853449 , 10) , (17490122876598091776 , 10) , (231616946283203125 , 9) , (257327417311663616 , 9) , (285544154243029527 , 9) , (316478381828866048 , 9) , (350356403707485209 , 9) , (387420489000000000 , 9) , (427929800129788411 , 9) , (472161363286556672 , 9) , (520411082988487293 , 9) , (572994802228616704 , 9) , (630249409724609375 , 9) , (692533995824480256 , 9) , (760231058654565217 , 9) , (833747762130149888 , 9) , (913517247483640899 , 9) , (1000000000000000000 , 9) , (1093685272684360901 , 9) , (1195092568622310912 , 9) , (1304773183829244583 , 9) , (1423311812421484544 , 9) , (1551328215978515625 , 9) , (1689478959002692096 , 9) , (1838459212420154507 , 9) , (1999004627104432128 , 9) , (2171893279442309389 , 9) , (2357947691000000000 , 9) , (2558036924386500591 , 9) , (2773078757450186752 , 9) , (3004041937984268273 , 9) , (3251948521156637184 , 9) , (3517876291919921875 , 9) , (3802961274698203136 , 9) , (4108400332687853397 , 9) , (4435453859151328768 , 9) , (4785448563124474679 , 9) , (5159780352000000000 , 9) , (5559917313492231481 , 9) , (5987402799531080192 , 9) , (6443858614676334363 , 9) , (6930988311686938624 , 9) , (7450580596923828125 , 9) , (8004512848309157376 , 9) , (8594754748609397887 , 9) , (9223372036854775808 , 9) , (9892530380752880769 , 9) , (10604499373000000000 , 9) , (11361656654439817571 , 9) , (12166492167065567232 , 9) , (13021612539908538853 , 9) , (13929745610903012864 , 9) , (14893745087865234375 , 9) , (15916595351771938816 , 9) , (17001416405572203977 , 9) , (18151468971815029248 , 9) , (139353667211683681 , 8) , (147578905600000000 , 8) , (156225851787813921 , 8) , (165312903998914816 , 8) , (174859124550883201 , 8) , (184884258895036416 , 8) , (195408755062890625 , 8) , (206453783524884736 , 8) , (218041257467152161 , 8) , (230193853492166656 , 8) , (242935032749128801 , 8) , (256289062500000000 , 8) , (270281038127131201 , 8) , (284936905588473856 , 8) , (300283484326400961 , 8) , (316348490636206336 , 8) , (333160561500390625 , 8) , (350749278894882816 , 8) , (369145194573386401 , 8) , (388379855336079616 , 8) , (408485828788939521 , 8) , (429496729600000000 , 8) , (451447246258894081 , 8) , (474373168346071296 , 8) , (498311414318121121 , 8) , (523300059815673856 , 8) , (549378366500390625 , 8) , (576586811427594496 , 8) , (604967116961135041 , 8) , (634562281237118976 , 8) , (665416609183179841 , 8) , (697575744100000000 , 8) , (731086699811838561 , 8) , (765997893392859136 , 8) , (802359178476091681 , 8) , (840221879151902976 , 8) , (879638824462890625 , 8) , (920664383502155776 , 8) , (963354501121950081 , 8) , (1007766734259732736 , 8) , (1053960288888713761 , 8) , (1101996057600000000 , 8) , (1151936657823500641 , 8) , (1203846470694789376 , 8) , (1257791680575160641 , 8) , (1313840315232157696 , 8) , (1372062286687890625 , 8) , (1432529432742502656 , 8) , (1495315559180183521 , 8) , (1560496482665168896 , 8) , (1628150074335205281 , 8) , (1698356304100000000 , 8) , (1771197285652216321 , 8) , (1846757322198614016 , 8) , (1925122952918976001 , 8) , (2006383000160502016 , 8) , (2090628617375390625 , 8) , (2177953337809371136 , 8) , (2268453123948987361 , 8) , (2362226417735475456 , 8) , (2459374191553118401 , 8) , (2560000000000000000 , 8) , (2664210032449121601 , 8) , (2772113166407885056 , 8) , (2883821021683985761 , 8) , (2999448015365799936 , 8) , (3119111417625390625 , 8) , (3242931408352297216 , 8) , (3371031134626313601 , 8) , (3503536769037500416 , 8) , (3640577568861717121 , 8) , (3782285936100000000 , 8) , (3928797478390152481 , 8) , (4080251070798954496 , 8) , (4236788918503437921 , 8) , (4398556620369715456 , 8) , (4565703233437890625 , 8) , (4738381338321616896 , 8) , (4916747105530914241 , 8) , (5100960362726891776 , 8) , (5291184662917065441 , 8) , (5487587353600000000 , 8) , (5690339646868044961 , 8) , (5899616690476974336 , 8) , (6115597639891380481 , 8) , (6338465731314712576 , 8) , (6568408355712890625 , 8) , (6805617133840466176 , 8) , (7050287992278341281 , 8) , (7302621240492097536 , 8) , (7562821648920027361 , 8) , (7831098528100000000 , 8) , (8107665808844335041 , 8) , (8392742123471896576 , 8) , (8686550888106661441 , 8) , (8989320386052055296 , 8) , (9301283852250390625 , 8) , (9622679558836781056 , 8) , (9953750901796946721 , 8) , (10294746488738365696 , 8) , (10645920227784266881 , 8) , (11007531417600000000 , 8) , (11379844838561358721 , 8) , (11763130845074473216 , 8) , (12157665459056928801 , 8) , (12563730464589807616 , 8) , (12981613503750390625 , 8) , (13411608173635297536 , 8) , (13854014124583882561 , 8) , (14309137159611744256 , 8) , (14777289335064248001 , 8) , (15258789062500000000 , 8) , (15753961211814252001 , 8) , (16263137215612256256 , 8) , (16786655174842630561 , 8) , (17324859965700833536 , 8) , (17878103347812890625 , 8) , (72057594037927936 , 7) ,] ; let (base , power) = BASES [radix as usize] ; (base as BigDigit , power) } _ => panic ! ("Invalid bigdigit size") , } } # [test] fn test_from_slice () { fn check (slice : & [BigDigit] , data : & [BigDigit]) { assert ! (BigUint :: from_slice (slice) . data == data) ; } check (& [1] , & [1]) ; check (& [0 , 0 , 0] , & []) ; check (& [1 , 2 , 0 , 0] , & [1 , 2]) ; check (& [0 , 0 , 1 , 2] , & [0 , 0 , 1 , 2]) ; check (& [0 , 0 , 1 , 2 , 0 , 0] , & [0 , 0 , 1 , 2]) ; check (& [- 1i32 as BigDigit] , & [- 1i32 as BigDigit]) ; } # [test] fn test_assign_from_slice () { fn check (slice : & [BigDigit] , data : & [BigDigit]) { let mut p = BigUint :: from_slice (& [2627_u32 , 0_u32 , 9182_u32 , 42_u32]) ; p . assign_from_slice (slice) ; assert ! (p . data == data) ; } check (& [1] , & [1]) ; check (& [0 , 0 , 0] , & []) ; check (& [1 , 2 , 0 , 0] , & [1 , 2]) ; check (& [0 , 0 , 1 , 2] , & [0 , 0 , 1 , 2]) ; check (& [0 , 0 , 1 , 2 , 0 , 0] , & [0 , 0 , 1 , 2]) ; check (& [- 1i32 as BigDigit] , & [- 1i32 as BigDigit]) ; } # [cfg (has_i128)] # [test] fn test_u32_u128 () { assert_eq ! (u32_from_u128 (0u128) , (0 , 0 , 0 , 0)) ; assert_eq ! (u32_from_u128 (u128 :: max_value ()) , (u32 :: max_value () , u32 :: max_value () , u32 :: max_value () , u32 :: max_value ())) ; assert_eq ! (u32_from_u128 (u32 :: max_value () as u128) , (0 , 0 , 0 , u32 :: max_value ())) ; assert_eq ! (u32_from_u128 (u64 :: max_value () as u128) , (0 , 0 , u32 :: max_value () , u32 :: max_value ())) ; assert_eq ! (u32_from_u128 ((u64 :: max_value () as u128) + u32 :: max_value () as u128) , (0 , 1 , 0 , u32 :: max_value () - 1)) ; assert_eq ! (u32_from_u128 (36_893_488_151_714_070_528) , (0 , 2 , 1 , 0)) ; } # [cfg (has_i128)] # [test] fn test_u128_u32_roundtrip () { let values = vec ! [0u128 , 1u128 , u64 :: max_value () as u128 * 3 , u32 :: max_value () as u128 , u64 :: max_value () as u128 , (u64 :: max_value () as u128) + u32 :: max_value () as u128 , u128 :: max_value () ,] ; for val in & values { let (a , b , c , d) = u32_from_u128 (* val) ; assert_eq ! (u32_to_u128 (a , b , c , d) , * val) ; } } # [test] fn test_pow_biguint () { let base = BigUint :: from (5u8) ; let exponent = BigUint :: from (3u8) ; assert_eq ! (BigUint :: from (125u8) , base . pow (exponent)) ; } } # [cfg (feature = "rand")] mod bigrand { use rand :: distributions :: uniform :: { SampleUniform , UniformSampler } ; use rand :: prelude :: * ; use rand :: AsByteSliceMut ; use BigInt ; use BigUint ; use Sign :: * ; use big_digit :: BigDigit ; use bigint :: { into_magnitude , magnitude } ; use integer :: Integer ; use traits :: Zero ; # [doc = " A trait for sampling random big integers."] # [doc = ""] # [doc = " The `rand` feature must be enabled to use this. See crate-level documentation for details."] pub trait RandBigInt { # [doc = " Generate a random `BigUint` of the given bit size."] fn gen_biguint (& mut self , bit_size : usize) -> BigUint ; # [doc = " Generate a random BigInt of the given bit size."] fn gen_bigint (& mut self , bit_size : usize) -> BigInt ; # [doc = " Generate a random `BigUint` less than the given bound. Fails"] # [doc = " when the bound is zero."] fn gen_biguint_below (& mut self , bound : & BigUint) -> BigUint ; # [doc = " Generate a random `BigUint` within the given range. The lower"] # [doc = " bound is inclusive; the upper bound is exclusive. Fails when"] # [doc = " the upper bound is not greater than the lower bound."] fn gen_biguint_range (& mut self , lbound : & BigUint , ubound : & BigUint) -> BigUint ; # [doc = " Generate a random `BigInt` within the given range. The lower"] # [doc = " bound is inclusive; the upper bound is exclusive. Fails when"] # [doc = " the upper bound is not greater than the lower bound."] fn gen_bigint_range (& mut self , lbound : & BigInt , ubound : & BigInt) -> BigInt ; } impl < R : Rng + ? Sized > RandBigInt for R { fn gen_biguint (& mut self , bit_size : usize) -> BigUint { use super :: big_digit :: BITS ; let (digits , rem) = bit_size . div_rem (& BITS) ; let mut data = vec ! [BigDigit :: default () ; digits + (rem > 0) as usize] ; self . fill_bytes (data [..] . as_byte_slice_mut ()) ; data . to_le () ; if rem > 0 { data [digits] >>= BITS - rem ; } BigUint :: new (data) } fn gen_bigint (& mut self , bit_size : usize) -> BigInt { loop { let biguint = self . gen_biguint (bit_size) ; let sign = if biguint . is_zero () { if self . gen () { continue ; } else { NoSign } } else if self . gen () { Plus } else { Minus } ; return BigInt :: from_biguint (sign , biguint) ; } } fn gen_biguint_below (& mut self , bound : & BigUint) -> BigUint { assert ! (! bound . is_zero ()) ; let bits = bound . bits () ; loop { let n = self . gen_biguint (bits) ; if n < * bound { return n ; } } } fn gen_biguint_range (& mut self , lbound : & BigUint , ubound : & BigUint) -> BigUint { assert ! (* lbound < * ubound) ; if lbound . is_zero () { self . gen_biguint_below (ubound) } else { lbound + self . gen_biguint_below (& (ubound - lbound)) } } fn gen_bigint_range (& mut self , lbound : & BigInt , ubound : & BigInt) -> BigInt { assert ! (* lbound < * ubound) ; if lbound . is_zero () { BigInt :: from (self . gen_biguint_below (magnitude (& ubound))) } else if ubound . is_zero () { lbound + BigInt :: from (self . gen_biguint_below (magnitude (& lbound))) } else { let delta = ubound - lbound ; lbound + BigInt :: from (self . gen_biguint_below (magnitude (& delta))) } } } # [doc = " The back-end implementing rand's `UniformSampler` for `BigUint`."] # [derive (Clone , Debug)] pub struct UniformBigUint { base : BigUint , len : BigUint , } impl UniformSampler for UniformBigUint { type X = BigUint ; # [inline] fn new (low : Self :: X , high : Self :: X) -> Self { assert ! (low < high) ; UniformBigUint { len : high - & low , base : low , } } # [inline] fn new_inclusive (low : Self :: X , high : Self :: X) -> Self { assert ! (low <= high) ; Self :: new (low , high + 1u32) } # [inline] fn sample < R : Rng + ? Sized > (& self , rng : & mut R) -> Self :: X { & self . base + rng . gen_biguint_below (& self . len) } # [inline] fn sample_single < R : Rng + ? Sized > (low : Self :: X , high : Self :: X , rng : & mut R) -> Self :: X { rng . gen_biguint_range (& low , & high) } } impl SampleUniform for BigUint { type Sampler = UniformBigUint ; } # [doc = " The back-end implementing rand's `UniformSampler` for `BigInt`."] # [derive (Clone , Debug)] pub struct UniformBigInt { base : BigInt , len : BigUint , } impl UniformSampler for UniformBigInt { type X = BigInt ; # [inline] fn new (low : Self :: X , high : Self :: X) -> Self { assert ! (low < high) ; UniformBigInt { len : into_magnitude (high - & low) , base : low , } } # [inline] fn new_inclusive (low : Self :: X , high : Self :: X) -> Self { assert ! (low <= high) ; Self :: new (low , high + 1u32) } # [inline] fn sample < R : Rng + ? Sized > (& self , rng : & mut R) -> Self :: X { & self . base + BigInt :: from (rng . gen_biguint_below (& self . len)) } # [inline] fn sample_single < R : Rng + ? Sized > (low : Self :: X , high : Self :: X , rng : & mut R) -> Self :: X { rng . gen_bigint_range (& low , & high) } } impl SampleUniform for BigInt { type Sampler = UniformBigInt ; } # [doc = " A random distribution for `BigUint` and `BigInt` values of a particular bit size."] # [doc = ""] # [doc = " The `rand` feature must be enabled to use this. See crate-level documentation for details."] # [derive (Clone , Copy , Debug)] pub struct RandomBits { bits : usize , } impl RandomBits { # [inline] pub fn new (bits : usize) -> RandomBits { RandomBits { bits } } } impl Distribution < BigUint > for RandomBits { # [inline] fn sample < R : Rng + ? Sized > (& self , rng : & mut R) -> BigUint { rng . gen_biguint (self . bits) } } impl Distribution < BigInt > for RandomBits { # [inline] fn sample < R : Rng + ? Sized > (& self , rng : & mut R) -> BigInt { rng . gen_bigint (self . bits) } } } # [cfg (target_pointer_width = "32")] type UsizePromotion = u32 ; # [cfg (target_pointer_width = "64")] type UsizePromotion = u64 ; # [cfg (target_pointer_width = "32")] type IsizePromotion = i32 ; # [cfg (target_pointer_width = "64")] type IsizePromotion = i64 ; # [derive (Debug , Clone , PartialEq , Eq)] pub struct ParseBigIntError { kind : BigIntErrorKind , } # [derive (Debug , Clone , PartialEq , Eq)] enum BigIntErrorKind { Empty , InvalidDigit , } impl ParseBigIntError { fn __description (& self) -> & str { use BigIntErrorKind :: * ; match self . kind { Empty => "cannot parse integer from empty string" , InvalidDigit => "invalid digit found in string" , } } fn empty () -> Self { ParseBigIntError { kind : BigIntErrorKind :: Empty , } } fn invalid () -> Self { ParseBigIntError { kind : BigIntErrorKind :: InvalidDigit , } } } impl fmt :: Display for ParseBigIntError { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { self . __description () . fmt (f) } } impl Error for ParseBigIntError { fn description (& self) -> & str { self . __description () } } pub use biguint :: BigUint ; pub use biguint :: ToBigUint ; pub use bigint :: BigInt ; pub use bigint :: Sign ; pub use bigint :: ToBigInt ; # [cfg (feature = "rand")] pub use bigrand :: { RandBigInt , RandomBits , UniformBigInt , UniformBigUint } ; mod big_digit { # [doc = " A `BigDigit` is a `BigUint`'s composing element."] pub type BigDigit = u32 ; # [doc = " A `DoubleBigDigit` is the internal type used to do the computations.  Its"] # [doc = " size is the double of the size of `BigDigit`."] pub type DoubleBigDigit = u64 ; # [doc = " A `SignedDoubleBigDigit` is the signed version of `DoubleBigDigit`."] pub type SignedDoubleBigDigit = i64 ; pub const BITS : usize = 32 ; const LO_MASK : DoubleBigDigit = (- 1i32 as DoubleBigDigit) >> BITS ; # [inline] fn get_hi (n : DoubleBigDigit) -> BigDigit { (n >> BITS) as BigDigit } # [inline] fn get_lo (n : DoubleBigDigit) -> BigDigit { (n & LO_MASK) as BigDigit } # [doc = " Split one `DoubleBigDigit` into two `BigDigit`s."] # [inline] pub fn from_doublebigdigit (n : DoubleBigDigit) -> (BigDigit , BigDigit) { (get_hi (n) , get_lo (n)) } # [doc = " Join two `BigDigit`s into one `DoubleBigDigit`"] # [inline] pub fn to_doublebigdigit (hi : BigDigit , lo : BigDigit) -> DoubleBigDigit { DoubleBigDigit :: from (lo) | (DoubleBigDigit :: from (hi) << BITS) } } }mod num_traits { # ! [doc = " Numeric traits for generic mathematics"] # ! [doc = ""] # ! [doc = " ## Compatibility"] # ! [doc = ""] # ! [doc = " The `num-traits` crate is tested for rustc 1.8 and greater."] # ! [doc (html_root_url = "https://docs.rs/num-traits/0.2")] # ! [deny (unconditional_recursion)] # ! [no_std] # [cfg (feature = "std")] extern crate std ; # [cfg (all (not (feature = "std") , feature = "libm"))] extern crate libm ; use core :: fmt ; use core :: num :: Wrapping ; use core :: ops :: { Add , Div , Mul , Rem , Sub } ; use core :: ops :: { AddAssign , DivAssign , MulAssign , RemAssign , SubAssign } ; pub use bounds :: Bounded ; # [cfg (any (feature = "std" , feature = "libm"))] pub use float :: Float ; pub use float :: FloatConst ; pub use cast :: { cast , AsPrimitive , FromPrimitive , NumCast , ToPrimitive } ; pub use identities :: { one , zero , One , Zero } ; pub use int :: PrimInt ; pub use ops :: checked :: { CheckedAdd , CheckedDiv , CheckedMul , CheckedNeg , CheckedRem , CheckedShl , CheckedShr , CheckedSub , } ; pub use ops :: inv :: Inv ; pub use ops :: mul_add :: { MulAdd , MulAddAssign } ; pub use ops :: saturating :: Saturating ; pub use ops :: wrapping :: { WrappingAdd , WrappingMul , WrappingShl , WrappingShr , WrappingSub } ; pub use pow :: { checked_pow , pow , Pow } ; pub use sign :: { abs , abs_sub , signum , Signed , Unsigned } ; # [macro_use] mod macros { # [doc = " Forward a method to an inherent method or a base trait method."] macro_rules ! forward { ($ (Self :: $ method : ident (self $ (, $ arg : ident : $ ty : ty) *) -> $ ret : ty ;) *) => { $ (# [inline] fn $ method (self $ (, $ arg : $ ty) *) -> $ ret { Self ::$ method (self $ (, $ arg) *) }) * } ; ($ ($ base : ident :: $ method : ident (self $ (, $ arg : ident : $ ty : ty) *) -> $ ret : ty ;) *) => { $ (# [inline] fn $ method (self $ (, $ arg : $ ty) *) -> $ ret { < Self as $ base >::$ method (self $ (, $ arg) *) }) * } ; ($ ($ base : ident :: $ method : ident ($ ($ arg : ident : $ ty : ty) ,*) -> $ ret : ty ;) *) => { $ (# [inline] fn $ method ($ ($ arg : $ ty) ,*) -> $ ret { < Self as $ base >::$ method ($ ($ arg) ,*) }) * } } macro_rules ! constant { ($ ($ method : ident () -> $ ret : expr ;) *) => { $ (# [inline] fn $ method () -> Self { $ ret }) * } ; } } pub mod bounds { use core :: num :: Wrapping ; use core :: { f32 , f64 } ; # [cfg (has_i128)] use core :: { i128 , u128 } ; use core :: { i16 , i32 , i64 , i8 , isize } ; use core :: { u16 , u32 , u64 , u8 , usize } ; # [doc = " Numbers which have upper and lower bounds"] pub trait Bounded { # [doc = " returns the smallest finite number this type can represent"] fn min_value () -> Self ; # [doc = " returns the largest finite number this type can represent"] fn max_value () -> Self ; } macro_rules ! bounded_impl { ($ t : ty , $ min : expr , $ max : expr) => { impl Bounded for $ t { # [inline] fn min_value () -> $ t { $ min } # [inline] fn max_value () -> $ t { $ max } } } ; } bounded_impl ! (usize , usize :: MIN , usize :: MAX) ; bounded_impl ! (u8 , u8 :: MIN , u8 :: MAX) ; bounded_impl ! (u16 , u16 :: MIN , u16 :: MAX) ; bounded_impl ! (u32 , u32 :: MIN , u32 :: MAX) ; bounded_impl ! (u64 , u64 :: MIN , u64 :: MAX) ; # [cfg (has_i128)] bounded_impl ! (u128 , u128 :: MIN , u128 :: MAX) ; bounded_impl ! (isize , isize :: MIN , isize :: MAX) ; bounded_impl ! (i8 , i8 :: MIN , i8 :: MAX) ; bounded_impl ! (i16 , i16 :: MIN , i16 :: MAX) ; bounded_impl ! (i32 , i32 :: MIN , i32 :: MAX) ; bounded_impl ! (i64 , i64 :: MIN , i64 :: MAX) ; # [cfg (has_i128)] bounded_impl ! (i128 , i128 :: MIN , i128 :: MAX) ; impl < T : Bounded > Bounded for Wrapping < T > { fn min_value () -> Self { Wrapping (T :: min_value ()) } fn max_value () -> Self { Wrapping (T :: max_value ()) } } bounded_impl ! (f32 , f32 :: MIN , f32 :: MAX) ; macro_rules ! for_each_tuple_ { ($ m : ident !!) => ($ m ! { }) ; ($ m : ident !! $ h : ident , $ ($ t : ident ,) *) => ($ m ! { $ h $ ($ t) * } for_each_tuple_ ! { $ m !! $ ($ t ,) * }) ; } macro_rules ! for_each_tuple { ($ m : ident) => { for_each_tuple_ ! { $ m !! A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , } } ; } macro_rules ! bounded_tuple { ($ ($ name : ident) *) => (impl <$ ($ name : Bounded ,) *> Bounded for ($ ($ name ,) *) { # [inline] fn min_value () -> Self { ($ ($ name :: min_value () ,) *) } # [inline] fn max_value () -> Self { ($ ($ name :: max_value () ,) *) } }) ; } for_each_tuple ! (bounded_tuple) ; bounded_impl ! (f64 , f64 :: MIN , f64 :: MAX) ; # [test] fn wrapping_bounded () { macro_rules ! test_wrapping_bounded { ($ ($ t : ty) +) => { $ (assert_eq ! (< Wrapping <$ t > as Bounded >:: min_value () . 0 , <$ t >:: min_value ()) ; assert_eq ! (< Wrapping <$ t > as Bounded >:: max_value () . 0 , <$ t >:: max_value ()) ;) + } ; } test_wrapping_bounded ! (usize u8 u16 u32 u64 isize i8 i16 i32 i64) ; } # [cfg (has_i128)] # [test] fn wrapping_bounded_i128 () { macro_rules ! test_wrapping_bounded { ($ ($ t : ty) +) => { $ (assert_eq ! (< Wrapping <$ t > as Bounded >:: min_value () . 0 , <$ t >:: min_value ()) ; assert_eq ! (< Wrapping <$ t > as Bounded >:: max_value () . 0 , <$ t >:: max_value ()) ;) + } ; } test_wrapping_bounded ! (u128 i128) ; } # [test] fn wrapping_is_bounded () { fn require_bounded < T : Bounded > (_ : & T) { } require_bounded (& Wrapping (42_u32)) ; require_bounded (& Wrapping (- 42)) ; } } pub mod cast { use core :: mem :: size_of ; use core :: num :: Wrapping ; use core :: { f32 , f64 } ; # [cfg (has_i128)] use core :: { i128 , u128 } ; use core :: { i16 , i32 , i64 , i8 , isize } ; use core :: { u16 , u32 , u64 , u8 , usize } ; use float :: FloatCore ; # [doc = " A generic trait for converting a value to a number."] pub trait ToPrimitive { # [doc = " Converts the value of `self` to an `isize`. If the value cannot be"] # [doc = " represented by an `isize`, then `None` is returned."] # [inline] fn to_isize (& self) -> Option < isize > { self . to_i64 () . as_ref () . and_then (ToPrimitive :: to_isize) } # [doc = " Converts the value of `self` to an `i8`. If the value cannot be"] # [doc = " represented by an `i8`, then `None` is returned."] # [inline] fn to_i8 (& self) -> Option < i8 > { self . to_i64 () . as_ref () . and_then (ToPrimitive :: to_i8) } # [doc = " Converts the value of `self` to an `i16`. If the value cannot be"] # [doc = " represented by an `i16`, then `None` is returned."] # [inline] fn to_i16 (& self) -> Option < i16 > { self . to_i64 () . as_ref () . and_then (ToPrimitive :: to_i16) } # [doc = " Converts the value of `self` to an `i32`. If the value cannot be"] # [doc = " represented by an `i32`, then `None` is returned."] # [inline] fn to_i32 (& self) -> Option < i32 > { self . to_i64 () . as_ref () . and_then (ToPrimitive :: to_i32) } # [doc = " Converts the value of `self` to an `i64`. If the value cannot be"] # [doc = " represented by an `i64`, then `None` is returned."] fn to_i64 (& self) -> Option < i64 > ; # [doc = " Converts the value of `self` to an `i128`. If the value cannot be"] # [doc = " represented by an `i128` (`i64` under the default implementation), then"] # [doc = " `None` is returned."] # [doc = ""] # [doc = " This method is only available with feature `i128` enabled on Rust >= 1.26."] # [doc = ""] # [doc = " The default implementation converts through `to_i64()`. Types implementing"] # [doc = " this trait should override this method if they can represent a greater range."] # [inline] # [cfg (has_i128)] fn to_i128 (& self) -> Option < i128 > { self . to_i64 () . map (From :: from) } # [doc = " Converts the value of `self` to a `usize`. If the value cannot be"] # [doc = " represented by a `usize`, then `None` is returned."] # [inline] fn to_usize (& self) -> Option < usize > { self . to_u64 () . as_ref () . and_then (ToPrimitive :: to_usize) } # [doc = " Converts the value of `self` to a `u8`. If the value cannot be"] # [doc = " represented by a `u8`, then `None` is returned."] # [inline] fn to_u8 (& self) -> Option < u8 > { self . to_u64 () . as_ref () . and_then (ToPrimitive :: to_u8) } # [doc = " Converts the value of `self` to a `u16`. If the value cannot be"] # [doc = " represented by a `u16`, then `None` is returned."] # [inline] fn to_u16 (& self) -> Option < u16 > { self . to_u64 () . as_ref () . and_then (ToPrimitive :: to_u16) } # [doc = " Converts the value of `self` to a `u32`. If the value cannot be"] # [doc = " represented by a `u32`, then `None` is returned."] # [inline] fn to_u32 (& self) -> Option < u32 > { self . to_u64 () . as_ref () . and_then (ToPrimitive :: to_u32) } # [doc = " Converts the value of `self` to a `u64`. If the value cannot be"] # [doc = " represented by a `u64`, then `None` is returned."] fn to_u64 (& self) -> Option < u64 > ; # [doc = " Converts the value of `self` to a `u128`. If the value cannot be"] # [doc = " represented by a `u128` (`u64` under the default implementation), then"] # [doc = " `None` is returned."] # [doc = ""] # [doc = " This method is only available with feature `i128` enabled on Rust >= 1.26."] # [doc = ""] # [doc = " The default implementation converts through `to_u64()`.  Types implementing"] # [doc = " this trait should override this method if they can represent a greater range."] # [inline] # [cfg (has_i128)] fn to_u128 (& self) -> Option < u128 > { self . to_u64 () . map (From :: from) } # [doc = " Converts the value of `self` to an `f32`. If the value cannot be"] # [doc = " represented by an `f32`, then `None` is returned."] # [inline] fn to_f32 (& self) -> Option < f32 > { self . to_f64 () . as_ref () . and_then (ToPrimitive :: to_f32) } # [doc = " Converts the value of `self` to an `f64`. If the value cannot be"] # [doc = " represented by an `f64`, then `None` is returned."] # [inline] fn to_f64 (& self) -> Option < f64 > { match self . to_i64 () { Some (i) => i . to_f64 () , None => self . to_u64 () . as_ref () . and_then (ToPrimitive :: to_f64) , } } } macro_rules ! impl_to_primitive_int_to_int { ($ SrcT : ident : $ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ DstT : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ DstT > { let min = $ DstT :: MIN as $ SrcT ; let max = $ DstT :: MAX as $ SrcT ; if size_of ::<$ SrcT > () <= size_of ::<$ DstT > () || (min <= * self && * self <= max) { Some (* self as $ DstT) } else { None } }) * } } macro_rules ! impl_to_primitive_int_to_uint { ($ SrcT : ident : $ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ DstT : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ DstT > { let max = $ DstT :: MAX as $ SrcT ; if 0 <= * self && (size_of ::<$ SrcT > () <= size_of ::<$ DstT > () || * self <= max) { Some (* self as $ DstT) } else { None } }) * } } macro_rules ! impl_to_primitive_int { ($ T : ident) => { impl ToPrimitive for $ T { impl_to_primitive_int_to_int ! { $ T : fn to_isize -> isize ; fn to_i8 -> i8 ; fn to_i16 -> i16 ; fn to_i32 -> i32 ; fn to_i64 -> i64 ; # [cfg (has_i128)] fn to_i128 -> i128 ; } impl_to_primitive_int_to_uint ! { $ T : fn to_usize -> usize ; fn to_u8 -> u8 ; fn to_u16 -> u16 ; fn to_u32 -> u32 ; fn to_u64 -> u64 ; # [cfg (has_i128)] fn to_u128 -> u128 ; } # [inline] fn to_f32 (& self) -> Option < f32 > { Some (* self as f32) } # [inline] fn to_f64 (& self) -> Option < f64 > { Some (* self as f64) } } } ; } impl_to_primitive_int ! (isize) ; impl_to_primitive_int ! (i8) ; impl_to_primitive_int ! (i16) ; impl_to_primitive_int ! (i32) ; impl_to_primitive_int ! (i64) ; # [cfg (has_i128)] impl_to_primitive_int ! (i128) ; macro_rules ! impl_to_primitive_uint_to_int { ($ SrcT : ident : $ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ DstT : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ DstT > { let max = $ DstT :: MAX as $ SrcT ; if size_of ::<$ SrcT > () < size_of ::<$ DstT > () || * self <= max { Some (* self as $ DstT) } else { None } }) * } } macro_rules ! impl_to_primitive_uint_to_uint { ($ SrcT : ident : $ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ DstT : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ DstT > { let max = $ DstT :: MAX as $ SrcT ; if size_of ::<$ SrcT > () <= size_of ::<$ DstT > () || * self <= max { Some (* self as $ DstT) } else { None } }) * } } macro_rules ! impl_to_primitive_uint { ($ T : ident) => { impl ToPrimitive for $ T { impl_to_primitive_uint_to_int ! { $ T : fn to_isize -> isize ; fn to_i8 -> i8 ; fn to_i16 -> i16 ; fn to_i32 -> i32 ; fn to_i64 -> i64 ; # [cfg (has_i128)] fn to_i128 -> i128 ; } impl_to_primitive_uint_to_uint ! { $ T : fn to_usize -> usize ; fn to_u8 -> u8 ; fn to_u16 -> u16 ; fn to_u32 -> u32 ; fn to_u64 -> u64 ; # [cfg (has_i128)] fn to_u128 -> u128 ; } # [inline] fn to_f32 (& self) -> Option < f32 > { Some (* self as f32) } # [inline] fn to_f64 (& self) -> Option < f64 > { Some (* self as f64) } } } ; } impl_to_primitive_uint ! (usize) ; impl_to_primitive_uint ! (u8) ; impl_to_primitive_uint ! (u16) ; impl_to_primitive_uint ! (u32) ; impl_to_primitive_uint ! (u64) ; # [cfg (has_i128)] impl_to_primitive_uint ! (u128) ; macro_rules ! impl_to_primitive_float_to_float { ($ SrcT : ident : $ (fn $ method : ident -> $ DstT : ident ;) *) => { $ (# [inline] fn $ method (& self) -> Option <$ DstT > { if size_of ::<$ SrcT > () > size_of ::<$ DstT > () && FloatCore :: is_finite (* self) { let n = * self as f64 ; if n < $ DstT :: MIN as f64 || n > $ DstT :: MAX as f64 { return None ; } } Some (* self as $ DstT) }) * } } macro_rules ! impl_to_primitive_float_to_signed_int { ($ f : ident : $ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ i : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ i > { if size_of ::<$ f > () > size_of ::<$ i > () { const MIN_M1 : $ f = $ i :: MIN as $ f - 1.0 ; const MAX_P1 : $ f = $ i :: MAX as $ f + 1.0 ; if * self > MIN_M1 && * self < MAX_P1 { return Some (* self as $ i) ; } } else { const MIN : $ f = $ i :: MIN as $ f ; const MAX_P1 : $ f = $ i :: MAX as $ f ; if * self >= MIN && * self < MAX_P1 { return Some (* self as $ i) ; } } None }) * } } macro_rules ! impl_to_primitive_float_to_unsigned_int { ($ f : ident : $ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ u : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ u > { if size_of ::<$ f > () > size_of ::<$ u > () { const MAX_P1 : $ f = $ u :: MAX as $ f + 1.0 ; if * self > - 1.0 && * self < MAX_P1 { return Some (* self as $ u) ; } } else { const MAX_P1 : $ f = $ u :: MAX as $ f ; if * self > - 1.0 && * self < MAX_P1 { return Some (* self as $ u) ; } } None }) * } } macro_rules ! impl_to_primitive_float { ($ T : ident) => { impl ToPrimitive for $ T { impl_to_primitive_float_to_signed_int ! { $ T : fn to_isize -> isize ; fn to_i8 -> i8 ; fn to_i16 -> i16 ; fn to_i32 -> i32 ; fn to_i64 -> i64 ; # [cfg (has_i128)] fn to_i128 -> i128 ; } impl_to_primitive_float_to_unsigned_int ! { $ T : fn to_usize -> usize ; fn to_u8 -> u8 ; fn to_u16 -> u16 ; fn to_u32 -> u32 ; fn to_u64 -> u64 ; # [cfg (has_i128)] fn to_u128 -> u128 ; } impl_to_primitive_float_to_float ! { $ T : fn to_f32 -> f32 ; fn to_f64 -> f64 ; } } } ; } impl_to_primitive_float ! (f32) ; impl_to_primitive_float ! (f64) ; # [doc = " A generic trait for converting a number to a value."] pub trait FromPrimitive : Sized { # [doc = " Converts an `isize` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_isize (n : isize) -> Option < Self > { n . to_i64 () . and_then (FromPrimitive :: from_i64) } # [doc = " Converts an `i8` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_i8 (n : i8) -> Option < Self > { FromPrimitive :: from_i64 (From :: from (n)) } # [doc = " Converts an `i16` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_i16 (n : i16) -> Option < Self > { FromPrimitive :: from_i64 (From :: from (n)) } # [doc = " Converts an `i32` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_i32 (n : i32) -> Option < Self > { FromPrimitive :: from_i64 (From :: from (n)) } # [doc = " Converts an `i64` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] fn from_i64 (n : i64) -> Option < Self > ; # [doc = " Converts an `i128` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [doc = ""] # [doc = " This method is only available with feature `i128` enabled on Rust >= 1.26."] # [doc = ""] # [doc = " The default implementation converts through `from_i64()`. Types implementing"] # [doc = " this trait should override this method if they can represent a greater range."] # [inline] # [cfg (has_i128)] fn from_i128 (n : i128) -> Option < Self > { n . to_i64 () . and_then (FromPrimitive :: from_i64) } # [doc = " Converts a `usize` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_usize (n : usize) -> Option < Self > { n . to_u64 () . and_then (FromPrimitive :: from_u64) } # [doc = " Converts an `u8` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_u8 (n : u8) -> Option < Self > { FromPrimitive :: from_u64 (From :: from (n)) } # [doc = " Converts an `u16` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_u16 (n : u16) -> Option < Self > { FromPrimitive :: from_u64 (From :: from (n)) } # [doc = " Converts an `u32` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_u32 (n : u32) -> Option < Self > { FromPrimitive :: from_u64 (From :: from (n)) } # [doc = " Converts an `u64` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] fn from_u64 (n : u64) -> Option < Self > ; # [doc = " Converts an `u128` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [doc = ""] # [doc = " This method is only available with feature `i128` enabled on Rust >= 1.26."] # [doc = ""] # [doc = " The default implementation converts through `from_u64()`. Types implementing"] # [doc = " this trait should override this method if they can represent a greater range."] # [inline] # [cfg (has_i128)] fn from_u128 (n : u128) -> Option < Self > { n . to_u64 () . and_then (FromPrimitive :: from_u64) } # [doc = " Converts a `f32` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_f32 (n : f32) -> Option < Self > { FromPrimitive :: from_f64 (From :: from (n)) } # [doc = " Converts a `f64` to return an optional value of this type. If the"] # [doc = " value cannot be represented by this type, then `None` is returned."] # [inline] fn from_f64 (n : f64) -> Option < Self > { match n . to_i64 () { Some (i) => FromPrimitive :: from_i64 (i) , None => n . to_u64 () . and_then (FromPrimitive :: from_u64) , } } } macro_rules ! impl_from_primitive { ($ T : ty , $ to_ty : ident) => { # [allow (deprecated)] impl FromPrimitive for $ T { # [inline] fn from_isize (n : isize) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_i8 (n : i8) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_i16 (n : i16) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_i32 (n : i32) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_i64 (n : i64) -> Option <$ T > { n .$ to_ty () } # [cfg (has_i128)] # [inline] fn from_i128 (n : i128) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_usize (n : usize) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_u8 (n : u8) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_u16 (n : u16) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_u32 (n : u32) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_u64 (n : u64) -> Option <$ T > { n .$ to_ty () } # [cfg (has_i128)] # [inline] fn from_u128 (n : u128) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_f32 (n : f32) -> Option <$ T > { n .$ to_ty () } # [inline] fn from_f64 (n : f64) -> Option <$ T > { n .$ to_ty () } } } ; } impl_from_primitive ! (isize , to_isize) ; impl_from_primitive ! (i8 , to_i8) ; impl_from_primitive ! (i16 , to_i16) ; impl_from_primitive ! (i32 , to_i32) ; impl_from_primitive ! (i64 , to_i64) ; # [cfg (has_i128)] impl_from_primitive ! (i128 , to_i128) ; impl_from_primitive ! (usize , to_usize) ; impl_from_primitive ! (u8 , to_u8) ; impl_from_primitive ! (u16 , to_u16) ; impl_from_primitive ! (u32 , to_u32) ; impl_from_primitive ! (u64 , to_u64) ; # [cfg (has_i128)] impl_from_primitive ! (u128 , to_u128) ; impl_from_primitive ! (f32 , to_f32) ; impl_from_primitive ! (f64 , to_f64) ; macro_rules ! impl_to_primitive_wrapping { ($ ($ (# [$ cfg : meta]) * fn $ method : ident -> $ i : ident ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (& self) -> Option <$ i > { (self . 0) .$ method () }) * } } impl < T : ToPrimitive > ToPrimitive for Wrapping < T > { impl_to_primitive_wrapping ! { fn to_isize -> isize ; fn to_i8 -> i8 ; fn to_i16 -> i16 ; fn to_i32 -> i32 ; fn to_i64 -> i64 ; # [cfg (has_i128)] fn to_i128 -> i128 ; fn to_usize -> usize ; fn to_u8 -> u8 ; fn to_u16 -> u16 ; fn to_u32 -> u32 ; fn to_u64 -> u64 ; # [cfg (has_i128)] fn to_u128 -> u128 ; fn to_f32 -> f32 ; fn to_f64 -> f64 ; } } macro_rules ! impl_from_primitive_wrapping { ($ ($ (# [$ cfg : meta]) * fn $ method : ident ($ i : ident) ;) *) => { $ (# [inline] $ (# [$ cfg]) * fn $ method (n : $ i) -> Option < Self > { T ::$ method (n) . map (Wrapping) }) * } } impl < T : FromPrimitive > FromPrimitive for Wrapping < T > { impl_from_primitive_wrapping ! { fn from_isize (isize) ; fn from_i8 (i8) ; fn from_i16 (i16) ; fn from_i32 (i32) ; fn from_i64 (i64) ; # [cfg (has_i128)] fn from_i128 (i128) ; fn from_usize (usize) ; fn from_u8 (u8) ; fn from_u16 (u16) ; fn from_u32 (u32) ; fn from_u64 (u64) ; # [cfg (has_i128)] fn from_u128 (u128) ; fn from_f32 (f32) ; fn from_f64 (f64) ; } } # [doc = " Cast from one machine scalar to another."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " # use num_traits as num;"] # [doc = " let twenty: f32 = num::cast(0x14).unwrap();"] # [doc = " assert_eq!(twenty, 20f32);"] # [doc = " ```"] # [doc = ""] # [inline] pub fn cast < T : NumCast , U : NumCast > (n : T) -> Option < U > { NumCast :: from (n) } # [doc = " An interface for casting between machine scalars."] pub trait NumCast : Sized + ToPrimitive { # [doc = " Creates a number from another value that can be converted into"] # [doc = " a primitive via the `ToPrimitive` trait. If the source value cannot be"] # [doc = " represented by the target type, then `None` is returned."] fn from < T : ToPrimitive > (n : T) -> Option < Self > ; } macro_rules ! impl_num_cast { ($ T : ty , $ conv : ident) => { impl NumCast for $ T { # [inline] # [allow (deprecated)] fn from < N : ToPrimitive > (n : N) -> Option <$ T > { n .$ conv () } } } ; } impl_num_cast ! (u8 , to_u8) ; impl_num_cast ! (u16 , to_u16) ; impl_num_cast ! (u32 , to_u32) ; impl_num_cast ! (u64 , to_u64) ; # [cfg (has_i128)] impl_num_cast ! (u128 , to_u128) ; impl_num_cast ! (usize , to_usize) ; impl_num_cast ! (i8 , to_i8) ; impl_num_cast ! (i16 , to_i16) ; impl_num_cast ! (i32 , to_i32) ; impl_num_cast ! (i64 , to_i64) ; # [cfg (has_i128)] impl_num_cast ! (i128 , to_i128) ; impl_num_cast ! (isize , to_isize) ; impl_num_cast ! (f32 , to_f32) ; impl_num_cast ! (f64 , to_f64) ; impl < T : NumCast > NumCast for Wrapping < T > { fn from < U : ToPrimitive > (n : U) -> Option < Self > { T :: from (n) . map (Wrapping) } } # [doc = " A generic interface for casting between machine scalars with the"] # [doc = " `as` operator, which admits narrowing and precision loss."] # [doc = " Implementers of this trait `AsPrimitive` should behave like a primitive"] # [doc = " numeric type (e.g. a newtype around another primitive), and the"] # [doc = " intended conversion must never fail."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " # use num_traits::AsPrimitive;"] # [doc = " let three: i32 = (3.14159265f32).as_();"] # [doc = " assert_eq!(three, 3);"] # [doc = " ```"] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Currently, some uses of the `as` operator are not entirely safe."] # [doc = " In particular, it is undefined behavior if:"] # [doc = ""] # [doc = " - A truncated floating point value cannot fit in the target integer"] # [doc = "   type ([#10184](https://github.com/rust-lang/rust/issues/10184));"] # [doc = ""] # [doc = " ```ignore"] # [doc = " # use num_traits::AsPrimitive;"] # [doc = " let x: u8 = (1.04E+17).as_(); // UB"] # [doc = " ```"] # [doc = ""] # [doc = " - Or a floating point value does not fit in another floating"] # [doc = "   point type ([#15536](https://github.com/rust-lang/rust/issues/15536))."] # [doc = ""] # [doc = " ```ignore"] # [doc = " # use num_traits::AsPrimitive;"] # [doc = " let x: f32 = (1e300f64).as_(); // UB"] # [doc = " ```"] # [doc = ""] pub trait AsPrimitive < T > : 'static + Copy where T : 'static + Copy , { # [doc = " Convert a value to another, using the `as` operator."] fn as_ (self) -> T ; } macro_rules ! impl_as_primitive { (@ $ T : ty => $ (# [$ cfg : meta]) * impl $ U : ty) => { $ (# [$ cfg]) * impl AsPrimitive <$ U > for $ T { # [inline] fn as_ (self) -> $ U { self as $ U } } } ; (@ $ T : ty => { $ ($ U : ty) ,* }) => { $ (impl_as_primitive ! (@ $ T => impl $ U) ;) * } ; ($ T : ty => { $ ($ U : ty) ,* }) => { impl_as_primitive ! (@ $ T => { $ ($ U) ,* }) ; impl_as_primitive ! (@ $ T => { u8 , u16 , u32 , u64 , usize }) ; impl_as_primitive ! (@ $ T => # [cfg (has_i128)] impl u128) ; impl_as_primitive ! (@ $ T => { i8 , i16 , i32 , i64 , isize }) ; impl_as_primitive ! (@ $ T => # [cfg (has_i128)] impl i128) ; } ; } impl_as_primitive ! (u8 => { char , f32 , f64 }) ; impl_as_primitive ! (i8 => { f32 , f64 }) ; impl_as_primitive ! (u16 => { f32 , f64 }) ; impl_as_primitive ! (i16 => { f32 , f64 }) ; impl_as_primitive ! (u32 => { f32 , f64 }) ; impl_as_primitive ! (i32 => { f32 , f64 }) ; impl_as_primitive ! (u64 => { f32 , f64 }) ; impl_as_primitive ! (i64 => { f32 , f64 }) ; # [cfg (has_i128)] impl_as_primitive ! (u128 => { f32 , f64 }) ; # [cfg (has_i128)] impl_as_primitive ! (i128 => { f32 , f64 }) ; impl_as_primitive ! (usize => { f32 , f64 }) ; impl_as_primitive ! (isize => { f32 , f64 }) ; impl_as_primitive ! (f32 => { f32 , f64 }) ; impl_as_primitive ! (f64 => { f32 , f64 }) ; impl_as_primitive ! (char => { char }) ; impl_as_primitive ! (bool => { }) ; } pub mod float { use core :: mem ; use core :: num :: FpCategory ; use core :: ops :: { Add , Neg } ; use core :: f32 ; use core :: f64 ; use { Num , NumCast , ToPrimitive } ; # [cfg (all (not (feature = "std") , feature = "libm"))] use libm ; # [doc = " Generic trait for floating point numbers that works with `no_std`."] # [doc = ""] # [doc = " This trait implements a subset of the `Float` trait."] pub trait FloatCore : Num + NumCast + Neg < Output = Self > + PartialOrd + Copy { # [doc = " Returns positive infinity."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T) {"] # [doc = "     assert!(T::infinity() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY);"] # [doc = " check(f64::INFINITY);"] # [doc = " ```"] fn infinity () -> Self ; # [doc = " Returns negative infinity."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T) {"] # [doc = "     assert!(T::neg_infinity() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::NEG_INFINITY);"] # [doc = " check(f64::NEG_INFINITY);"] # [doc = " ```"] fn neg_infinity () -> Self ; # [doc = " Returns NaN."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = ""] # [doc = " fn check<T: FloatCore>() {"] # [doc = "     let n = T::nan();"] # [doc = "     assert!(n != n);"] # [doc = " }"] # [doc = ""] # [doc = " check::<f32>();"] # [doc = " check::<f64>();"] # [doc = " ```"] fn nan () -> Self ; # [doc = " Returns `-0.0`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(n: T) {"] # [doc = "     let z = T::neg_zero();"] # [doc = "     assert!(z.is_zero());"] # [doc = "     assert!(T::one() / z == n);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::NEG_INFINITY);"] # [doc = " check(f64::NEG_INFINITY);"] # [doc = " ```"] fn neg_zero () -> Self ; # [doc = " Returns the smallest finite value that this type can represent."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T) {"] # [doc = "     assert!(T::min_value() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::MIN);"] # [doc = " check(f64::MIN);"] # [doc = " ```"] fn min_value () -> Self ; # [doc = " Returns the smallest positive, normalized value that this type can represent."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T) {"] # [doc = "     assert!(T::min_positive_value() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::MIN_POSITIVE);"] # [doc = " check(f64::MIN_POSITIVE);"] # [doc = " ```"] fn min_positive_value () -> Self ; # [doc = " Returns epsilon, a small positive value."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T) {"] # [doc = "     assert!(T::epsilon() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::EPSILON);"] # [doc = " check(f64::EPSILON);"] # [doc = " ```"] fn epsilon () -> Self ; # [doc = " Returns the largest finite value that this type can represent."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T) {"] # [doc = "     assert!(T::max_value() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::MAX);"] # [doc = " check(f64::MAX);"] # [doc = " ```"] fn max_value () -> Self ; # [doc = " Returns `true` if the number is NaN."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, p: bool) {"] # [doc = "     assert!(x.is_nan() == p);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::NAN, true);"] # [doc = " check(f32::INFINITY, false);"] # [doc = " check(f64::NAN, true);"] # [doc = " check(0.0f64, false);"] # [doc = " ```"] # [inline] fn is_nan (self) -> bool { self != self } # [doc = " Returns `true` if the number is infinite."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, p: bool) {"] # [doc = "     assert!(x.is_infinite() == p);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, true);"] # [doc = " check(f32::NEG_INFINITY, true);"] # [doc = " check(f32::NAN, false);"] # [doc = " check(f64::INFINITY, true);"] # [doc = " check(f64::NEG_INFINITY, true);"] # [doc = " check(0.0f64, false);"] # [doc = " ```"] # [inline] fn is_infinite (self) -> bool { self == Self :: infinity () || self == Self :: neg_infinity () } # [doc = " Returns `true` if the number is neither infinite or NaN."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, p: bool) {"] # [doc = "     assert!(x.is_finite() == p);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, false);"] # [doc = " check(f32::MAX, true);"] # [doc = " check(f64::NEG_INFINITY, false);"] # [doc = " check(f64::MIN_POSITIVE, true);"] # [doc = " check(f64::NAN, false);"] # [doc = " ```"] # [inline] fn is_finite (self) -> bool { ! (self . is_nan () || self . is_infinite ()) } # [doc = " Returns `true` if the number is neither zero, infinite, subnormal or NaN."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, p: bool) {"] # [doc = "     assert!(x.is_normal() == p);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, false);"] # [doc = " check(f32::MAX, true);"] # [doc = " check(f64::NEG_INFINITY, false);"] # [doc = " check(f64::MIN_POSITIVE, true);"] # [doc = " check(0.0f64, false);"] # [doc = " ```"] # [inline] fn is_normal (self) -> bool { self . classify () == FpCategory :: Normal } # [doc = " Returns the floating point category of the number. If only one property"] # [doc = " is going to be tested, it is generally faster to use the specific"] # [doc = " predicate instead."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = " use std::num::FpCategory;"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, c: FpCategory) {"] # [doc = "     assert!(x.classify() == c);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, FpCategory::Infinite);"] # [doc = " check(f32::MAX, FpCategory::Normal);"] # [doc = " check(f64::NAN, FpCategory::Nan);"] # [doc = " check(f64::MIN_POSITIVE, FpCategory::Normal);"] # [doc = " check(f64::MIN_POSITIVE / 2.0, FpCategory::Subnormal);"] # [doc = " check(0.0f64, FpCategory::Zero);"] # [doc = " ```"] fn classify (self) -> FpCategory ; # [doc = " Returns the largest integer less than or equal to a number."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.floor() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, f32::INFINITY);"] # [doc = " check(0.9f32, 0.0);"] # [doc = " check(1.0f32, 1.0);"] # [doc = " check(1.1f32, 1.0);"] # [doc = " check(-0.0f64, 0.0);"] # [doc = " check(-0.9f64, -1.0);"] # [doc = " check(-1.0f64, -1.0);"] # [doc = " check(-1.1f64, -2.0);"] # [doc = " check(f64::MIN, f64::MIN);"] # [doc = " ```"] # [inline] fn floor (self) -> Self { let f = self . fract () ; if f . is_nan () || f . is_zero () { self } else if self < Self :: zero () { self - f - Self :: one () } else { self - f } } # [doc = " Returns the smallest integer greater than or equal to a number."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.ceil() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, f32::INFINITY);"] # [doc = " check(0.9f32, 1.0);"] # [doc = " check(1.0f32, 1.0);"] # [doc = " check(1.1f32, 2.0);"] # [doc = " check(-0.0f64, 0.0);"] # [doc = " check(-0.9f64, -0.0);"] # [doc = " check(-1.0f64, -1.0);"] # [doc = " check(-1.1f64, -1.0);"] # [doc = " check(f64::MIN, f64::MIN);"] # [doc = " ```"] # [inline] fn ceil (self) -> Self { let f = self . fract () ; if f . is_nan () || f . is_zero () { self } else if self > Self :: zero () { self - f + Self :: one () } else { self - f } } # [doc = " Returns the nearest integer to a number. Round half-way cases away from `0.0`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.round() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, f32::INFINITY);"] # [doc = " check(0.4f32, 0.0);"] # [doc = " check(0.5f32, 1.0);"] # [doc = " check(0.6f32, 1.0);"] # [doc = " check(-0.4f64, 0.0);"] # [doc = " check(-0.5f64, -1.0);"] # [doc = " check(-0.6f64, -1.0);"] # [doc = " check(f64::MIN, f64::MIN);"] # [doc = " ```"] # [inline] fn round (self) -> Self { let one = Self :: one () ; let h = Self :: from (0.5) . expect ("Unable to cast from 0.5") ; let f = self . fract () ; if f . is_nan () || f . is_zero () { self } else if self > Self :: zero () { if f < h { self - f } else { self - f + one } } else { if - f < h { self - f } else { self - f - one } } } # [doc = " Return the integer part of a number."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.trunc() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, f32::INFINITY);"] # [doc = " check(0.9f32, 0.0);"] # [doc = " check(1.0f32, 1.0);"] # [doc = " check(1.1f32, 1.0);"] # [doc = " check(-0.0f64, 0.0);"] # [doc = " check(-0.9f64, -0.0);"] # [doc = " check(-1.0f64, -1.0);"] # [doc = " check(-1.1f64, -1.0);"] # [doc = " check(f64::MIN, f64::MIN);"] # [doc = " ```"] # [inline] fn trunc (self) -> Self { let f = self . fract () ; if f . is_nan () { self } else { self - f } } # [doc = " Returns the fractional part of a number."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.fract() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::MAX, 0.0);"] # [doc = " check(0.75f32, 0.75);"] # [doc = " check(1.0f32, 0.0);"] # [doc = " check(1.25f32, 0.25);"] # [doc = " check(-0.0f64, 0.0);"] # [doc = " check(-0.75f64, -0.75);"] # [doc = " check(-1.0f64, 0.0);"] # [doc = " check(-1.25f64, -0.25);"] # [doc = " check(f64::MIN, 0.0);"] # [doc = " ```"] # [inline] fn fract (self) -> Self { if self . is_zero () { Self :: zero () } else { self % Self :: one () } } # [doc = " Computes the absolute value of `self`. Returns `FloatCore::nan()` if the"] # [doc = " number is `FloatCore::nan()`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.abs() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, f32::INFINITY);"] # [doc = " check(1.0f32, 1.0);"] # [doc = " check(0.0f64, 0.0);"] # [doc = " check(-0.0f64, 0.0);"] # [doc = " check(-1.0f64, 1.0);"] # [doc = " check(f64::MIN, f64::MAX);"] # [doc = " ```"] # [inline] fn abs (self) -> Self { if self . is_sign_positive () { return self ; } if self . is_sign_negative () { return - self ; } Self :: nan () } # [doc = " Returns a number that represents the sign of `self`."] # [doc = ""] # [doc = " - `1.0` if the number is positive, `+0.0` or `FloatCore::infinity()`"] # [doc = " - `-1.0` if the number is negative, `-0.0` or `FloatCore::neg_infinity()`"] # [doc = " - `FloatCore::nan()` if the number is `FloatCore::nan()`"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.signum() == y);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, 1.0);"] # [doc = " check(3.0f32, 1.0);"] # [doc = " check(0.0f32, 1.0);"] # [doc = " check(-0.0f64, -1.0);"] # [doc = " check(-3.0f64, -1.0);"] # [doc = " check(f64::MIN, -1.0);"] # [doc = " ```"] # [inline] fn signum (self) -> Self { if self . is_nan () { Self :: nan () } else if self . is_sign_negative () { - Self :: one () } else { Self :: one () } } # [doc = " Returns `true` if `self` is positive, including `+0.0` and"] # [doc = " `FloatCore::infinity()`, and since Rust 1.20 also"] # [doc = " `FloatCore::nan()`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, p: bool) {"] # [doc = "     assert!(x.is_sign_positive() == p);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, true);"] # [doc = " check(f32::MAX, true);"] # [doc = " check(0.0f32, true);"] # [doc = " check(-0.0f64, false);"] # [doc = " check(f64::NEG_INFINITY, false);"] # [doc = " check(f64::MIN_POSITIVE, true);"] # [doc = " check(-f64::NAN, false);"] # [doc = " ```"] # [inline] fn is_sign_positive (self) -> bool { ! self . is_sign_negative () } # [doc = " Returns `true` if `self` is negative, including `-0.0` and"] # [doc = " `FloatCore::neg_infinity()`, and since Rust 1.20 also"] # [doc = " `-FloatCore::nan()`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, p: bool) {"] # [doc = "     assert!(x.is_sign_negative() == p);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, false);"] # [doc = " check(f32::MAX, false);"] # [doc = " check(0.0f32, false);"] # [doc = " check(-0.0f64, true);"] # [doc = " check(f64::NEG_INFINITY, true);"] # [doc = " check(f64::MIN_POSITIVE, false);"] # [doc = " check(f64::NAN, false);"] # [doc = " ```"] # [inline] fn is_sign_negative (self) -> bool { let (_ , _ , sign) = self . integer_decode () ; sign < 0 } # [doc = " Returns the minimum of the two numbers."] # [doc = ""] # [doc = " If one of the arguments is NaN, then the other argument is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T, min: T) {"] # [doc = "     assert!(x.min(y) == min);"] # [doc = " }"] # [doc = ""] # [doc = " check(1.0f32, 2.0, 1.0);"] # [doc = " check(f32::NAN, 2.0, 2.0);"] # [doc = " check(1.0f64, -2.0, -2.0);"] # [doc = " check(1.0f64, f64::NAN, 1.0);"] # [doc = " ```"] # [inline] fn min (self , other : Self) -> Self { if self . is_nan () { return other ; } if other . is_nan () { return self ; } if self < other { self } else { other } } # [doc = " Returns the maximum of the two numbers."] # [doc = ""] # [doc = " If one of the arguments is NaN, then the other argument is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T, min: T) {"] # [doc = "     assert!(x.max(y) == min);"] # [doc = " }"] # [doc = ""] # [doc = " check(1.0f32, 2.0, 2.0);"] # [doc = " check(1.0f32, f32::NAN, 1.0);"] # [doc = " check(-1.0f64, 2.0, 2.0);"] # [doc = " check(-1.0f64, f64::NAN, -1.0);"] # [doc = " ```"] # [inline] fn max (self , other : Self) -> Self { if self . is_nan () { return other ; } if other . is_nan () { return self ; } if self > other { self } else { other } } # [doc = " Returns the reciprocal (multiplicative inverse) of the number."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, y: T) {"] # [doc = "     assert!(x.recip() == y);"] # [doc = "     assert!(y.recip() == x);"] # [doc = " }"] # [doc = ""] # [doc = " check(f32::INFINITY, 0.0);"] # [doc = " check(2.0f32, 0.5);"] # [doc = " check(-0.25f64, -4.0);"] # [doc = " check(-0.0f64, f64::NEG_INFINITY);"] # [doc = " ```"] # [inline] fn recip (self) -> Self { Self :: one () / self } # [doc = " Raise a number to an integer power."] # [doc = ""] # [doc = " Using this function is generally faster than using `powf`"] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, exp: i32, powi: T) {"] # [doc = "     assert!(x.powi(exp) == powi);"] # [doc = " }"] # [doc = ""] # [doc = " check(9.0f32, 2, 81.0);"] # [doc = " check(1.0f32, -2, 1.0);"] # [doc = " check(10.0f64, 20, 1e20);"] # [doc = " check(4.0f64, -2, 0.0625);"] # [doc = " check(-1.0f64, std::i32::MIN, 1.0);"] # [doc = " ```"] # [inline] fn powi (mut self , mut exp : i32) -> Self { if exp < 0 { exp = exp . wrapping_neg () ; self = self . recip () ; } super :: pow (self , (exp as u32) . to_usize () . unwrap ()) } # [doc = " Converts to degrees, assuming the number is in radians."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(rad: T, deg: T) {"] # [doc = "     assert!(rad.to_degrees() == deg);"] # [doc = " }"] # [doc = ""] # [doc = " check(0.0f32, 0.0);"] # [doc = " check(f32::consts::PI, 180.0);"] # [doc = " check(f64::consts::FRAC_PI_4, 45.0);"] # [doc = " check(f64::INFINITY, f64::INFINITY);"] # [doc = " ```"] fn to_degrees (self) -> Self ; # [doc = " Converts to radians, assuming the number is in degrees."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(deg: T, rad: T) {"] # [doc = "     assert!(deg.to_radians() == rad);"] # [doc = " }"] # [doc = ""] # [doc = " check(0.0f32, 0.0);"] # [doc = " check(180.0, f32::consts::PI);"] # [doc = " check(45.0, f64::consts::FRAC_PI_4);"] # [doc = " check(f64::INFINITY, f64::INFINITY);"] # [doc = " ```"] fn to_radians (self) -> Self ; # [doc = " Returns the mantissa, base 2 exponent, and sign as integers, respectively."] # [doc = " The original number can be recovered by `sign * mantissa * 2 ^ exponent`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::float::FloatCore;"] # [doc = " use std::{f32, f64};"] # [doc = ""] # [doc = " fn check<T: FloatCore>(x: T, m: u64, e: i16, s:i8) {"] # [doc = "     let (mantissa, exponent, sign) = x.integer_decode();"] # [doc = "     assert_eq!(mantissa, m);"] # [doc = "     assert_eq!(exponent, e);"] # [doc = "     assert_eq!(sign, s);"] # [doc = " }"] # [doc = ""] # [doc = " check(2.0f32, 1 << 23, -22, 1);"] # [doc = " check(-2.0f32, 1 << 23, -22, -1);"] # [doc = " check(f32::INFINITY, 1 << 23, 105, 1);"] # [doc = " check(f64::NEG_INFINITY, 1 << 52, 972, -1);"] # [doc = " ```"] fn integer_decode (self) -> (u64 , i16 , i8) ; } impl FloatCore for f32 { constant ! { infinity () -> f32 :: INFINITY ; neg_infinity () -> f32 :: NEG_INFINITY ; nan () -> f32 :: NAN ; neg_zero () -> - 0.0 ; min_value () -> f32 :: MIN ; min_positive_value () -> f32 :: MIN_POSITIVE ; epsilon () -> f32 :: EPSILON ; max_value () -> f32 :: MAX ; } # [inline] fn integer_decode (self) -> (u64 , i16 , i8) { integer_decode_f32 (self) } # [inline] # [cfg (not (feature = "std"))] fn classify (self) -> FpCategory { const EXP_MASK : u32 = 0x7f800000 ; const MAN_MASK : u32 = 0x007fffff ; let bits : u32 = unsafe { mem :: transmute (self) } ; match (bits & MAN_MASK , bits & EXP_MASK) { (0 , 0) => FpCategory :: Zero , (_ , 0) => FpCategory :: Subnormal , (0 , EXP_MASK) => FpCategory :: Infinite , (_ , EXP_MASK) => FpCategory :: Nan , _ => FpCategory :: Normal , } } # [inline] # [cfg (not (feature = "std"))] fn to_degrees (self) -> Self { const PIS_IN_180 : f32 = 57.2957795130823208767981548141051703_f32 ; self * PIS_IN_180 } # [inline] # [cfg (not (feature = "std"))] fn to_radians (self) -> Self { self * (f32 :: consts :: PI / 180.0) } # [cfg (feature = "std")] forward ! { Self :: is_nan (self) -> bool ; Self :: is_infinite (self) -> bool ; Self :: is_finite (self) -> bool ; Self :: is_normal (self) -> bool ; Self :: classify (self) -> FpCategory ; Self :: floor (self) -> Self ; Self :: ceil (self) -> Self ; Self :: round (self) -> Self ; Self :: trunc (self) -> Self ; Self :: fract (self) -> Self ; Self :: abs (self) -> Self ; Self :: signum (self) -> Self ; Self :: is_sign_positive (self) -> bool ; Self :: is_sign_negative (self) -> bool ; Self :: min (self , other : Self) -> Self ; Self :: max (self , other : Self) -> Self ; Self :: recip (self) -> Self ; Self :: powi (self , n : i32) -> Self ; Self :: to_degrees (self) -> Self ; Self :: to_radians (self) -> Self ; } } impl FloatCore for f64 { constant ! { infinity () -> f64 :: INFINITY ; neg_infinity () -> f64 :: NEG_INFINITY ; nan () -> f64 :: NAN ; neg_zero () -> - 0.0 ; min_value () -> f64 :: MIN ; min_positive_value () -> f64 :: MIN_POSITIVE ; epsilon () -> f64 :: EPSILON ; max_value () -> f64 :: MAX ; } # [inline] fn integer_decode (self) -> (u64 , i16 , i8) { integer_decode_f64 (self) } # [inline] # [cfg (not (feature = "std"))] fn classify (self) -> FpCategory { const EXP_MASK : u64 = 0x7ff0000000000000 ; const MAN_MASK : u64 = 0x000fffffffffffff ; let bits : u64 = unsafe { mem :: transmute (self) } ; match (bits & MAN_MASK , bits & EXP_MASK) { (0 , 0) => FpCategory :: Zero , (_ , 0) => FpCategory :: Subnormal , (0 , EXP_MASK) => FpCategory :: Infinite , (_ , EXP_MASK) => FpCategory :: Nan , _ => FpCategory :: Normal , } } # [inline] # [cfg (not (feature = "std"))] fn to_degrees (self) -> Self { self * (180.0 / f64 :: consts :: PI) } # [inline] # [cfg (not (feature = "std"))] fn to_radians (self) -> Self { self * (f64 :: consts :: PI / 180.0) } # [cfg (feature = "std")] forward ! { Self :: is_nan (self) -> bool ; Self :: is_infinite (self) -> bool ; Self :: is_finite (self) -> bool ; Self :: is_normal (self) -> bool ; Self :: classify (self) -> FpCategory ; Self :: floor (self) -> Self ; Self :: ceil (self) -> Self ; Self :: round (self) -> Self ; Self :: trunc (self) -> Self ; Self :: fract (self) -> Self ; Self :: abs (self) -> Self ; Self :: signum (self) -> Self ; Self :: is_sign_positive (self) -> bool ; Self :: is_sign_negative (self) -> bool ; Self :: min (self , other : Self) -> Self ; Self :: max (self , other : Self) -> Self ; Self :: recip (self) -> Self ; Self :: powi (self , n : i32) -> Self ; Self :: to_degrees (self) -> Self ; Self :: to_radians (self) -> Self ; } } # [doc = " Generic trait for floating point numbers"] # [doc = ""] # [doc = " This trait is only available with the `std` feature, or with the `libm` feature otherwise."] # [cfg (any (feature = "std" , feature = "libm"))] pub trait Float : Num + Copy + NumCast + PartialOrd + Neg < Output = Self > { # [doc = " Returns the `NaN` value."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let nan: f32 = Float::nan();"] # [doc = ""] # [doc = " assert!(nan.is_nan());"] # [doc = " ```"] fn nan () -> Self ; # [doc = " Returns the infinite value."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let infinity: f32 = Float::infinity();"] # [doc = ""] # [doc = " assert!(infinity.is_infinite());"] # [doc = " assert!(!infinity.is_finite());"] # [doc = " assert!(infinity > f32::MAX);"] # [doc = " ```"] fn infinity () -> Self ; # [doc = " Returns the negative infinite value."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let neg_infinity: f32 = Float::neg_infinity();"] # [doc = ""] # [doc = " assert!(neg_infinity.is_infinite());"] # [doc = " assert!(!neg_infinity.is_finite());"] # [doc = " assert!(neg_infinity < f32::MIN);"] # [doc = " ```"] fn neg_infinity () -> Self ; # [doc = " Returns `-0.0`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::{Zero, Float};"] # [doc = ""] # [doc = " let inf: f32 = Float::infinity();"] # [doc = " let zero: f32 = Zero::zero();"] # [doc = " let neg_zero: f32 = Float::neg_zero();"] # [doc = ""] # [doc = " assert_eq!(zero, neg_zero);"] # [doc = " assert_eq!(7.0f32/inf, zero);"] # [doc = " assert_eq!(zero * 10.0, zero);"] # [doc = " ```"] fn neg_zero () -> Self ; # [doc = " Returns the smallest finite value that this type can represent."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Float::min_value();"] # [doc = ""] # [doc = " assert_eq!(x, f64::MIN);"] # [doc = " ```"] fn min_value () -> Self ; # [doc = " Returns the smallest positive, normalized value that this type can represent."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Float::min_positive_value();"] # [doc = ""] # [doc = " assert_eq!(x, f64::MIN_POSITIVE);"] # [doc = " ```"] fn min_positive_value () -> Self ; # [doc = " Returns epsilon, a small positive value."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Float::epsilon();"] # [doc = ""] # [doc = " assert_eq!(x, f64::EPSILON);"] # [doc = " ```"] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " The default implementation will panic if `f32::EPSILON` cannot"] # [doc = " be cast to `Self`."] fn epsilon () -> Self { Self :: from (f32 :: EPSILON) . expect ("Unable to cast from f32::EPSILON") } # [doc = " Returns the largest finite value that this type can represent."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Float::max_value();"] # [doc = " assert_eq!(x, f64::MAX);"] # [doc = " ```"] fn max_value () -> Self ; # [doc = " Returns `true` if this value is `NaN` and false otherwise."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let nan = f64::NAN;"] # [doc = " let f = 7.0;"] # [doc = ""] # [doc = " assert!(nan.is_nan());"] # [doc = " assert!(!f.is_nan());"] # [doc = " ```"] fn is_nan (self) -> bool ; # [doc = " Returns `true` if this value is positive infinity or negative infinity and"] # [doc = " false otherwise."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let f = 7.0f32;"] # [doc = " let inf: f32 = Float::infinity();"] # [doc = " let neg_inf: f32 = Float::neg_infinity();"] # [doc = " let nan: f32 = f32::NAN;"] # [doc = ""] # [doc = " assert!(!f.is_infinite());"] # [doc = " assert!(!nan.is_infinite());"] # [doc = ""] # [doc = " assert!(inf.is_infinite());"] # [doc = " assert!(neg_inf.is_infinite());"] # [doc = " ```"] fn is_infinite (self) -> bool ; # [doc = " Returns `true` if this number is neither infinite nor `NaN`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let f = 7.0f32;"] # [doc = " let inf: f32 = Float::infinity();"] # [doc = " let neg_inf: f32 = Float::neg_infinity();"] # [doc = " let nan: f32 = f32::NAN;"] # [doc = ""] # [doc = " assert!(f.is_finite());"] # [doc = ""] # [doc = " assert!(!nan.is_finite());"] # [doc = " assert!(!inf.is_finite());"] # [doc = " assert!(!neg_inf.is_finite());"] # [doc = " ```"] fn is_finite (self) -> bool ; # [doc = " Returns `true` if the number is neither zero, infinite,"] # [doc = " [subnormal][subnormal], or `NaN`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let min = f32::MIN_POSITIVE; // 1.17549435e-38f32"] # [doc = " let max = f32::MAX;"] # [doc = " let lower_than_min = 1.0e-40_f32;"] # [doc = " let zero = 0.0f32;"] # [doc = ""] # [doc = " assert!(min.is_normal());"] # [doc = " assert!(max.is_normal());"] # [doc = ""] # [doc = " assert!(!zero.is_normal());"] # [doc = " assert!(!f32::NAN.is_normal());"] # [doc = " assert!(!f32::INFINITY.is_normal());"] # [doc = " // Values between `0` and `min` are Subnormal."] # [doc = " assert!(!lower_than_min.is_normal());"] # [doc = " ```"] # [doc = " [subnormal]: http://en.wikipedia.org/wiki/Denormal_number"] fn is_normal (self) -> bool ; # [doc = " Returns the floating point category of the number. If only one property"] # [doc = " is going to be tested, it is generally faster to use the specific"] # [doc = " predicate instead."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::num::FpCategory;"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let num = 12.4f32;"] # [doc = " let inf = f32::INFINITY;"] # [doc = ""] # [doc = " assert_eq!(num.classify(), FpCategory::Normal);"] # [doc = " assert_eq!(inf.classify(), FpCategory::Infinite);"] # [doc = " ```"] fn classify (self) -> FpCategory ; # [doc = " Returns the largest integer less than or equal to a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let f = 3.99;"] # [doc = " let g = 3.0;"] # [doc = ""] # [doc = " assert_eq!(f.floor(), 3.0);"] # [doc = " assert_eq!(g.floor(), 3.0);"] # [doc = " ```"] fn floor (self) -> Self ; # [doc = " Returns the smallest integer greater than or equal to a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let f = 3.01;"] # [doc = " let g = 4.0;"] # [doc = ""] # [doc = " assert_eq!(f.ceil(), 4.0);"] # [doc = " assert_eq!(g.ceil(), 4.0);"] # [doc = " ```"] fn ceil (self) -> Self ; # [doc = " Returns the nearest integer to a number. Round half-way cases away from"] # [doc = " `0.0`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let f = 3.3;"] # [doc = " let g = -3.3;"] # [doc = ""] # [doc = " assert_eq!(f.round(), 3.0);"] # [doc = " assert_eq!(g.round(), -3.0);"] # [doc = " ```"] fn round (self) -> Self ; # [doc = " Return the integer part of a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let f = 3.3;"] # [doc = " let g = -3.7;"] # [doc = ""] # [doc = " assert_eq!(f.trunc(), 3.0);"] # [doc = " assert_eq!(g.trunc(), -3.0);"] # [doc = " ```"] fn trunc (self) -> Self ; # [doc = " Returns the fractional part of a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 3.5;"] # [doc = " let y = -3.5;"] # [doc = " let abs_difference_x = (x.fract() - 0.5).abs();"] # [doc = " let abs_difference_y = (y.fract() - (-0.5)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_x < 1e-10);"] # [doc = " assert!(abs_difference_y < 1e-10);"] # [doc = " ```"] fn fract (self) -> Self ; # [doc = " Computes the absolute value of `self`. Returns `Float::nan()` if the"] # [doc = " number is `Float::nan()`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = 3.5;"] # [doc = " let y = -3.5;"] # [doc = ""] # [doc = " let abs_difference_x = (x.abs() - x).abs();"] # [doc = " let abs_difference_y = (y.abs() - (-y)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_x < 1e-10);"] # [doc = " assert!(abs_difference_y < 1e-10);"] # [doc = ""] # [doc = " assert!(f64::NAN.abs().is_nan());"] # [doc = " ```"] fn abs (self) -> Self ; # [doc = " Returns a number that represents the sign of `self`."] # [doc = ""] # [doc = " - `1.0` if the number is positive, `+0.0` or `Float::infinity()`"] # [doc = " - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`"] # [doc = " - `Float::nan()` if the number is `Float::nan()`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let f = 3.5;"] # [doc = ""] # [doc = " assert_eq!(f.signum(), 1.0);"] # [doc = " assert_eq!(f64::NEG_INFINITY.signum(), -1.0);"] # [doc = ""] # [doc = " assert!(f64::NAN.signum().is_nan());"] # [doc = " ```"] fn signum (self) -> Self ; # [doc = " Returns `true` if `self` is positive, including `+0.0`,"] # [doc = " `Float::infinity()`, and since Rust 1.20 also `Float::nan()`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let neg_nan: f64 = -f64::NAN;"] # [doc = ""] # [doc = " let f = 7.0;"] # [doc = " let g = -7.0;"] # [doc = ""] # [doc = " assert!(f.is_sign_positive());"] # [doc = " assert!(!g.is_sign_positive());"] # [doc = " assert!(!neg_nan.is_sign_positive());"] # [doc = " ```"] fn is_sign_positive (self) -> bool ; # [doc = " Returns `true` if `self` is negative, including `-0.0`,"] # [doc = " `Float::neg_infinity()`, and since Rust 1.20 also `-Float::nan()`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let nan: f64 = f64::NAN;"] # [doc = ""] # [doc = " let f = 7.0;"] # [doc = " let g = -7.0;"] # [doc = ""] # [doc = " assert!(!f.is_sign_negative());"] # [doc = " assert!(g.is_sign_negative());"] # [doc = " assert!(!nan.is_sign_negative());"] # [doc = " ```"] fn is_sign_negative (self) -> bool ; # [doc = " Fused multiply-add. Computes `(self * a) + b` with only one rounding"] # [doc = " error, yielding a more accurate result than an unfused multiply-add."] # [doc = ""] # [doc = " Using `mul_add` can be more performant than an unfused multiply-add if"] # [doc = " the target architecture has a dedicated `fma` CPU instruction."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let m = 10.0;"] # [doc = " let x = 4.0;"] # [doc = " let b = 60.0;"] # [doc = ""] # [doc = " // 100.0"] # [doc = " let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn mul_add (self , a : Self , b : Self) -> Self ; # [doc = " Take the reciprocal (inverse) of a number, `1/x`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let abs_difference = (x.recip() - (1.0/x)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn recip (self) -> Self ; # [doc = " Raise a number to an integer power."] # [doc = ""] # [doc = " Using this function is generally faster than using `powf`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let abs_difference = (x.powi(2) - x*x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn powi (self , n : i32) -> Self ; # [doc = " Raise a number to a floating point power."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let abs_difference = (x.powf(2.0) - x*x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn powf (self , n : Self) -> Self ; # [doc = " Take the square root of a number."] # [doc = ""] # [doc = " Returns NaN if `self` is a negative number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let positive = 4.0;"] # [doc = " let negative = -4.0;"] # [doc = ""] # [doc = " let abs_difference = (positive.sqrt() - 2.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " assert!(negative.sqrt().is_nan());"] # [doc = " ```"] fn sqrt (self) -> Self ; # [doc = " Returns `e^(self)`, (the exponential function)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let one = 1.0;"] # [doc = " // e^1"] # [doc = " let e = one.exp();"] # [doc = ""] # [doc = " // ln(e) - 1 == 0"] # [doc = " let abs_difference = (e.ln() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn exp (self) -> Self ; # [doc = " Returns `2^(self)`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let f = 2.0;"] # [doc = ""] # [doc = " // 2^2 - 4 == 0"] # [doc = " let abs_difference = (f.exp2() - 4.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn exp2 (self) -> Self ; # [doc = " Returns the natural logarithm of the number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let one = 1.0;"] # [doc = " // e^1"] # [doc = " let e = one.exp();"] # [doc = ""] # [doc = " // ln(e) - 1 == 0"] # [doc = " let abs_difference = (e.ln() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn ln (self) -> Self ; # [doc = " Returns the logarithm of the number with respect to an arbitrary base."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let ten = 10.0;"] # [doc = " let two = 2.0;"] # [doc = ""] # [doc = " // log10(10) - 1 == 0"] # [doc = " let abs_difference_10 = (ten.log(10.0) - 1.0).abs();"] # [doc = ""] # [doc = " // log2(2) - 1 == 0"] # [doc = " let abs_difference_2 = (two.log(2.0) - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_10 < 1e-10);"] # [doc = " assert!(abs_difference_2 < 1e-10);"] # [doc = " ```"] fn log (self , base : Self) -> Self ; # [doc = " Returns the base 2 logarithm of the number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let two = 2.0;"] # [doc = ""] # [doc = " // log2(2) - 1 == 0"] # [doc = " let abs_difference = (two.log2() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn log2 (self) -> Self ; # [doc = " Returns the base 10 logarithm of the number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let ten = 10.0;"] # [doc = ""] # [doc = " // log10(10) - 1 == 0"] # [doc = " let abs_difference = (ten.log10() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn log10 (self) -> Self ; # [doc = " Converts radians to degrees."] # [doc = ""] # [doc = " ```"] # [doc = " use std::f64::consts;"] # [doc = ""] # [doc = " let angle = consts::PI;"] # [doc = ""] # [doc = " let abs_difference = (angle.to_degrees() - 180.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] # [inline] fn to_degrees (self) -> Self { let halfpi = Self :: zero () . acos () ; let ninety = Self :: from (90u8) . unwrap () ; self * ninety / halfpi } # [doc = " Converts degrees to radians."] # [doc = ""] # [doc = " ```"] # [doc = " use std::f64::consts;"] # [doc = ""] # [doc = " let angle = 180.0_f64;"] # [doc = ""] # [doc = " let abs_difference = (angle.to_radians() - consts::PI).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] # [inline] fn to_radians (self) -> Self { let halfpi = Self :: zero () . acos () ; let ninety = Self :: from (90u8) . unwrap () ; self * halfpi / ninety } # [doc = " Returns the maximum of the two numbers."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let y = 2.0;"] # [doc = ""] # [doc = " assert_eq!(x.max(y), y);"] # [doc = " ```"] fn max (self , other : Self) -> Self ; # [doc = " Returns the minimum of the two numbers."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let y = 2.0;"] # [doc = ""] # [doc = " assert_eq!(x.min(y), x);"] # [doc = " ```"] fn min (self , other : Self) -> Self ; # [doc = " The positive difference of two numbers."] # [doc = ""] # [doc = " * If `self <= other`: `0:0`"] # [doc = " * Else: `self - other`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 3.0;"] # [doc = " let y = -3.0;"] # [doc = ""] # [doc = " let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();"] # [doc = " let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_x < 1e-10);"] # [doc = " assert!(abs_difference_y < 1e-10);"] # [doc = " ```"] fn abs_sub (self , other : Self) -> Self ; # [doc = " Take the cubic root of a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 8.0;"] # [doc = ""] # [doc = " // x^(1/3) - 2 == 0"] # [doc = " let abs_difference = (x.cbrt() - 2.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn cbrt (self) -> Self ; # [doc = " Calculate the length of the hypotenuse of a right-angle triangle given"] # [doc = " legs of length `x` and `y`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let y = 3.0;"] # [doc = ""] # [doc = " // sqrt(x^2 + y^2)"] # [doc = " let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn hypot (self , other : Self) -> Self ; # [doc = " Computes the sine of a number (in radians)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::PI/2.0;"] # [doc = ""] # [doc = " let abs_difference = (x.sin() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn sin (self) -> Self ; # [doc = " Computes the cosine of a number (in radians)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = 2.0*f64::consts::PI;"] # [doc = ""] # [doc = " let abs_difference = (x.cos() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn cos (self) -> Self ; # [doc = " Computes the tangent of a number (in radians)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::PI/4.0;"] # [doc = " let abs_difference = (x.tan() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-14);"] # [doc = " ```"] fn tan (self) -> Self ; # [doc = " Computes the arcsine of a number. Return value is in radians in"] # [doc = " the range [-pi/2, pi/2] or NaN if the number is outside the range"] # [doc = " [-1, 1]."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let f = f64::consts::PI / 2.0;"] # [doc = ""] # [doc = " // asin(sin(pi/2))"] # [doc = " let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn asin (self) -> Self ; # [doc = " Computes the arccosine of a number. Return value is in radians in"] # [doc = " the range [0, pi] or NaN if the number is outside the range"] # [doc = " [-1, 1]."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let f = f64::consts::PI / 4.0;"] # [doc = ""] # [doc = " // acos(cos(pi/4))"] # [doc = " let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn acos (self) -> Self ; # [doc = " Computes the arctangent of a number. Return value is in radians in the"] # [doc = " range [-pi/2, pi/2];"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let f = 1.0;"] # [doc = ""] # [doc = " // atan(tan(1))"] # [doc = " let abs_difference = (f.tan().atan() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn atan (self) -> Self ; # [doc = " Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`)."] # [doc = ""] # [doc = " * `x = 0`, `y = 0`: `0`"] # [doc = " * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`"] # [doc = " * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`"] # [doc = " * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let pi = f64::consts::PI;"] # [doc = " // All angles from horizontal right (+x)"] # [doc = " // 45 deg counter-clockwise"] # [doc = " let x1 = 3.0;"] # [doc = " let y1 = -3.0;"] # [doc = ""] # [doc = " // 135 deg clockwise"] # [doc = " let x2 = -3.0;"] # [doc = " let y2 = 3.0;"] # [doc = ""] # [doc = " let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();"] # [doc = " let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_1 < 1e-10);"] # [doc = " assert!(abs_difference_2 < 1e-10);"] # [doc = " ```"] fn atan2 (self , other : Self) -> Self ; # [doc = " Simultaneously computes the sine and cosine of the number, `x`. Returns"] # [doc = " `(sin(x), cos(x))`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::PI/4.0;"] # [doc = " let f = x.sin_cos();"] # [doc = ""] # [doc = " let abs_difference_0 = (f.0 - x.sin()).abs();"] # [doc = " let abs_difference_1 = (f.1 - x.cos()).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_0 < 1e-10);"] # [doc = " assert!(abs_difference_0 < 1e-10);"] # [doc = " ```"] fn sin_cos (self) -> (Self , Self) ; # [doc = " Returns `e^(self) - 1` in a way that is accurate even if the"] # [doc = " number is close to zero."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 7.0;"] # [doc = ""] # [doc = " // e^(ln(7)) - 1"] # [doc = " let abs_difference = (x.ln().exp_m1() - 6.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn exp_m1 (self) -> Self ; # [doc = " Returns `ln(1+n)` (natural logarithm) more accurately than if"] # [doc = " the operations were performed separately."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::E - 1.0;"] # [doc = ""] # [doc = " // ln(1 + (e - 1)) == ln(e) == 1"] # [doc = " let abs_difference = (x.ln_1p() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn ln_1p (self) -> Self ; # [doc = " Hyperbolic sine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let x = 1.0;"] # [doc = ""] # [doc = " let f = x.sinh();"] # [doc = " // Solving sinh() at 1 gives `(e^2-1)/(2e)`"] # [doc = " let g = (e*e - 1.0)/(2.0*e);"] # [doc = " let abs_difference = (f - g).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn sinh (self) -> Self ; # [doc = " Hyperbolic cosine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let x = 1.0;"] # [doc = " let f = x.cosh();"] # [doc = " // Solving cosh() at 1 gives this result"] # [doc = " let g = (e*e + 1.0)/(2.0*e);"] # [doc = " let abs_difference = (f - g).abs();"] # [doc = ""] # [doc = " // Same result"] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn cosh (self) -> Self ; # [doc = " Hyperbolic tangent function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let x = 1.0;"] # [doc = ""] # [doc = " let f = x.tanh();"] # [doc = " // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`"] # [doc = " let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));"] # [doc = " let abs_difference = (f - g).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn tanh (self) -> Self ; # [doc = " Inverse hyperbolic sine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let f = x.sinh().asinh();"] # [doc = ""] # [doc = " let abs_difference = (f - x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn asinh (self) -> Self ; # [doc = " Inverse hyperbolic cosine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let f = x.cosh().acosh();"] # [doc = ""] # [doc = " let abs_difference = (f - x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn acosh (self) -> Self ; # [doc = " Inverse hyperbolic tangent function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let f = e.tanh().atanh();"] # [doc = ""] # [doc = " let abs_difference = (f - e).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn atanh (self) -> Self ; # [doc = " Returns the mantissa, base 2 exponent, and sign as integers, respectively."] # [doc = " The original number can be recovered by `sign * mantissa * 2 ^ exponent`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Float;"] # [doc = ""] # [doc = " let num = 2.0f32;"] # [doc = ""] # [doc = " // (8388608, -22, 1)"] # [doc = " let (mantissa, exponent, sign) = Float::integer_decode(num);"] # [doc = " let sign_f = sign as f32;"] # [doc = " let mantissa_f = mantissa as f32;"] # [doc = " let exponent_f = num.powf(exponent as f32);"] # [doc = ""] # [doc = " // 1 * 8388608 * 2^(-22) == 2"] # [doc = " let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn integer_decode (self) -> (u64 , i16 , i8) ; } # [cfg (feature = "std")] macro_rules ! float_impl_std { ($ T : ident $ decode : ident) => { impl Float for $ T { constant ! { nan () -> $ T :: NAN ; infinity () -> $ T :: INFINITY ; neg_infinity () -> $ T :: NEG_INFINITY ; neg_zero () -> - 0.0 ; min_value () -> $ T :: MIN ; min_positive_value () -> $ T :: MIN_POSITIVE ; epsilon () -> $ T :: EPSILON ; max_value () -> $ T :: MAX ; } # [inline] # [allow (deprecated)] fn abs_sub (self , other : Self) -> Self { <$ T >:: abs_sub (self , other) } # [inline] fn integer_decode (self) -> (u64 , i16 , i8) { $ decode (self) } forward ! { Self :: is_nan (self) -> bool ; Self :: is_infinite (self) -> bool ; Self :: is_finite (self) -> bool ; Self :: is_normal (self) -> bool ; Self :: classify (self) -> FpCategory ; Self :: floor (self) -> Self ; Self :: ceil (self) -> Self ; Self :: round (self) -> Self ; Self :: trunc (self) -> Self ; Self :: fract (self) -> Self ; Self :: abs (self) -> Self ; Self :: signum (self) -> Self ; Self :: is_sign_positive (self) -> bool ; Self :: is_sign_negative (self) -> bool ; Self :: mul_add (self , a : Self , b : Self) -> Self ; Self :: recip (self) -> Self ; Self :: powi (self , n : i32) -> Self ; Self :: powf (self , n : Self) -> Self ; Self :: sqrt (self) -> Self ; Self :: exp (self) -> Self ; Self :: exp2 (self) -> Self ; Self :: ln (self) -> Self ; Self :: log (self , base : Self) -> Self ; Self :: log2 (self) -> Self ; Self :: log10 (self) -> Self ; Self :: to_degrees (self) -> Self ; Self :: to_radians (self) -> Self ; Self :: max (self , other : Self) -> Self ; Self :: min (self , other : Self) -> Self ; Self :: cbrt (self) -> Self ; Self :: hypot (self , other : Self) -> Self ; Self :: sin (self) -> Self ; Self :: cos (self) -> Self ; Self :: tan (self) -> Self ; Self :: asin (self) -> Self ; Self :: acos (self) -> Self ; Self :: atan (self) -> Self ; Self :: atan2 (self , other : Self) -> Self ; Self :: sin_cos (self) -> (Self , Self) ; Self :: exp_m1 (self) -> Self ; Self :: ln_1p (self) -> Self ; Self :: sinh (self) -> Self ; Self :: cosh (self) -> Self ; Self :: tanh (self) -> Self ; Self :: asinh (self) -> Self ; Self :: acosh (self) -> Self ; Self :: atanh (self) -> Self ; } } } ; } # [cfg (all (not (feature = "std") , feature = "libm"))] macro_rules ! float_impl_libm { ($ T : ident $ decode : ident) => { constant ! { nan () -> $ T :: NAN ; infinity () -> $ T :: INFINITY ; neg_infinity () -> $ T :: NEG_INFINITY ; neg_zero () -> - 0.0 ; min_value () -> $ T :: MIN ; min_positive_value () -> $ T :: MIN_POSITIVE ; epsilon () -> $ T :: EPSILON ; max_value () -> $ T :: MAX ; } # [inline] fn integer_decode (self) -> (u64 , i16 , i8) { $ decode (self) } # [inline] fn fract (self) -> Self { self - FloatCore :: trunc (self) } # [inline] fn log (self , base : Self) -> Self { self . ln () / base . ln () } forward ! { FloatCore :: is_nan (self) -> bool ; FloatCore :: is_infinite (self) -> bool ; FloatCore :: is_finite (self) -> bool ; FloatCore :: is_normal (self) -> bool ; FloatCore :: classify (self) -> FpCategory ; FloatCore :: signum (self) -> Self ; FloatCore :: is_sign_positive (self) -> bool ; FloatCore :: is_sign_negative (self) -> bool ; FloatCore :: recip (self) -> Self ; FloatCore :: powi (self , n : i32) -> Self ; FloatCore :: to_degrees (self) -> Self ; FloatCore :: to_radians (self) -> Self ; FloatCore :: max (self , other : Self) -> Self ; FloatCore :: min (self , other : Self) -> Self ; } } ; } fn integer_decode_f32 (f : f32) -> (u64 , i16 , i8) { let bits : u32 = unsafe { mem :: transmute (f) } ; let sign : i8 = if bits >> 31 == 0 { 1 } else { - 1 } ; let mut exponent : i16 = ((bits >> 23) & 0xff) as i16 ; let mantissa = if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 } ; exponent -= 127 + 23 ; (mantissa as u64 , exponent , sign) } fn integer_decode_f64 (f : f64) -> (u64 , i16 , i8) { let bits : u64 = unsafe { mem :: transmute (f) } ; let sign : i8 = if bits >> 63 == 0 { 1 } else { - 1 } ; let mut exponent : i16 = ((bits >> 52) & 0x7ff) as i16 ; let mantissa = if exponent == 0 { (bits & 0xfffffffffffff) << 1 } else { (bits & 0xfffffffffffff) | 0x10000000000000 } ; exponent -= 1023 + 52 ; (mantissa , exponent , sign) } # [cfg (feature = "std")] float_impl_std ! (f32 integer_decode_f32) ; # [cfg (feature = "std")] float_impl_std ! (f64 integer_decode_f64) ; # [cfg (all (not (feature = "std") , feature = "libm"))] impl Float for f32 { float_impl_libm ! (f32 integer_decode_f32) ; # [inline] # [allow (deprecated)] fn abs_sub (self , other : Self) -> Self { libm :: fdimf (self , other) } # [inline] fn floor (self) -> Self { libm :: floorf (self) } # [inline] fn ceil (self) -> Self { libm :: ceilf (self) } # [inline] fn round (self) -> Self { libm :: roundf (self) } # [inline] fn trunc (self) -> Self { libm :: truncf (self) } # [inline] fn abs (self) -> Self { libm :: fabsf (self) } # [inline] fn mul_add (self , a : Self , b : Self) -> Self { libm :: fmaf (self , a , b) } # [inline] fn powf (self , n : Self) -> Self { libm :: powf (self , n) } # [inline] fn sqrt (self) -> Self { libm :: sqrtf (self) } # [inline] fn exp (self) -> Self { libm :: expf (self) } # [inline] fn exp2 (self) -> Self { libm :: exp2f (self) } # [inline] fn ln (self) -> Self { libm :: logf (self) } # [inline] fn log2 (self) -> Self { libm :: log2f (self) } # [inline] fn log10 (self) -> Self { libm :: log10f (self) } # [inline] fn cbrt (self) -> Self { libm :: cbrtf (self) } # [inline] fn hypot (self , other : Self) -> Self { libm :: hypotf (self , other) } # [inline] fn sin (self) -> Self { libm :: sinf (self) } # [inline] fn cos (self) -> Self { libm :: cosf (self) } # [inline] fn tan (self) -> Self { libm :: tanf (self) } # [inline] fn asin (self) -> Self { libm :: asinf (self) } # [inline] fn acos (self) -> Self { libm :: acosf (self) } # [inline] fn atan (self) -> Self { libm :: atanf (self) } # [inline] fn atan2 (self , other : Self) -> Self { libm :: atan2f (self , other) } # [inline] fn sin_cos (self) -> (Self , Self) { libm :: sincosf (self) } # [inline] fn exp_m1 (self) -> Self { libm :: expm1f (self) } # [inline] fn ln_1p (self) -> Self { libm :: log1pf (self) } # [inline] fn sinh (self) -> Self { libm :: sinhf (self) } # [inline] fn cosh (self) -> Self { libm :: coshf (self) } # [inline] fn tanh (self) -> Self { libm :: tanhf (self) } # [inline] fn asinh (self) -> Self { libm :: asinhf (self) } # [inline] fn acosh (self) -> Self { libm :: acoshf (self) } # [inline] fn atanh (self) -> Self { libm :: atanhf (self) } } # [cfg (all (not (feature = "std") , feature = "libm"))] impl Float for f64 { float_impl_libm ! (f64 integer_decode_f64) ; # [inline] # [allow (deprecated)] fn abs_sub (self , other : Self) -> Self { libm :: fdim (self , other) } # [inline] fn floor (self) -> Self { libm :: floor (self) } # [inline] fn ceil (self) -> Self { libm :: ceil (self) } # [inline] fn round (self) -> Self { libm :: round (self) } # [inline] fn trunc (self) -> Self { libm :: trunc (self) } # [inline] fn abs (self) -> Self { libm :: fabs (self) } # [inline] fn mul_add (self , a : Self , b : Self) -> Self { libm :: fma (self , a , b) } # [inline] fn powf (self , n : Self) -> Self { libm :: pow (self , n) } # [inline] fn sqrt (self) -> Self { libm :: sqrt (self) } # [inline] fn exp (self) -> Self { libm :: exp (self) } # [inline] fn exp2 (self) -> Self { libm :: exp2 (self) } # [inline] fn ln (self) -> Self { libm :: log (self) } # [inline] fn log2 (self) -> Self { libm :: log2 (self) } # [inline] fn log10 (self) -> Self { libm :: log10 (self) } # [inline] fn cbrt (self) -> Self { libm :: cbrt (self) } # [inline] fn hypot (self , other : Self) -> Self { libm :: hypot (self , other) } # [inline] fn sin (self) -> Self { libm :: sin (self) } # [inline] fn cos (self) -> Self { libm :: cos (self) } # [inline] fn tan (self) -> Self { libm :: tan (self) } # [inline] fn asin (self) -> Self { libm :: asin (self) } # [inline] fn acos (self) -> Self { libm :: acos (self) } # [inline] fn atan (self) -> Self { libm :: atan (self) } # [inline] fn atan2 (self , other : Self) -> Self { libm :: atan2 (self , other) } # [inline] fn sin_cos (self) -> (Self , Self) { libm :: sincos (self) } # [inline] fn exp_m1 (self) -> Self { libm :: expm1 (self) } # [inline] fn ln_1p (self) -> Self { libm :: log1p (self) } # [inline] fn sinh (self) -> Self { libm :: sinh (self) } # [inline] fn cosh (self) -> Self { libm :: cosh (self) } # [inline] fn tanh (self) -> Self { libm :: tanh (self) } # [inline] fn asinh (self) -> Self { libm :: asinh (self) } # [inline] fn acosh (self) -> Self { libm :: acosh (self) } # [inline] fn atanh (self) -> Self { libm :: atanh (self) } } macro_rules ! float_const_impl { ($ (# [$ doc : meta] $ constant : ident ,) +) => (# [allow (non_snake_case)] pub trait FloatConst { $ (# [$ doc] fn $ constant () -> Self ;) + # [doc = "Return the full circle constant ``."] # [inline] fn TAU () -> Self where Self : Sized + Add < Self , Output = Self > { Self :: PI () + Self :: PI () } } float_const_impl ! { @ float f32 , $ ($ constant ,) + } float_const_impl ! { @ float f64 , $ ($ constant ,) + }) ; (@ float $ T : ident , $ ($ constant : ident ,) +) => (impl FloatConst for $ T { constant ! { $ ($ constant () -> $ T :: consts ::$ constant ;) + TAU () -> 6.28318530717958647692528676655900577 ; } }) ; } float_const_impl ! { # [doc = "Return Eulers number."] E , # [doc = "Return `1.0 / `."] FRAC_1_PI , # [doc = "Return `1.0 / sqrt(2.0)`."] FRAC_1_SQRT_2 , # [doc = "Return `2.0 / `."] FRAC_2_PI , # [doc = "Return `2.0 / sqrt()`."] FRAC_2_SQRT_PI , # [doc = "Return ` / 2.0`."] FRAC_PI_2 , # [doc = "Return ` / 3.0`."] FRAC_PI_3 , # [doc = "Return ` / 4.0`."] FRAC_PI_4 , # [doc = "Return ` / 6.0`."] FRAC_PI_6 , # [doc = "Return ` / 8.0`."] FRAC_PI_8 , # [doc = "Return `ln(10.0)`."] LN_10 , # [doc = "Return `ln(2.0)`."] LN_2 , # [doc = "Return `log10(e)`."] LOG10_E , # [doc = "Return `log2(e)`."] LOG2_E , # [doc = "Return Archimedes constant ``."] PI , # [doc = "Return `sqrt(2.0)`."] SQRT_2 , } # [cfg (test)] mod tests { use core :: f64 :: consts ; const DEG_RAD_PAIRS : [(f64 , f64) ; 7] = [(0.0 , 0.) , (22.5 , consts :: FRAC_PI_8) , (30.0 , consts :: FRAC_PI_6) , (45.0 , consts :: FRAC_PI_4) , (60.0 , consts :: FRAC_PI_3) , (90.0 , consts :: FRAC_PI_2) , (180.0 , consts :: PI) ,] ; # [test] fn convert_deg_rad () { use float :: FloatCore ; for & (deg , rad) in & DEG_RAD_PAIRS { assert ! ((FloatCore :: to_degrees (rad) - deg) . abs () < 1e-6) ; assert ! ((FloatCore :: to_radians (deg) - rad) . abs () < 1e-6) ; let (deg , rad) = (deg as f32 , rad as f32) ; assert ! ((FloatCore :: to_degrees (rad) - deg) . abs () < 1e-5) ; assert ! ((FloatCore :: to_radians (deg) - rad) . abs () < 1e-5) ; } } # [cfg (any (feature = "std" , feature = "libm"))] # [test] fn convert_deg_rad_std () { for & (deg , rad) in & DEG_RAD_PAIRS { use Float ; assert ! ((Float :: to_degrees (rad) - deg) . abs () < 1e-6) ; assert ! ((Float :: to_radians (deg) - rad) . abs () < 1e-6) ; let (deg , rad) = (deg as f32 , rad as f32) ; assert ! ((Float :: to_degrees (rad) - deg) . abs () < 1e-5) ; assert ! ((Float :: to_radians (deg) - rad) . abs () < 1e-5) ; } } # [test] # [cfg (not (feature = "std"))] fn to_degrees_rounding () { use float :: FloatCore ; assert_eq ! (FloatCore :: to_degrees (1_f32) , 57.2957795130823208767981548141051703) ; } } } pub mod identities { use core :: num :: Wrapping ; use core :: ops :: { Add , Mul } ; # [doc = " Defines an additive identity element for `Self`."] # [doc = ""] # [doc = " # Laws"] # [doc = ""] # [doc = " ```{.text}"] # [doc = " a + 0 = a        a  Self"] # [doc = " 0 + a = a        a  Self"] # [doc = " ```"] pub trait Zero : Sized + Add < Self , Output = Self > { # [doc = " Returns the additive identity element of `Self`, `0`."] # [doc = " # Purity"] # [doc = ""] # [doc = " This function should return the same result at all times regardless of"] # [doc = " external mutable state, for example values stored in TLS or in"] # [doc = " `static mut`s."] fn zero () -> Self ; # [doc = " Sets `self` to the additive identity element of `Self`, `0`."] fn set_zero (& mut self) { * self = Zero :: zero () ; } # [doc = " Returns `true` if `self` is equal to the additive identity."] fn is_zero (& self) -> bool ; } macro_rules ! zero_impl { ($ t : ty , $ v : expr) => { impl Zero for $ t { # [inline] fn zero () -> $ t { $ v } # [inline] fn is_zero (& self) -> bool { * self == $ v } } } ; } zero_impl ! (usize , 0) ; zero_impl ! (u8 , 0) ; zero_impl ! (u16 , 0) ; zero_impl ! (u32 , 0) ; zero_impl ! (u64 , 0) ; # [cfg (has_i128)] zero_impl ! (u128 , 0) ; zero_impl ! (isize , 0) ; zero_impl ! (i8 , 0) ; zero_impl ! (i16 , 0) ; zero_impl ! (i32 , 0) ; zero_impl ! (i64 , 0) ; # [cfg (has_i128)] zero_impl ! (i128 , 0) ; zero_impl ! (f32 , 0.0) ; zero_impl ! (f64 , 0.0) ; impl < T : Zero > Zero for Wrapping < T > where Wrapping < T > : Add < Output = Wrapping < T > > , { fn is_zero (& self) -> bool { self . 0 . is_zero () } fn set_zero (& mut self) { self . 0 . set_zero () ; } fn zero () -> Self { Wrapping (T :: zero ()) } } # [doc = " Defines a multiplicative identity element for `Self`."] # [doc = ""] # [doc = " # Laws"] # [doc = ""] # [doc = " ```{.text}"] # [doc = " a * 1 = a        a  Self"] # [doc = " 1 * a = a        a  Self"] # [doc = " ```"] pub trait One : Sized + Mul < Self , Output = Self > { # [doc = " Returns the multiplicative identity element of `Self`, `1`."] # [doc = ""] # [doc = " # Purity"] # [doc = ""] # [doc = " This function should return the same result at all times regardless of"] # [doc = " external mutable state, for example values stored in TLS or in"] # [doc = " `static mut`s."] fn one () -> Self ; # [doc = " Sets `self` to the multiplicative identity element of `Self`, `1`."] fn set_one (& mut self) { * self = One :: one () ; } # [doc = " Returns `true` if `self` is equal to the multiplicative identity."] # [doc = ""] # [doc = " For performance reasons, it's best to implement this manually."] # [doc = " After a semver bump, this method will be required, and the"] # [doc = " `where Self: PartialEq` bound will be removed."] # [inline] fn is_one (& self) -> bool where Self : PartialEq , { * self == Self :: one () } } macro_rules ! one_impl { ($ t : ty , $ v : expr) => { impl One for $ t { # [inline] fn one () -> $ t { $ v } # [inline] fn is_one (& self) -> bool { * self == $ v } } } ; } one_impl ! (usize , 1) ; one_impl ! (u8 , 1) ; one_impl ! (u16 , 1) ; one_impl ! (u32 , 1) ; one_impl ! (u64 , 1) ; # [cfg (has_i128)] one_impl ! (u128 , 1) ; one_impl ! (isize , 1) ; one_impl ! (i8 , 1) ; one_impl ! (i16 , 1) ; one_impl ! (i32 , 1) ; one_impl ! (i64 , 1) ; # [cfg (has_i128)] one_impl ! (i128 , 1) ; one_impl ! (f32 , 1.0) ; one_impl ! (f64 , 1.0) ; impl < T : One > One for Wrapping < T > where Wrapping < T > : Mul < Output = Wrapping < T > > , { fn set_one (& mut self) { self . 0 . set_one () ; } fn one () -> Self { Wrapping (T :: one ()) } } # [doc = " Returns the additive identity, `0`."] # [inline (always)] pub fn zero < T : Zero > () -> T { Zero :: zero () } # [doc = " Returns the multiplicative identity, `1`."] # [inline (always)] pub fn one < T : One > () -> T { One :: one () } # [test] fn wrapping_identities () { macro_rules ! test_wrapping_identities { ($ ($ t : ty) +) => { $ (assert_eq ! (zero ::<$ t > () , zero ::< Wrapping <$ t >> () . 0) ; assert_eq ! (one ::<$ t > () , one ::< Wrapping <$ t >> () . 0) ; assert_eq ! ((0 as $ t) . is_zero () , Wrapping (0 as $ t) . is_zero ()) ; assert_eq ! ((1 as $ t) . is_zero () , Wrapping (1 as $ t) . is_zero ()) ;) + } ; } test_wrapping_identities ! (isize i8 i16 i32 i64 usize u8 u16 u32 u64) ; } # [test] fn wrapping_is_zero () { fn require_zero < T : Zero > (_ : & T) { } require_zero (& Wrapping (42)) ; } # [test] fn wrapping_is_one () { fn require_one < T : One > (_ : & T) { } require_one (& Wrapping (42)) ; } } pub mod int { use core :: ops :: { BitAnd , BitOr , BitXor , Not , Shl , Shr } ; use bounds :: Bounded ; use ops :: checked :: * ; use ops :: saturating :: Saturating ; use { Num , NumCast } ; # [doc = " Generic trait for primitive integers."] # [doc = ""] # [doc = " The `PrimInt` trait is an abstraction over the builtin primitive integer types (e.g., `u8`,"] # [doc = " `u32`, `isize`, `i128`, ...). It inherits the basic numeric traits and extends them with"] # [doc = " bitwise operators and non-wrapping arithmetic."] # [doc = ""] # [doc = " The trait explicitly inherits `Copy`, `Eq`, `Ord`, and `Sized`. The intention is that all"] # [doc = " types implementing this trait behave like primitive types that are passed by value by default"] # [doc = " and behave like builtin integers. Furthermore, the types are expected to expose the integer"] # [doc = " value in binary representation and support bitwise operators. The standard bitwise operations"] # [doc = " (e.g., bitwise-and, bitwise-or, right-shift, left-shift) are inherited and the trait extends"] # [doc = " these with introspective queries (e.g., `PrimInt::count_ones()`, `PrimInt::leading_zeros()`),"] # [doc = " bitwise combinators (e.g., `PrimInt::rotate_left()`), and endianness converters (e.g.,"] # [doc = " `PrimInt::to_be()`)."] # [doc = ""] # [doc = " All `PrimInt` types are expected to be fixed-width binary integers. The width can be queried"] # [doc = " via `T::zero().count_zeros()`. The trait currently lacks a way to query the width at"] # [doc = " compile-time."] # [doc = ""] # [doc = " While a default implementation for all builtin primitive integers is provided, the trait is in"] # [doc = " no way restricted to these. Other integer types that fulfil the requirements are free to"] # [doc = " implement the trait was well."] # [doc = ""] # [doc = " This trait and many of the method names originate in the unstable `core::num::Int` trait from"] # [doc = " the rust standard library. The original trait was never stabilized and thus removed from the"] # [doc = " standard library."] pub trait PrimInt : Sized + Copy + Num + NumCast + Bounded + PartialOrd + Ord + Eq + Not < Output = Self > + BitAnd < Output = Self > + BitOr < Output = Self > + BitXor < Output = Self > + Shl < usize , Output = Self > + Shr < usize , Output = Self > + CheckedAdd < Output = Self > + CheckedSub < Output = Self > + CheckedMul < Output = Self > + CheckedDiv < Output = Self > + Saturating { # [doc = " Returns the number of ones in the binary representation of `self`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0b01001100u8;"] # [doc = ""] # [doc = " assert_eq!(n.count_ones(), 3);"] # [doc = " ```"] fn count_ones (self) -> u32 ; # [doc = " Returns the number of zeros in the binary representation of `self`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0b01001100u8;"] # [doc = ""] # [doc = " assert_eq!(n.count_zeros(), 5);"] # [doc = " ```"] fn count_zeros (self) -> u32 ; # [doc = " Returns the number of leading zeros in the binary representation"] # [doc = " of `self`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0b0101000u16;"] # [doc = ""] # [doc = " assert_eq!(n.leading_zeros(), 10);"] # [doc = " ```"] fn leading_zeros (self) -> u32 ; # [doc = " Returns the number of trailing zeros in the binary representation"] # [doc = " of `self`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0b0101000u16;"] # [doc = ""] # [doc = " assert_eq!(n.trailing_zeros(), 3);"] # [doc = " ```"] fn trailing_zeros (self) -> u32 ; # [doc = " Shifts the bits to the left by a specified amount amount, `n`, wrapping"] # [doc = " the truncated bits to the end of the resulting integer."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = " let m = 0x3456789ABCDEF012u64;"] # [doc = ""] # [doc = " assert_eq!(n.rotate_left(12), m);"] # [doc = " ```"] fn rotate_left (self , n : u32) -> Self ; # [doc = " Shifts the bits to the right by a specified amount amount, `n`, wrapping"] # [doc = " the truncated bits to the beginning of the resulting integer."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = " let m = 0xDEF0123456789ABCu64;"] # [doc = ""] # [doc = " assert_eq!(n.rotate_right(12), m);"] # [doc = " ```"] fn rotate_right (self , n : u32) -> Self ; # [doc = " Shifts the bits to the left by a specified amount amount, `n`, filling"] # [doc = " zeros in the least significant bits."] # [doc = ""] # [doc = " This is bitwise equivalent to signed `Shl`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = " let m = 0x3456789ABCDEF000u64;"] # [doc = ""] # [doc = " assert_eq!(n.signed_shl(12), m);"] # [doc = " ```"] fn signed_shl (self , n : u32) -> Self ; # [doc = " Shifts the bits to the right by a specified amount amount, `n`, copying"] # [doc = " the \"sign bit\" in the most significant bits even for unsigned types."] # [doc = ""] # [doc = " This is bitwise equivalent to signed `Shr`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0xFEDCBA9876543210u64;"] # [doc = " let m = 0xFFFFEDCBA9876543u64;"] # [doc = ""] # [doc = " assert_eq!(n.signed_shr(12), m);"] # [doc = " ```"] fn signed_shr (self , n : u32) -> Self ; # [doc = " Shifts the bits to the left by a specified amount amount, `n`, filling"] # [doc = " zeros in the least significant bits."] # [doc = ""] # [doc = " This is bitwise equivalent to unsigned `Shl`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFi64;"] # [doc = " let m = 0x3456789ABCDEF000i64;"] # [doc = ""] # [doc = " assert_eq!(n.unsigned_shl(12), m);"] # [doc = " ```"] fn unsigned_shl (self , n : u32) -> Self ; # [doc = " Shifts the bits to the right by a specified amount amount, `n`, filling"] # [doc = " zeros in the most significant bits."] # [doc = ""] # [doc = " This is bitwise equivalent to unsigned `Shr`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = -8i8; // 0b11111000"] # [doc = " let m = 62i8; // 0b00111110"] # [doc = ""] # [doc = " assert_eq!(n.unsigned_shr(2), m);"] # [doc = " ```"] fn unsigned_shr (self , n : u32) -> Self ; # [doc = " Reverses the byte order of the integer."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = " let m = 0xEFCDAB8967452301u64;"] # [doc = ""] # [doc = " assert_eq!(n.swap_bytes(), m);"] # [doc = " ```"] fn swap_bytes (self) -> Self ; # [doc = " Convert an integer from big endian to the target's endianness."] # [doc = ""] # [doc = " On big endian this is a no-op. On little endian the bytes are swapped."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = ""] # [doc = " if cfg!(target_endian = \"big\") {"] # [doc = "     assert_eq!(u64::from_be(n), n)"] # [doc = " } else {"] # [doc = "     assert_eq!(u64::from_be(n), n.swap_bytes())"] # [doc = " }"] # [doc = " ```"] fn from_be (x : Self) -> Self ; # [doc = " Convert an integer from little endian to the target's endianness."] # [doc = ""] # [doc = " On little endian this is a no-op. On big endian the bytes are swapped."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = ""] # [doc = " if cfg!(target_endian = \"little\") {"] # [doc = "     assert_eq!(u64::from_le(n), n)"] # [doc = " } else {"] # [doc = "     assert_eq!(u64::from_le(n), n.swap_bytes())"] # [doc = " }"] # [doc = " ```"] fn from_le (x : Self) -> Self ; # [doc = " Convert `self` to big endian from the target's endianness."] # [doc = ""] # [doc = " On big endian this is a no-op. On little endian the bytes are swapped."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = ""] # [doc = " if cfg!(target_endian = \"big\") {"] # [doc = "     assert_eq!(n.to_be(), n)"] # [doc = " } else {"] # [doc = "     assert_eq!(n.to_be(), n.swap_bytes())"] # [doc = " }"] # [doc = " ```"] fn to_be (self) -> Self ; # [doc = " Convert `self` to little endian from the target's endianness."] # [doc = ""] # [doc = " On little endian this is a no-op. On big endian the bytes are swapped."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " let n = 0x0123456789ABCDEFu64;"] # [doc = ""] # [doc = " if cfg!(target_endian = \"little\") {"] # [doc = "     assert_eq!(n.to_le(), n)"] # [doc = " } else {"] # [doc = "     assert_eq!(n.to_le(), n.swap_bytes())"] # [doc = " }"] # [doc = " ```"] fn to_le (self) -> Self ; # [doc = " Raises self to the power of `exp`, using exponentiation by squaring."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::PrimInt;"] # [doc = ""] # [doc = " assert_eq!(2i32.pow(4), 16);"] # [doc = " ```"] fn pow (self , exp : u32) -> Self ; } macro_rules ! prim_int_impl { ($ T : ty , $ S : ty , $ U : ty) => { impl PrimInt for $ T { # [inline] fn count_ones (self) -> u32 { <$ T >:: count_ones (self) } # [inline] fn count_zeros (self) -> u32 { <$ T >:: count_zeros (self) } # [inline] fn leading_zeros (self) -> u32 { <$ T >:: leading_zeros (self) } # [inline] fn trailing_zeros (self) -> u32 { <$ T >:: trailing_zeros (self) } # [inline] fn rotate_left (self , n : u32) -> Self { <$ T >:: rotate_left (self , n) } # [inline] fn rotate_right (self , n : u32) -> Self { <$ T >:: rotate_right (self , n) } # [inline] fn signed_shl (self , n : u32) -> Self { ((self as $ S) << n) as $ T } # [inline] fn signed_shr (self , n : u32) -> Self { ((self as $ S) >> n) as $ T } # [inline] fn unsigned_shl (self , n : u32) -> Self { ((self as $ U) << n) as $ T } # [inline] fn unsigned_shr (self , n : u32) -> Self { ((self as $ U) >> n) as $ T } # [inline] fn swap_bytes (self) -> Self { <$ T >:: swap_bytes (self) } # [inline] fn from_be (x : Self) -> Self { <$ T >:: from_be (x) } # [inline] fn from_le (x : Self) -> Self { <$ T >:: from_le (x) } # [inline] fn to_be (self) -> Self { <$ T >:: to_be (self) } # [inline] fn to_le (self) -> Self { <$ T >:: to_le (self) } # [inline] fn pow (self , exp : u32) -> Self { <$ T >:: pow (self , exp) } } } ; } prim_int_impl ! (u8 , i8 , u8) ; prim_int_impl ! (u16 , i16 , u16) ; prim_int_impl ! (u32 , i32 , u32) ; prim_int_impl ! (u64 , i64 , u64) ; # [cfg (has_i128)] prim_int_impl ! (u128 , i128 , u128) ; prim_int_impl ! (usize , isize , usize) ; prim_int_impl ! (i8 , i8 , u8) ; prim_int_impl ! (i16 , i16 , u16) ; prim_int_impl ! (i32 , i32 , u32) ; prim_int_impl ! (i64 , i64 , u64) ; # [cfg (has_i128)] prim_int_impl ! (i128 , i128 , u128) ; prim_int_impl ! (isize , isize , usize) ; } pub mod ops { pub mod checked { use core :: ops :: { Add , Div , Mul , Rem , Shl , Shr , Sub } ; # [doc = " Performs addition that returns `None` instead of wrapping around on"] # [doc = " overflow."] pub trait CheckedAdd : Sized + Add < Self , Output = Self > { # [doc = " Adds two numbers, checking for overflow. If overflow happens, `None` is"] # [doc = " returned."] fn checked_add (& self , v : & Self) -> Option < Self > ; } macro_rules ! checked_impl { ($ trait_name : ident , $ method : ident , $ t : ty) => { impl $ trait_name for $ t { # [inline] fn $ method (& self , v : &$ t) -> Option <$ t > { <$ t >::$ method (* self , * v) } } } ; } checked_impl ! (CheckedAdd , checked_add , u8) ; checked_impl ! (CheckedAdd , checked_add , u16) ; checked_impl ! (CheckedAdd , checked_add , u32) ; checked_impl ! (CheckedAdd , checked_add , u64) ; checked_impl ! (CheckedAdd , checked_add , usize) ; # [cfg (has_i128)] checked_impl ! (CheckedAdd , checked_add , u128) ; checked_impl ! (CheckedAdd , checked_add , i8) ; checked_impl ! (CheckedAdd , checked_add , i16) ; checked_impl ! (CheckedAdd , checked_add , i32) ; checked_impl ! (CheckedAdd , checked_add , i64) ; checked_impl ! (CheckedAdd , checked_add , isize) ; # [cfg (has_i128)] checked_impl ! (CheckedAdd , checked_add , i128) ; # [doc = " Performs subtraction that returns `None` instead of wrapping around on underflow."] pub trait CheckedSub : Sized + Sub < Self , Output = Self > { # [doc = " Subtracts two numbers, checking for underflow. If underflow happens,"] # [doc = " `None` is returned."] fn checked_sub (& self , v : & Self) -> Option < Self > ; } checked_impl ! (CheckedSub , checked_sub , u8) ; checked_impl ! (CheckedSub , checked_sub , u16) ; checked_impl ! (CheckedSub , checked_sub , u32) ; checked_impl ! (CheckedSub , checked_sub , u64) ; checked_impl ! (CheckedSub , checked_sub , usize) ; # [cfg (has_i128)] checked_impl ! (CheckedSub , checked_sub , u128) ; checked_impl ! (CheckedSub , checked_sub , i8) ; checked_impl ! (CheckedSub , checked_sub , i16) ; checked_impl ! (CheckedSub , checked_sub , i32) ; checked_impl ! (CheckedSub , checked_sub , i64) ; checked_impl ! (CheckedSub , checked_sub , isize) ; # [cfg (has_i128)] checked_impl ! (CheckedSub , checked_sub , i128) ; # [doc = " Performs multiplication that returns `None` instead of wrapping around on underflow or"] # [doc = " overflow."] pub trait CheckedMul : Sized + Mul < Self , Output = Self > { # [doc = " Multiplies two numbers, checking for underflow or overflow. If underflow"] # [doc = " or overflow happens, `None` is returned."] fn checked_mul (& self , v : & Self) -> Option < Self > ; } checked_impl ! (CheckedMul , checked_mul , u8) ; checked_impl ! (CheckedMul , checked_mul , u16) ; checked_impl ! (CheckedMul , checked_mul , u32) ; checked_impl ! (CheckedMul , checked_mul , u64) ; checked_impl ! (CheckedMul , checked_mul , usize) ; # [cfg (has_i128)] checked_impl ! (CheckedMul , checked_mul , u128) ; checked_impl ! (CheckedMul , checked_mul , i8) ; checked_impl ! (CheckedMul , checked_mul , i16) ; checked_impl ! (CheckedMul , checked_mul , i32) ; checked_impl ! (CheckedMul , checked_mul , i64) ; checked_impl ! (CheckedMul , checked_mul , isize) ; # [cfg (has_i128)] checked_impl ! (CheckedMul , checked_mul , i128) ; # [doc = " Performs division that returns `None` instead of panicking on division by zero and instead of"] # [doc = " wrapping around on underflow and overflow."] pub trait CheckedDiv : Sized + Div < Self , Output = Self > { # [doc = " Divides two numbers, checking for underflow, overflow and division by"] # [doc = " zero. If any of that happens, `None` is returned."] fn checked_div (& self , v : & Self) -> Option < Self > ; } checked_impl ! (CheckedDiv , checked_div , u8) ; checked_impl ! (CheckedDiv , checked_div , u16) ; checked_impl ! (CheckedDiv , checked_div , u32) ; checked_impl ! (CheckedDiv , checked_div , u64) ; checked_impl ! (CheckedDiv , checked_div , usize) ; # [cfg (has_i128)] checked_impl ! (CheckedDiv , checked_div , u128) ; checked_impl ! (CheckedDiv , checked_div , i8) ; checked_impl ! (CheckedDiv , checked_div , i16) ; checked_impl ! (CheckedDiv , checked_div , i32) ; checked_impl ! (CheckedDiv , checked_div , i64) ; checked_impl ! (CheckedDiv , checked_div , isize) ; # [cfg (has_i128)] checked_impl ! (CheckedDiv , checked_div , i128) ; # [doc = " Performs an integral remainder that returns `None` instead of panicking on division by zero and"] # [doc = " instead of wrapping around on underflow and overflow."] pub trait CheckedRem : Sized + Rem < Self , Output = Self > { # [doc = " Finds the remainder of dividing two numbers, checking for underflow, overflow and division"] # [doc = " by zero. If any of that happens, `None` is returned."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::CheckedRem;"] # [doc = " use std::i32::MIN;"] # [doc = ""] # [doc = " assert_eq!(CheckedRem::checked_rem(&10, &7), Some(3));"] # [doc = " assert_eq!(CheckedRem::checked_rem(&10, &-7), Some(3));"] # [doc = " assert_eq!(CheckedRem::checked_rem(&-10, &7), Some(-3));"] # [doc = " assert_eq!(CheckedRem::checked_rem(&-10, &-7), Some(-3));"] # [doc = ""] # [doc = " assert_eq!(CheckedRem::checked_rem(&10, &0), None);"] # [doc = ""] # [doc = " assert_eq!(CheckedRem::checked_rem(&MIN, &1), Some(0));"] # [doc = " assert_eq!(CheckedRem::checked_rem(&MIN, &-1), None);"] # [doc = " ```"] fn checked_rem (& self , v : & Self) -> Option < Self > ; } checked_impl ! (CheckedRem , checked_rem , u8) ; checked_impl ! (CheckedRem , checked_rem , u16) ; checked_impl ! (CheckedRem , checked_rem , u32) ; checked_impl ! (CheckedRem , checked_rem , u64) ; checked_impl ! (CheckedRem , checked_rem , usize) ; # [cfg (has_i128)] checked_impl ! (CheckedRem , checked_rem , u128) ; checked_impl ! (CheckedRem , checked_rem , i8) ; checked_impl ! (CheckedRem , checked_rem , i16) ; checked_impl ! (CheckedRem , checked_rem , i32) ; checked_impl ! (CheckedRem , checked_rem , i64) ; checked_impl ! (CheckedRem , checked_rem , isize) ; # [cfg (has_i128)] checked_impl ! (CheckedRem , checked_rem , i128) ; macro_rules ! checked_impl_unary { ($ trait_name : ident , $ method : ident , $ t : ty) => { impl $ trait_name for $ t { # [inline] fn $ method (& self) -> Option <$ t > { <$ t >::$ method (* self) } } } ; } # [doc = " Performs negation that returns `None` if the result can't be represented."] pub trait CheckedNeg : Sized { # [doc = " Negates a number, returning `None` for results that can't be represented, like signed `MIN`"] # [doc = " values that can't be positive, or non-zero unsigned values that can't be negative."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::CheckedNeg;"] # [doc = " use std::i32::MIN;"] # [doc = ""] # [doc = " assert_eq!(CheckedNeg::checked_neg(&1_i32), Some(-1));"] # [doc = " assert_eq!(CheckedNeg::checked_neg(&-1_i32), Some(1));"] # [doc = " assert_eq!(CheckedNeg::checked_neg(&MIN), None);"] # [doc = ""] # [doc = " assert_eq!(CheckedNeg::checked_neg(&0_u32), Some(0));"] # [doc = " assert_eq!(CheckedNeg::checked_neg(&1_u32), None);"] # [doc = " ```"] fn checked_neg (& self) -> Option < Self > ; } checked_impl_unary ! (CheckedNeg , checked_neg , u8) ; checked_impl_unary ! (CheckedNeg , checked_neg , u16) ; checked_impl_unary ! (CheckedNeg , checked_neg , u32) ; checked_impl_unary ! (CheckedNeg , checked_neg , u64) ; checked_impl_unary ! (CheckedNeg , checked_neg , usize) ; # [cfg (has_i128)] checked_impl_unary ! (CheckedNeg , checked_neg , u128) ; checked_impl_unary ! (CheckedNeg , checked_neg , i8) ; checked_impl_unary ! (CheckedNeg , checked_neg , i16) ; checked_impl_unary ! (CheckedNeg , checked_neg , i32) ; checked_impl_unary ! (CheckedNeg , checked_neg , i64) ; checked_impl_unary ! (CheckedNeg , checked_neg , isize) ; # [cfg (has_i128)] checked_impl_unary ! (CheckedNeg , checked_neg , i128) ; # [doc = " Performs a left shift that returns `None` on shifts larger than"] # [doc = " the type width."] pub trait CheckedShl : Sized + Shl < u32 , Output = Self > { # [doc = " Checked shift left. Computes `self << rhs`, returning `None`"] # [doc = " if `rhs` is larger than or equal to the number of bits in `self`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::CheckedShl;"] # [doc = ""] # [doc = " let x: u16 = 0x0001;"] # [doc = ""] # [doc = " assert_eq!(CheckedShl::checked_shl(&x, 0),  Some(0x0001));"] # [doc = " assert_eq!(CheckedShl::checked_shl(&x, 1),  Some(0x0002));"] # [doc = " assert_eq!(CheckedShl::checked_shl(&x, 15), Some(0x8000));"] # [doc = " assert_eq!(CheckedShl::checked_shl(&x, 16), None);"] # [doc = " ```"] fn checked_shl (& self , rhs : u32) -> Option < Self > ; } macro_rules ! checked_shift_impl { ($ trait_name : ident , $ method : ident , $ t : ty) => { impl $ trait_name for $ t { # [inline] fn $ method (& self , rhs : u32) -> Option <$ t > { <$ t >::$ method (* self , rhs) } } } ; } checked_shift_impl ! (CheckedShl , checked_shl , u8) ; checked_shift_impl ! (CheckedShl , checked_shl , u16) ; checked_shift_impl ! (CheckedShl , checked_shl , u32) ; checked_shift_impl ! (CheckedShl , checked_shl , u64) ; checked_shift_impl ! (CheckedShl , checked_shl , usize) ; # [cfg (has_i128)] checked_shift_impl ! (CheckedShl , checked_shl , u128) ; checked_shift_impl ! (CheckedShl , checked_shl , i8) ; checked_shift_impl ! (CheckedShl , checked_shl , i16) ; checked_shift_impl ! (CheckedShl , checked_shl , i32) ; checked_shift_impl ! (CheckedShl , checked_shl , i64) ; checked_shift_impl ! (CheckedShl , checked_shl , isize) ; # [cfg (has_i128)] checked_shift_impl ! (CheckedShl , checked_shl , i128) ; # [doc = " Performs a right shift that returns `None` on shifts larger than"] # [doc = " the type width."] pub trait CheckedShr : Sized + Shr < u32 , Output = Self > { # [doc = " Checked shift right. Computes `self >> rhs`, returning `None`"] # [doc = " if `rhs` is larger than or equal to the number of bits in `self`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::CheckedShr;"] # [doc = ""] # [doc = " let x: u16 = 0x8000;"] # [doc = ""] # [doc = " assert_eq!(CheckedShr::checked_shr(&x, 0),  Some(0x8000));"] # [doc = " assert_eq!(CheckedShr::checked_shr(&x, 1),  Some(0x4000));"] # [doc = " assert_eq!(CheckedShr::checked_shr(&x, 15), Some(0x0001));"] # [doc = " assert_eq!(CheckedShr::checked_shr(&x, 16), None);"] # [doc = " ```"] fn checked_shr (& self , rhs : u32) -> Option < Self > ; } checked_shift_impl ! (CheckedShr , checked_shr , u8) ; checked_shift_impl ! (CheckedShr , checked_shr , u16) ; checked_shift_impl ! (CheckedShr , checked_shr , u32) ; checked_shift_impl ! (CheckedShr , checked_shr , u64) ; checked_shift_impl ! (CheckedShr , checked_shr , usize) ; # [cfg (has_i128)] checked_shift_impl ! (CheckedShr , checked_shr , u128) ; checked_shift_impl ! (CheckedShr , checked_shr , i8) ; checked_shift_impl ! (CheckedShr , checked_shr , i16) ; checked_shift_impl ! (CheckedShr , checked_shr , i32) ; checked_shift_impl ! (CheckedShr , checked_shr , i64) ; checked_shift_impl ! (CheckedShr , checked_shr , isize) ; # [cfg (has_i128)] checked_shift_impl ! (CheckedShr , checked_shr , i128) ; } pub mod inv { # [doc = " Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value."] pub trait Inv { # [doc = " The result after applying the operator."] type Output ; # [doc = " Returns the multiplicative inverse of `self`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use std::f64::INFINITY;"] # [doc = " use num_traits::Inv;"] # [doc = ""] # [doc = " assert_eq!(7.0.inv() * 7.0, 1.0);"] # [doc = " assert_eq!((-0.0).inv(), -INFINITY);"] # [doc = " ```"] fn inv (self) -> Self :: Output ; } impl Inv for f32 { type Output = f32 ; # [inline] fn inv (self) -> f32 { 1.0 / self } } impl Inv for f64 { type Output = f64 ; # [inline] fn inv (self) -> f64 { 1.0 / self } } impl < 'a > Inv for & 'a f32 { type Output = f32 ; # [inline] fn inv (self) -> f32 { 1.0 / * self } } impl < 'a > Inv for & 'a f64 { type Output = f64 ; # [inline] fn inv (self) -> f64 { 1.0 / * self } } } pub mod mul_add { # [doc = " Fused multiply-add. Computes `(self * a) + b` with only one rounding"] # [doc = " error, yielding a more accurate result than an unfused multiply-add."] # [doc = ""] # [doc = " Using `mul_add` can be more performant than an unfused multiply-add if"] # [doc = " the target architecture has a dedicated `fma` CPU instruction."] # [doc = ""] # [doc = " Note that `A` and `B` are `Self` by default, but this is not mandatory."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use std::f32;"] # [doc = ""] # [doc = " let m = 10.0_f32;"] # [doc = " let x = 4.0_f32;"] # [doc = " let b = 60.0_f32;"] # [doc = ""] # [doc = " // 100.0"] # [doc = " let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference <= 100.0 * f32::EPSILON);"] # [doc = " ```"] pub trait MulAdd < A = Self , B = Self > { # [doc = " The resulting type after applying the fused multiply-add."] type Output ; # [doc = " Performs the fused multiply-add operation."] fn mul_add (self , a : A , b : B) -> Self :: Output ; } # [doc = " The fused multiply-add assignment operation."] pub trait MulAddAssign < A = Self , B = Self > { # [doc = " Performs the fused multiply-add operation."] fn mul_add_assign (& mut self , a : A , b : B) ; } # [cfg (any (feature = "std" , feature = "libm"))] impl MulAdd < f32 , f32 > for f32 { type Output = Self ; # [inline] fn mul_add (self , a : Self , b : Self) -> Self :: Output { < Self as :: Float > :: mul_add (self , a , b) } } # [cfg (any (feature = "std" , feature = "libm"))] impl MulAdd < f64 , f64 > for f64 { type Output = Self ; # [inline] fn mul_add (self , a : Self , b : Self) -> Self :: Output { < Self as :: Float > :: mul_add (self , a , b) } } macro_rules ! mul_add_impl { ($ trait_name : ident for $ ($ t : ty) *) => { $ (impl $ trait_name for $ t { type Output = Self ; # [inline] fn mul_add (self , a : Self , b : Self) -> Self :: Output { (self * a) + b } }) * } } mul_add_impl ! (MulAdd for isize usize i8 u8 i16 u16 i32 u32 i64 u64) ; # [cfg (has_i128)] mul_add_impl ! (MulAdd for i128 u128) ; # [cfg (any (feature = "std" , feature = "libm"))] impl MulAddAssign < f32 , f32 > for f32 { # [inline] fn mul_add_assign (& mut self , a : Self , b : Self) { * self = < Self as :: Float > :: mul_add (* self , a , b) } } # [cfg (any (feature = "std" , feature = "libm"))] impl MulAddAssign < f64 , f64 > for f64 { # [inline] fn mul_add_assign (& mut self , a : Self , b : Self) { * self = < Self as :: Float > :: mul_add (* self , a , b) } } macro_rules ! mul_add_assign_impl { ($ trait_name : ident for $ ($ t : ty) *) => { $ (impl $ trait_name for $ t { # [inline] fn mul_add_assign (& mut self , a : Self , b : Self) { * self = (* self * a) + b } }) * } } mul_add_assign_impl ! (MulAddAssign for isize usize i8 u8 i16 u16 i32 u32 i64 u64) ; # [cfg (has_i128)] mul_add_assign_impl ! (MulAddAssign for i128 u128) ; # [cfg (test)] mod tests { use super :: * ; # [test] fn mul_add_integer () { macro_rules ! test_mul_add { ($ ($ t : ident) +) => { $ ({ let m : $ t = 2 ; let x : $ t = 3 ; let b : $ t = 4 ; assert_eq ! (MulAdd :: mul_add (m , x , b) , (m * x + b)) ; }) + } ; } test_mul_add ! (usize u8 u16 u32 u64 isize i8 i16 i32 i64) ; } # [test] # [cfg (feature = "std")] fn mul_add_float () { macro_rules ! test_mul_add { ($ ($ t : ident) +) => { $ ({ use core ::$ t ; let m : $ t = 12.0 ; let x : $ t = 3.4 ; let b : $ t = 5.6 ; let abs_difference = (MulAdd :: mul_add (m , x , b) - (m * x + b)) . abs () ; assert ! (abs_difference <= 46.4 * $ t :: EPSILON) ; }) + } ; } test_mul_add ! (f32 f64) ; } } } pub mod saturating { # [doc = " Saturating math operations"] pub trait Saturating { # [doc = " Saturating addition operator."] # [doc = " Returns a+b, saturating at the numeric bounds instead of overflowing."] fn saturating_add (self , v : Self) -> Self ; # [doc = " Saturating subtraction operator."] # [doc = " Returns a-b, saturating at the numeric bounds instead of overflowing."] fn saturating_sub (self , v : Self) -> Self ; } macro_rules ! saturating_impl { ($ trait_name : ident for $ ($ t : ty) *) => { $ (impl $ trait_name for $ t { # [inline] fn saturating_add (self , v : Self) -> Self { Self :: saturating_add (self , v) } # [inline] fn saturating_sub (self , v : Self) -> Self { Self :: saturating_sub (self , v) } }) * } } saturating_impl ! (Saturating for isize usize i8 u8 i16 u16 i32 u32 i64 u64) ; # [cfg (has_i128)] saturating_impl ! (Saturating for i128 u128) ; } pub mod wrapping { use core :: num :: Wrapping ; use core :: ops :: { Add , Mul , Shl , Shr , Sub } ; macro_rules ! wrapping_impl { ($ trait_name : ident , $ method : ident , $ t : ty) => { impl $ trait_name for $ t { # [inline] fn $ method (& self , v : & Self) -> Self { <$ t >::$ method (* self , * v) } } } ; ($ trait_name : ident , $ method : ident , $ t : ty , $ rhs : ty) => { impl $ trait_name <$ rhs > for $ t { # [inline] fn $ method (& self , v : &$ rhs) -> Self { <$ t >::$ method (* self , * v) } } } ; } # [doc = " Performs addition that wraps around on overflow."] pub trait WrappingAdd : Sized + Add < Self , Output = Self > { # [doc = " Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of"] # [doc = " the type."] fn wrapping_add (& self , v : & Self) -> Self ; } wrapping_impl ! (WrappingAdd , wrapping_add , u8) ; wrapping_impl ! (WrappingAdd , wrapping_add , u16) ; wrapping_impl ! (WrappingAdd , wrapping_add , u32) ; wrapping_impl ! (WrappingAdd , wrapping_add , u64) ; wrapping_impl ! (WrappingAdd , wrapping_add , usize) ; # [cfg (has_i128)] wrapping_impl ! (WrappingAdd , wrapping_add , u128) ; wrapping_impl ! (WrappingAdd , wrapping_add , i8) ; wrapping_impl ! (WrappingAdd , wrapping_add , i16) ; wrapping_impl ! (WrappingAdd , wrapping_add , i32) ; wrapping_impl ! (WrappingAdd , wrapping_add , i64) ; wrapping_impl ! (WrappingAdd , wrapping_add , isize) ; # [cfg (has_i128)] wrapping_impl ! (WrappingAdd , wrapping_add , i128) ; # [doc = " Performs subtraction that wraps around on overflow."] pub trait WrappingSub : Sized + Sub < Self , Output = Self > { # [doc = " Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary"] # [doc = " of the type."] fn wrapping_sub (& self , v : & Self) -> Self ; } wrapping_impl ! (WrappingSub , wrapping_sub , u8) ; wrapping_impl ! (WrappingSub , wrapping_sub , u16) ; wrapping_impl ! (WrappingSub , wrapping_sub , u32) ; wrapping_impl ! (WrappingSub , wrapping_sub , u64) ; wrapping_impl ! (WrappingSub , wrapping_sub , usize) ; # [cfg (has_i128)] wrapping_impl ! (WrappingSub , wrapping_sub , u128) ; wrapping_impl ! (WrappingSub , wrapping_sub , i8) ; wrapping_impl ! (WrappingSub , wrapping_sub , i16) ; wrapping_impl ! (WrappingSub , wrapping_sub , i32) ; wrapping_impl ! (WrappingSub , wrapping_sub , i64) ; wrapping_impl ! (WrappingSub , wrapping_sub , isize) ; # [cfg (has_i128)] wrapping_impl ! (WrappingSub , wrapping_sub , i128) ; # [doc = " Performs multiplication that wraps around on overflow."] pub trait WrappingMul : Sized + Mul < Self , Output = Self > { # [doc = " Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary"] # [doc = " of the type."] fn wrapping_mul (& self , v : & Self) -> Self ; } wrapping_impl ! (WrappingMul , wrapping_mul , u8) ; wrapping_impl ! (WrappingMul , wrapping_mul , u16) ; wrapping_impl ! (WrappingMul , wrapping_mul , u32) ; wrapping_impl ! (WrappingMul , wrapping_mul , u64) ; wrapping_impl ! (WrappingMul , wrapping_mul , usize) ; # [cfg (has_i128)] wrapping_impl ! (WrappingMul , wrapping_mul , u128) ; wrapping_impl ! (WrappingMul , wrapping_mul , i8) ; wrapping_impl ! (WrappingMul , wrapping_mul , i16) ; wrapping_impl ! (WrappingMul , wrapping_mul , i32) ; wrapping_impl ! (WrappingMul , wrapping_mul , i64) ; wrapping_impl ! (WrappingMul , wrapping_mul , isize) ; # [cfg (has_i128)] wrapping_impl ! (WrappingMul , wrapping_mul , i128) ; macro_rules ! wrapping_shift_impl { ($ trait_name : ident , $ method : ident , $ t : ty) => { impl $ trait_name for $ t { # [inline] fn $ method (& self , rhs : u32) -> $ t { <$ t >::$ method (* self , rhs) } } } ; } # [doc = " Performs a left shift that does not panic."] pub trait WrappingShl : Sized + Shl < usize , Output = Self > { # [doc = " Panic-free bitwise shift-left; yields `self << mask(rhs)`,"] # [doc = " where `mask` removes any high order bits of `rhs` that would"] # [doc = " cause the shift to exceed the bitwidth of the type."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::WrappingShl;"] # [doc = ""] # [doc = " let x: u16 = 0x0001;"] # [doc = ""] # [doc = " assert_eq!(WrappingShl::wrapping_shl(&x, 0),  0x0001);"] # [doc = " assert_eq!(WrappingShl::wrapping_shl(&x, 1),  0x0002);"] # [doc = " assert_eq!(WrappingShl::wrapping_shl(&x, 15), 0x8000);"] # [doc = " assert_eq!(WrappingShl::wrapping_shl(&x, 16), 0x0001);"] # [doc = " ```"] fn wrapping_shl (& self , rhs : u32) -> Self ; } wrapping_shift_impl ! (WrappingShl , wrapping_shl , u8) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , u16) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , u32) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , u64) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , usize) ; # [cfg (has_i128)] wrapping_shift_impl ! (WrappingShl , wrapping_shl , u128) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , i8) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , i16) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , i32) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , i64) ; wrapping_shift_impl ! (WrappingShl , wrapping_shl , isize) ; # [cfg (has_i128)] wrapping_shift_impl ! (WrappingShl , wrapping_shl , i128) ; # [doc = " Performs a right shift that does not panic."] pub trait WrappingShr : Sized + Shr < usize , Output = Self > { # [doc = " Panic-free bitwise shift-right; yields `self >> mask(rhs)`,"] # [doc = " where `mask` removes any high order bits of `rhs` that would"] # [doc = " cause the shift to exceed the bitwidth of the type."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::WrappingShr;"] # [doc = ""] # [doc = " let x: u16 = 0x8000;"] # [doc = ""] # [doc = " assert_eq!(WrappingShr::wrapping_shr(&x, 0),  0x8000);"] # [doc = " assert_eq!(WrappingShr::wrapping_shr(&x, 1),  0x4000);"] # [doc = " assert_eq!(WrappingShr::wrapping_shr(&x, 15), 0x0001);"] # [doc = " assert_eq!(WrappingShr::wrapping_shr(&x, 16), 0x8000);"] # [doc = " ```"] fn wrapping_shr (& self , rhs : u32) -> Self ; } wrapping_shift_impl ! (WrappingShr , wrapping_shr , u8) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , u16) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , u32) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , u64) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , usize) ; # [cfg (has_i128)] wrapping_shift_impl ! (WrappingShr , wrapping_shr , u128) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , i8) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , i16) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , i32) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , i64) ; wrapping_shift_impl ! (WrappingShr , wrapping_shr , isize) ; # [cfg (has_i128)] wrapping_shift_impl ! (WrappingShr , wrapping_shr , i128) ; impl < T : WrappingAdd > WrappingAdd for Wrapping < T > where Wrapping < T > : Add < Output = Wrapping < T > > , { fn wrapping_add (& self , v : & Self) -> Self { Wrapping (self . 0 . wrapping_add (& v . 0)) } } impl < T : WrappingSub > WrappingSub for Wrapping < T > where Wrapping < T > : Sub < Output = Wrapping < T > > , { fn wrapping_sub (& self , v : & Self) -> Self { Wrapping (self . 0 . wrapping_sub (& v . 0)) } } impl < T : WrappingMul > WrappingMul for Wrapping < T > where Wrapping < T > : Mul < Output = Wrapping < T > > , { fn wrapping_mul (& self , v : & Self) -> Self { Wrapping (self . 0 . wrapping_mul (& v . 0)) } } impl < T : WrappingShl > WrappingShl for Wrapping < T > where Wrapping < T > : Shl < usize , Output = Wrapping < T > > , { fn wrapping_shl (& self , rhs : u32) -> Self { Wrapping (self . 0 . wrapping_shl (rhs)) } } impl < T : WrappingShr > WrappingShr for Wrapping < T > where Wrapping < T > : Shr < usize , Output = Wrapping < T > > , { fn wrapping_shr (& self , rhs : u32) -> Self { Wrapping (self . 0 . wrapping_shr (rhs)) } } # [test] fn test_wrapping_traits () { fn wrapping_add < T : WrappingAdd > (a : T , b : T) -> T { a . wrapping_add (& b) } fn wrapping_sub < T : WrappingSub > (a : T , b : T) -> T { a . wrapping_sub (& b) } fn wrapping_mul < T : WrappingMul > (a : T , b : T) -> T { a . wrapping_mul (& b) } fn wrapping_shl < T : WrappingShl > (a : T , b : u32) -> T { a . wrapping_shl (b) } fn wrapping_shr < T : WrappingShr > (a : T , b : u32) -> T { a . wrapping_shr (b) } assert_eq ! (wrapping_add (255 , 1) , 0u8) ; assert_eq ! (wrapping_sub (0 , 1) , 255u8) ; assert_eq ! (wrapping_mul (255 , 2) , 254u8) ; assert_eq ! (wrapping_shl (255 , 8) , 255u8) ; assert_eq ! (wrapping_shr (255 , 8) , 255u8) ; assert_eq ! (wrapping_add (255 , 1) , (Wrapping (255u8) + Wrapping (1u8)) . 0) ; assert_eq ! (wrapping_sub (0 , 1) , (Wrapping (0u8) - Wrapping (1u8)) . 0) ; assert_eq ! (wrapping_mul (255 , 2) , (Wrapping (255u8) * Wrapping (2u8)) . 0) ; assert_eq ! (wrapping_shl (255 , 8) , (Wrapping (255u8) << 8) . 0) ; assert_eq ! (wrapping_shr (255 , 8) , (Wrapping (255u8) >> 8) . 0) ; } # [test] fn wrapping_is_wrappingadd () { fn require_wrappingadd < T : WrappingAdd > (_ : & T) { } require_wrappingadd (& Wrapping (42)) ; } # [test] fn wrapping_is_wrappingsub () { fn require_wrappingsub < T : WrappingSub > (_ : & T) { } require_wrappingsub (& Wrapping (42)) ; } # [test] fn wrapping_is_wrappingmul () { fn require_wrappingmul < T : WrappingMul > (_ : & T) { } require_wrappingmul (& Wrapping (42)) ; } # [test] fn wrapping_is_wrappingshl () { fn require_wrappingshl < T : WrappingShl > (_ : & T) { } require_wrappingshl (& Wrapping (42)) ; } # [test] fn wrapping_is_wrappingshr () { fn require_wrappingshr < T : WrappingShr > (_ : & T) { } require_wrappingshr (& Wrapping (42)) ; } } } pub mod pow { use core :: num :: Wrapping ; use core :: ops :: Mul ; use { CheckedMul , One } ; # [doc = " Binary operator for raising a value to a power."] pub trait Pow < RHS > { # [doc = " The result after applying the operator."] type Output ; # [doc = " Returns `self` to the power `rhs`."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::Pow;"] # [doc = " assert_eq!(Pow::pow(10u32, 2u32), 100);"] # [doc = " ```"] fn pow (self , rhs : RHS) -> Self :: Output ; } macro_rules ! pow_impl { ($ t : ty) => { pow_impl ! ($ t , u8) ; pow_impl ! ($ t , usize) ; } ; ($ t : ty , $ rhs : ty) => { pow_impl ! ($ t , $ rhs , usize , pow) ; } ; ($ t : ty , $ rhs : ty , $ desired_rhs : ty , $ method : expr) => { impl Pow <$ rhs > for $ t { type Output = $ t ; # [inline] fn pow (self , rhs : $ rhs) -> $ t { ($ method) (self , <$ desired_rhs >:: from (rhs)) } } impl <'a > Pow <&'a $ rhs > for $ t { type Output = $ t ; # [inline] fn pow (self , rhs : &'a $ rhs) -> $ t { ($ method) (self , <$ desired_rhs >:: from (* rhs)) } } impl <'a > Pow <$ rhs > for &'a $ t { type Output = $ t ; # [inline] fn pow (self , rhs : $ rhs) -> $ t { ($ method) (* self , <$ desired_rhs >:: from (rhs)) } } impl <'a , 'b > Pow <&'a $ rhs > for &'b $ t { type Output = $ t ; # [inline] fn pow (self , rhs : &'a $ rhs) -> $ t { ($ method) (* self , <$ desired_rhs >:: from (* rhs)) } } } ; } pow_impl ! (u8 , u8 , u32 , u8 :: pow) ; pow_impl ! (u8 , u16 , u32 , u8 :: pow) ; pow_impl ! (u8 , u32 , u32 , u8 :: pow) ; pow_impl ! (u8 , usize) ; pow_impl ! (i8 , u8 , u32 , i8 :: pow) ; pow_impl ! (i8 , u16 , u32 , i8 :: pow) ; pow_impl ! (i8 , u32 , u32 , i8 :: pow) ; pow_impl ! (i8 , usize) ; pow_impl ! (u16 , u8 , u32 , u16 :: pow) ; pow_impl ! (u16 , u16 , u32 , u16 :: pow) ; pow_impl ! (u16 , u32 , u32 , u16 :: pow) ; pow_impl ! (u16 , usize) ; pow_impl ! (i16 , u8 , u32 , i16 :: pow) ; pow_impl ! (i16 , u16 , u32 , i16 :: pow) ; pow_impl ! (i16 , u32 , u32 , i16 :: pow) ; pow_impl ! (i16 , usize) ; pow_impl ! (u32 , u8 , u32 , u32 :: pow) ; pow_impl ! (u32 , u16 , u32 , u32 :: pow) ; pow_impl ! (u32 , u32 , u32 , u32 :: pow) ; pow_impl ! (u32 , usize) ; pow_impl ! (i32 , u8 , u32 , i32 :: pow) ; pow_impl ! (i32 , u16 , u32 , i32 :: pow) ; pow_impl ! (i32 , u32 , u32 , i32 :: pow) ; pow_impl ! (i32 , usize) ; pow_impl ! (u64 , u8 , u32 , u64 :: pow) ; pow_impl ! (u64 , u16 , u32 , u64 :: pow) ; pow_impl ! (u64 , u32 , u32 , u64 :: pow) ; pow_impl ! (u64 , usize) ; pow_impl ! (i64 , u8 , u32 , i64 :: pow) ; pow_impl ! (i64 , u16 , u32 , i64 :: pow) ; pow_impl ! (i64 , u32 , u32 , i64 :: pow) ; pow_impl ! (i64 , usize) ; # [cfg (has_i128)] pow_impl ! (u128 , u8 , u32 , u128 :: pow) ; # [cfg (has_i128)] pow_impl ! (u128 , u16 , u32 , u128 :: pow) ; # [cfg (has_i128)] pow_impl ! (u128 , u32 , u32 , u128 :: pow) ; # [cfg (has_i128)] pow_impl ! (u128 , usize) ; # [cfg (has_i128)] pow_impl ! (i128 , u8 , u32 , i128 :: pow) ; # [cfg (has_i128)] pow_impl ! (i128 , u16 , u32 , i128 :: pow) ; # [cfg (has_i128)] pow_impl ! (i128 , u32 , u32 , i128 :: pow) ; # [cfg (has_i128)] pow_impl ! (i128 , usize) ; pow_impl ! (usize , u8 , u32 , usize :: pow) ; pow_impl ! (usize , u16 , u32 , usize :: pow) ; pow_impl ! (usize , u32 , u32 , usize :: pow) ; pow_impl ! (usize , usize) ; pow_impl ! (isize , u8 , u32 , isize :: pow) ; pow_impl ! (isize , u16 , u32 , isize :: pow) ; pow_impl ! (isize , u32 , u32 , isize :: pow) ; pow_impl ! (isize , usize) ; pow_impl ! (Wrapping < u8 >) ; pow_impl ! (Wrapping < i8 >) ; pow_impl ! (Wrapping < u16 >) ; pow_impl ! (Wrapping < i16 >) ; pow_impl ! (Wrapping < u32 >) ; pow_impl ! (Wrapping < i32 >) ; pow_impl ! (Wrapping < u64 >) ; pow_impl ! (Wrapping < i64 >) ; # [cfg (has_i128)] pow_impl ! (Wrapping < u128 >) ; # [cfg (has_i128)] pow_impl ! (Wrapping < i128 >) ; pow_impl ! (Wrapping < usize >) ; pow_impl ! (Wrapping < isize >) ; # [cfg (any (feature = "std" , feature = "libm"))] mod float_impls { use super :: Pow ; use Float ; pow_impl ! (f32 , i8 , i32 , < f32 as Float >:: powi) ; pow_impl ! (f32 , u8 , i32 , < f32 as Float >:: powi) ; pow_impl ! (f32 , i16 , i32 , < f32 as Float >:: powi) ; pow_impl ! (f32 , u16 , i32 , < f32 as Float >:: powi) ; pow_impl ! (f32 , i32 , i32 , < f32 as Float >:: powi) ; pow_impl ! (f64 , i8 , i32 , < f64 as Float >:: powi) ; pow_impl ! (f64 , u8 , i32 , < f64 as Float >:: powi) ; pow_impl ! (f64 , i16 , i32 , < f64 as Float >:: powi) ; pow_impl ! (f64 , u16 , i32 , < f64 as Float >:: powi) ; pow_impl ! (f64 , i32 , i32 , < f64 as Float >:: powi) ; pow_impl ! (f32 , f32 , f32 , < f32 as Float >:: powf) ; pow_impl ! (f64 , f32 , f64 , < f64 as Float >:: powf) ; pow_impl ! (f64 , f64 , f64 , < f64 as Float >:: powf) ; } # [doc = " Raises a value to the power of exp, using exponentiation by squaring."] # [doc = ""] # [doc = " Note that `0` (`pow(0, 0)`) returns `1`. Mathematically this is undefined."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```rust"] # [doc = " use num_traits::pow;"] # [doc = ""] # [doc = " assert_eq!(pow(2i8, 4), 16);"] # [doc = " assert_eq!(pow(6u8, 3), 216);"] # [doc = " assert_eq!(pow(0u8, 0), 1); // Be aware if this case affects you"] # [doc = " ```"] # [inline] pub fn pow < T : Clone + One + Mul < T , Output = T > > (mut base : T , mut exp : usize) -> T { if exp == 0 { return T :: one () ; } while exp & 1 == 0 { base = base . clone () * base ; exp >>= 1 ; } if exp == 1 { return base ; } let mut acc = base . clone () ; while exp > 1 { exp >>= 1 ; base = base . clone () * base ; if exp & 1 == 1 { acc = acc * base . clone () ; } } acc } # [doc = " Raises a value to the power of exp, returning `None` if an overflow occurred."] # [doc = ""] # [doc = " Note that `0` (`checked_pow(0, 0)`) returns `Some(1)`. Mathematically this is undefined."] # [doc = ""] # [doc = " Otherwise same as the `pow` function."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```rust"] # [doc = " use num_traits::checked_pow;"] # [doc = ""] # [doc = " assert_eq!(checked_pow(2i8, 4), Some(16));"] # [doc = " assert_eq!(checked_pow(7i8, 8), None);"] # [doc = " assert_eq!(checked_pow(7u32, 8), Some(5_764_801));"] # [doc = " assert_eq!(checked_pow(0u32, 0), Some(1)); // Be aware if this case affect you"] # [doc = " ```"] # [inline] pub fn checked_pow < T : Clone + One + CheckedMul > (mut base : T , mut exp : usize) -> Option < T > { if exp == 0 { return Some (T :: one ()) ; } macro_rules ! optry { ($ expr : expr) => { if let Some (val) = $ expr { val } else { return None ; } } ; } while exp & 1 == 0 { base = optry ! (base . checked_mul (& base)) ; exp >>= 1 ; } if exp == 1 { return Some (base) ; } let mut acc = base . clone () ; while exp > 1 { exp >>= 1 ; base = optry ! (base . checked_mul (& base)) ; if exp & 1 == 1 { acc = optry ! (acc . checked_mul (& base)) ; } } Some (acc) } } pub mod real { use core :: ops :: Neg ; use { Float , Num , NumCast } ; # [doc = " A trait for real number types that do not necessarily have"] # [doc = " floating-point-specific characteristics such as NaN and infinity."] # [doc = ""] # [doc = " See [this Wikipedia article](https://en.wikipedia.org/wiki/Real_data_type)"] # [doc = " for a list of data types that could meaningfully implement this trait."] # [doc = ""] # [doc = " This trait is only available with the `std` feature, or with the `libm` feature otherwise."] pub trait Real : Num + Copy + NumCast + PartialOrd + Neg < Output = Self > { # [doc = " Returns the smallest finite value that this type can represent."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Real::min_value();"] # [doc = ""] # [doc = " assert_eq!(x, f64::MIN);"] # [doc = " ```"] fn min_value () -> Self ; # [doc = " Returns the smallest positive, normalized value that this type can represent."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Real::min_positive_value();"] # [doc = ""] # [doc = " assert_eq!(x, f64::MIN_POSITIVE);"] # [doc = " ```"] fn min_positive_value () -> Self ; # [doc = " Returns epsilon, a small positive value."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Real::epsilon();"] # [doc = ""] # [doc = " assert_eq!(x, f64::EPSILON);"] # [doc = " ```"] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " The default implementation will panic if `f32::EPSILON` cannot"] # [doc = " be cast to `Self`."] fn epsilon () -> Self ; # [doc = " Returns the largest finite value that this type can represent."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x: f64 = Real::max_value();"] # [doc = " assert_eq!(x, f64::MAX);"] # [doc = " ```"] fn max_value () -> Self ; # [doc = " Returns the largest integer less than or equal to a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let f = 3.99;"] # [doc = " let g = 3.0;"] # [doc = ""] # [doc = " assert_eq!(f.floor(), 3.0);"] # [doc = " assert_eq!(g.floor(), 3.0);"] # [doc = " ```"] fn floor (self) -> Self ; # [doc = " Returns the smallest integer greater than or equal to a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let f = 3.01;"] # [doc = " let g = 4.0;"] # [doc = ""] # [doc = " assert_eq!(f.ceil(), 4.0);"] # [doc = " assert_eq!(g.ceil(), 4.0);"] # [doc = " ```"] fn ceil (self) -> Self ; # [doc = " Returns the nearest integer to a number. Round half-way cases away from"] # [doc = " `0.0`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let f = 3.3;"] # [doc = " let g = -3.3;"] # [doc = ""] # [doc = " assert_eq!(f.round(), 3.0);"] # [doc = " assert_eq!(g.round(), -3.0);"] # [doc = " ```"] fn round (self) -> Self ; # [doc = " Return the integer part of a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let f = 3.3;"] # [doc = " let g = -3.7;"] # [doc = ""] # [doc = " assert_eq!(f.trunc(), 3.0);"] # [doc = " assert_eq!(g.trunc(), -3.0);"] # [doc = " ```"] fn trunc (self) -> Self ; # [doc = " Returns the fractional part of a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 3.5;"] # [doc = " let y = -3.5;"] # [doc = " let abs_difference_x = (x.fract() - 0.5).abs();"] # [doc = " let abs_difference_y = (y.fract() - (-0.5)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_x < 1e-10);"] # [doc = " assert!(abs_difference_y < 1e-10);"] # [doc = " ```"] fn fract (self) -> Self ; # [doc = " Computes the absolute value of `self`. Returns `Float::nan()` if the"] # [doc = " number is `Float::nan()`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = 3.5;"] # [doc = " let y = -3.5;"] # [doc = ""] # [doc = " let abs_difference_x = (x.abs() - x).abs();"] # [doc = " let abs_difference_y = (y.abs() - (-y)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_x < 1e-10);"] # [doc = " assert!(abs_difference_y < 1e-10);"] # [doc = ""] # [doc = " assert!(::num_traits::Float::is_nan(f64::NAN.abs()));"] # [doc = " ```"] fn abs (self) -> Self ; # [doc = " Returns a number that represents the sign of `self`."] # [doc = ""] # [doc = " - `1.0` if the number is positive, `+0.0` or `Float::infinity()`"] # [doc = " - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`"] # [doc = " - `Float::nan()` if the number is `Float::nan()`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let f = 3.5;"] # [doc = ""] # [doc = " assert_eq!(f.signum(), 1.0);"] # [doc = " assert_eq!(f64::NEG_INFINITY.signum(), -1.0);"] # [doc = ""] # [doc = " assert!(f64::NAN.signum().is_nan());"] # [doc = " ```"] fn signum (self) -> Self ; # [doc = " Returns `true` if `self` is positive, including `+0.0`,"] # [doc = " `Float::infinity()`, and with newer versions of Rust `f64::NAN`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let neg_nan: f64 = -f64::NAN;"] # [doc = ""] # [doc = " let f = 7.0;"] # [doc = " let g = -7.0;"] # [doc = ""] # [doc = " assert!(f.is_sign_positive());"] # [doc = " assert!(!g.is_sign_positive());"] # [doc = " assert!(!neg_nan.is_sign_positive());"] # [doc = " ```"] fn is_sign_positive (self) -> bool ; # [doc = " Returns `true` if `self` is negative, including `-0.0`,"] # [doc = " `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let nan: f64 = f64::NAN;"] # [doc = ""] # [doc = " let f = 7.0;"] # [doc = " let g = -7.0;"] # [doc = ""] # [doc = " assert!(!f.is_sign_negative());"] # [doc = " assert!(g.is_sign_negative());"] # [doc = " assert!(!nan.is_sign_negative());"] # [doc = " ```"] fn is_sign_negative (self) -> bool ; # [doc = " Fused multiply-add. Computes `(self * a) + b` with only one rounding"] # [doc = " error, yielding a more accurate result than an unfused multiply-add."] # [doc = ""] # [doc = " Using `mul_add` can be more performant than an unfused multiply-add if"] # [doc = " the target architecture has a dedicated `fma` CPU instruction."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let m = 10.0;"] # [doc = " let x = 4.0;"] # [doc = " let b = 60.0;"] # [doc = ""] # [doc = " // 100.0"] # [doc = " let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn mul_add (self , a : Self , b : Self) -> Self ; # [doc = " Take the reciprocal (inverse) of a number, `1/x`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let abs_difference = (x.recip() - (1.0/x)).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn recip (self) -> Self ; # [doc = " Raise a number to an integer power."] # [doc = ""] # [doc = " Using this function is generally faster than using `powf`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let abs_difference = (x.powi(2) - x*x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn powi (self , n : i32) -> Self ; # [doc = " Raise a number to a real number power."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let abs_difference = (x.powf(2.0) - x*x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn powf (self , n : Self) -> Self ; # [doc = " Take the square root of a number."] # [doc = ""] # [doc = " Returns NaN if `self` is a negative floating-point number.  "] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If the implementing type doesn't support NaN, this method should panic if `self < 0`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let positive = 4.0;"] # [doc = " let negative = -4.0;"] # [doc = ""] # [doc = " let abs_difference = (positive.sqrt() - 2.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " assert!(::num_traits::Float::is_nan(negative.sqrt()));"] # [doc = " ```"] fn sqrt (self) -> Self ; # [doc = " Returns `e^(self)`, (the exponential function)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let one = 1.0;"] # [doc = " // e^1"] # [doc = " let e = one.exp();"] # [doc = ""] # [doc = " // ln(e) - 1 == 0"] # [doc = " let abs_difference = (e.ln() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn exp (self) -> Self ; # [doc = " Returns `2^(self)`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let f = 2.0;"] # [doc = ""] # [doc = " // 2^2 - 4 == 0"] # [doc = " let abs_difference = (f.exp2() - 4.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn exp2 (self) -> Self ; # [doc = " Returns the natural logarithm of the number."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If `self <= 0` and this type does not support a NaN representation, this function should panic."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let one = 1.0;"] # [doc = " // e^1"] # [doc = " let e = one.exp();"] # [doc = ""] # [doc = " // ln(e) - 1 == 0"] # [doc = " let abs_difference = (e.ln() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn ln (self) -> Self ; # [doc = " Returns the logarithm of the number with respect to an arbitrary base."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If `self <= 0` and this type does not support a NaN representation, this function should panic."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let ten = 10.0;"] # [doc = " let two = 2.0;"] # [doc = ""] # [doc = " // log10(10) - 1 == 0"] # [doc = " let abs_difference_10 = (ten.log(10.0) - 1.0).abs();"] # [doc = ""] # [doc = " // log2(2) - 1 == 0"] # [doc = " let abs_difference_2 = (two.log(2.0) - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_10 < 1e-10);"] # [doc = " assert!(abs_difference_2 < 1e-10);"] # [doc = " ```"] fn log (self , base : Self) -> Self ; # [doc = " Returns the base 2 logarithm of the number."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If `self <= 0` and this type does not support a NaN representation, this function should panic."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let two = 2.0;"] # [doc = ""] # [doc = " // log2(2) - 1 == 0"] # [doc = " let abs_difference = (two.log2() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn log2 (self) -> Self ; # [doc = " Returns the base 10 logarithm of the number."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If `self <= 0` and this type does not support a NaN representation, this function should panic."] # [doc = ""] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let ten = 10.0;"] # [doc = ""] # [doc = " // log10(10) - 1 == 0"] # [doc = " let abs_difference = (ten.log10() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn log10 (self) -> Self ; # [doc = " Converts radians to degrees."] # [doc = ""] # [doc = " ```"] # [doc = " use std::f64::consts;"] # [doc = ""] # [doc = " let angle = consts::PI;"] # [doc = ""] # [doc = " let abs_difference = (angle.to_degrees() - 180.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn to_degrees (self) -> Self ; # [doc = " Converts degrees to radians."] # [doc = ""] # [doc = " ```"] # [doc = " use std::f64::consts;"] # [doc = ""] # [doc = " let angle = 180.0_f64;"] # [doc = ""] # [doc = " let abs_difference = (angle.to_radians() - consts::PI).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn to_radians (self) -> Self ; # [doc = " Returns the maximum of the two numbers."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let y = 2.0;"] # [doc = ""] # [doc = " assert_eq!(x.max(y), y);"] # [doc = " ```"] fn max (self , other : Self) -> Self ; # [doc = " Returns the minimum of the two numbers."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let y = 2.0;"] # [doc = ""] # [doc = " assert_eq!(x.min(y), x);"] # [doc = " ```"] fn min (self , other : Self) -> Self ; # [doc = " The positive difference of two numbers."] # [doc = ""] # [doc = " * If `self <= other`: `0:0`"] # [doc = " * Else: `self - other`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 3.0;"] # [doc = " let y = -3.0;"] # [doc = ""] # [doc = " let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();"] # [doc = " let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_x < 1e-10);"] # [doc = " assert!(abs_difference_y < 1e-10);"] # [doc = " ```"] fn abs_sub (self , other : Self) -> Self ; # [doc = " Take the cubic root of a number."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 8.0;"] # [doc = ""] # [doc = " // x^(1/3) - 2 == 0"] # [doc = " let abs_difference = (x.cbrt() - 2.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn cbrt (self) -> Self ; # [doc = " Calculate the length of the hypotenuse of a right-angle triangle given"] # [doc = " legs of length `x` and `y`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 2.0;"] # [doc = " let y = 3.0;"] # [doc = ""] # [doc = " // sqrt(x^2 + y^2)"] # [doc = " let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn hypot (self , other : Self) -> Self ; # [doc = " Computes the sine of a number (in radians)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::PI/2.0;"] # [doc = ""] # [doc = " let abs_difference = (x.sin() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn sin (self) -> Self ; # [doc = " Computes the cosine of a number (in radians)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = 2.0*f64::consts::PI;"] # [doc = ""] # [doc = " let abs_difference = (x.cos() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn cos (self) -> Self ; # [doc = " Computes the tangent of a number (in radians)."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::PI/4.0;"] # [doc = " let abs_difference = (x.tan() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-14);"] # [doc = " ```"] fn tan (self) -> Self ; # [doc = " Computes the arcsine of a number. Return value is in radians in"] # [doc = " the range [-pi/2, pi/2] or NaN if the number is outside the range"] # [doc = " [-1, 1]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If this type does not support a NaN representation, this function should panic"] # [doc = " if the number is outside the range [-1, 1]."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let f = f64::consts::PI / 2.0;"] # [doc = ""] # [doc = " // asin(sin(pi/2))"] # [doc = " let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn asin (self) -> Self ; # [doc = " Computes the arccosine of a number. Return value is in radians in"] # [doc = " the range [0, pi] or NaN if the number is outside the range"] # [doc = " [-1, 1]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If this type does not support a NaN representation, this function should panic"] # [doc = " if the number is outside the range [-1, 1]."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let f = f64::consts::PI / 4.0;"] # [doc = ""] # [doc = " // acos(cos(pi/4))"] # [doc = " let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn acos (self) -> Self ; # [doc = " Computes the arctangent of a number. Return value is in radians in the"] # [doc = " range [-pi/2, pi/2];"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let f = 1.0;"] # [doc = ""] # [doc = " // atan(tan(1))"] # [doc = " let abs_difference = (f.tan().atan() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn atan (self) -> Self ; # [doc = " Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`)."] # [doc = ""] # [doc = " * `x = 0`, `y = 0`: `0`"] # [doc = " * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`"] # [doc = " * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`"] # [doc = " * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`"] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let pi = f64::consts::PI;"] # [doc = " // All angles from horizontal right (+x)"] # [doc = " // 45 deg counter-clockwise"] # [doc = " let x1 = 3.0;"] # [doc = " let y1 = -3.0;"] # [doc = ""] # [doc = " // 135 deg clockwise"] # [doc = " let x2 = -3.0;"] # [doc = " let y2 = 3.0;"] # [doc = ""] # [doc = " let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();"] # [doc = " let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_1 < 1e-10);"] # [doc = " assert!(abs_difference_2 < 1e-10);"] # [doc = " ```"] fn atan2 (self , other : Self) -> Self ; # [doc = " Simultaneously computes the sine and cosine of the number, `x`. Returns"] # [doc = " `(sin(x), cos(x))`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::PI/4.0;"] # [doc = " let f = x.sin_cos();"] # [doc = ""] # [doc = " let abs_difference_0 = (f.0 - x.sin()).abs();"] # [doc = " let abs_difference_1 = (f.1 - x.cos()).abs();"] # [doc = ""] # [doc = " assert!(abs_difference_0 < 1e-10);"] # [doc = " assert!(abs_difference_0 < 1e-10);"] # [doc = " ```"] fn sin_cos (self) -> (Self , Self) ; # [doc = " Returns `e^(self) - 1` in a way that is accurate even if the"] # [doc = " number is close to zero."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 7.0;"] # [doc = ""] # [doc = " // e^(ln(7)) - 1"] # [doc = " let abs_difference = (x.ln().exp_m1() - 6.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn exp_m1 (self) -> Self ; # [doc = " Returns `ln(1+n)` (natural logarithm) more accurately than if"] # [doc = " the operations were performed separately."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " If this type does not support a NaN representation, this function should panic"] # [doc = " if `self-1 <= 0`."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let x = f64::consts::E - 1.0;"] # [doc = ""] # [doc = " // ln(1 + (e - 1)) == ln(e) == 1"] # [doc = " let abs_difference = (x.ln_1p() - 1.0).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn ln_1p (self) -> Self ; # [doc = " Hyperbolic sine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let x = 1.0;"] # [doc = ""] # [doc = " let f = x.sinh();"] # [doc = " // Solving sinh() at 1 gives `(e^2-1)/(2e)`"] # [doc = " let g = (e*e - 1.0)/(2.0*e);"] # [doc = " let abs_difference = (f - g).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1e-10);"] # [doc = " ```"] fn sinh (self) -> Self ; # [doc = " Hyperbolic cosine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let x = 1.0;"] # [doc = " let f = x.cosh();"] # [doc = " // Solving cosh() at 1 gives this result"] # [doc = " let g = (e*e + 1.0)/(2.0*e);"] # [doc = " let abs_difference = (f - g).abs();"] # [doc = ""] # [doc = " // Same result"] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn cosh (self) -> Self ; # [doc = " Hyperbolic tangent function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let x = 1.0;"] # [doc = ""] # [doc = " let f = x.tanh();"] # [doc = " // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`"] # [doc = " let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));"] # [doc = " let abs_difference = (f - g).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn tanh (self) -> Self ; # [doc = " Inverse hyperbolic sine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let f = x.sinh().asinh();"] # [doc = ""] # [doc = " let abs_difference = (f - x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn asinh (self) -> Self ; # [doc = " Inverse hyperbolic cosine function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = ""] # [doc = " let x = 1.0;"] # [doc = " let f = x.cosh().acosh();"] # [doc = ""] # [doc = " let abs_difference = (f - x).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn acosh (self) -> Self ; # [doc = " Inverse hyperbolic tangent function."] # [doc = ""] # [doc = " ```"] # [doc = " use num_traits::real::Real;"] # [doc = " use std::f64;"] # [doc = ""] # [doc = " let e = f64::consts::E;"] # [doc = " let f = e.tanh().atanh();"] # [doc = ""] # [doc = " let abs_difference = (f - e).abs();"] # [doc = ""] # [doc = " assert!(abs_difference < 1.0e-10);"] # [doc = " ```"] fn atanh (self) -> Self ; } impl < T : Float > Real for T { forward ! { Float :: min_value () -> Self ; Float :: min_positive_value () -> Self ; Float :: epsilon () -> Self ; Float :: max_value () -> Self ; } forward ! { Float :: floor (self) -> Self ; Float :: ceil (self) -> Self ; Float :: round (self) -> Self ; Float :: trunc (self) -> Self ; Float :: fract (self) -> Self ; Float :: abs (self) -> Self ; Float :: signum (self) -> Self ; Float :: is_sign_positive (self) -> bool ; Float :: is_sign_negative (self) -> bool ; Float :: mul_add (self , a : Self , b : Self) -> Self ; Float :: recip (self) -> Self ; Float :: powi (self , n : i32) -> Self ; Float :: powf (self , n : Self) -> Self ; Float :: sqrt (self) -> Self ; Float :: exp (self) -> Self ; Float :: exp2 (self) -> Self ; Float :: ln (self) -> Self ; Float :: log (self , base : Self) -> Self ; Float :: log2 (self) -> Self ; Float :: log10 (self) -> Self ; Float :: to_degrees (self) -> Self ; Float :: to_radians (self) -> Self ; Float :: max (self , other : Self) -> Self ; Float :: min (self , other : Self) -> Self ; Float :: abs_sub (self , other : Self) -> Self ; Float :: cbrt (self) -> Self ; Float :: hypot (self , other : Self) -> Self ; Float :: sin (self) -> Self ; Float :: cos (self) -> Self ; Float :: tan (self) -> Self ; Float :: asin (self) -> Self ; Float :: acos (self) -> Self ; Float :: atan (self) -> Self ; Float :: atan2 (self , other : Self) -> Self ; Float :: sin_cos (self) -> (Self , Self) ; Float :: exp_m1 (self) -> Self ; Float :: ln_1p (self) -> Self ; Float :: sinh (self) -> Self ; Float :: cosh (self) -> Self ; Float :: tanh (self) -> Self ; Float :: asinh (self) -> Self ; Float :: acosh (self) -> Self ; Float :: atanh (self) -> Self ; } } } pub mod sign { use core :: num :: Wrapping ; use core :: ops :: Neg ; use float :: FloatCore ; use Num ; # [doc = " Useful functions for signed numbers (i.e. numbers that can be negative)."] pub trait Signed : Sized + Num + Neg < Output = Self > { # [doc = " Computes the absolute value."] # [doc = ""] # [doc = " For `f32` and `f64`, `NaN` will be returned if the number is `NaN`."] # [doc = ""] # [doc = " For signed integers, `::MIN` will be returned if the number is `::MIN`."] fn abs (& self) -> Self ; # [doc = " The positive difference of two numbers."] # [doc = ""] # [doc = " Returns `zero` if the number is less than or equal to `other`, otherwise the difference"] # [doc = " between `self` and `other` is returned."] fn abs_sub (& self , other : & Self) -> Self ; # [doc = " Returns the sign of the number."] # [doc = ""] # [doc = " For `f32` and `f64`:"] # [doc = ""] # [doc = " * `1.0` if the number is positive, `+0.0` or `INFINITY`"] # [doc = " * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`"] # [doc = " * `NaN` if the number is `NaN`"] # [doc = ""] # [doc = " For signed integers:"] # [doc = ""] # [doc = " * `0` if the number is zero"] # [doc = " * `1` if the number is positive"] # [doc = " * `-1` if the number is negative"] fn signum (& self) -> Self ; # [doc = " Returns true if the number is positive and false if the number is zero or negative."] fn is_positive (& self) -> bool ; # [doc = " Returns true if the number is negative and false if the number is zero or positive."] fn is_negative (& self) -> bool ; } macro_rules ! signed_impl { ($ ($ t : ty) *) => ($ (impl Signed for $ t { # [inline] fn abs (& self) -> $ t { if self . is_negative () { -* self } else { * self } } # [inline] fn abs_sub (& self , other : &$ t) -> $ t { if * self <= * other { 0 } else { * self - * other } } # [inline] fn signum (& self) -> $ t { match * self { n if n > 0 => 1 , 0 => 0 , _ => - 1 , } } # [inline] fn is_positive (& self) -> bool { * self > 0 } # [inline] fn is_negative (& self) -> bool { * self < 0 } }) *) } signed_impl ! (isize i8 i16 i32 i64) ; # [cfg (has_i128)] signed_impl ! (i128) ; impl < T : Signed > Signed for Wrapping < T > where Wrapping < T > : Num + Neg < Output = Wrapping < T > > , { # [inline] fn abs (& self) -> Self { Wrapping (self . 0 . abs ()) } # [inline] fn abs_sub (& self , other : & Self) -> Self { Wrapping (self . 0 . abs_sub (& other . 0)) } # [inline] fn signum (& self) -> Self { Wrapping (self . 0 . signum ()) } # [inline] fn is_positive (& self) -> bool { self . 0 . is_positive () } # [inline] fn is_negative (& self) -> bool { self . 0 . is_negative () } } macro_rules ! signed_float_impl { ($ t : ty) => { impl Signed for $ t { # [doc = " Computes the absolute value. Returns `NAN` if the number is `NAN`."] # [inline] fn abs (& self) -> $ t { FloatCore :: abs (* self) } # [doc = " The positive difference of two numbers. Returns `0.0` if the number is"] # [doc = " less than or equal to `other`, otherwise the difference between`self`"] # [doc = " and `other` is returned."] # [inline] fn abs_sub (& self , other : &$ t) -> $ t { if * self <= * other { 0. } else { * self - * other } } # [doc = " # Returns"] # [doc = ""] # [doc = " - `1.0` if the number is positive, `+0.0` or `INFINITY`"] # [doc = " - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`"] # [doc = " - `NAN` if the number is NaN"] # [inline] fn signum (& self) -> $ t { FloatCore :: signum (* self) } # [doc = " Returns `true` if the number is positive, including `+0.0` and `INFINITY`"] # [inline] fn is_positive (& self) -> bool { FloatCore :: is_sign_positive (* self) } # [doc = " Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`"] # [inline] fn is_negative (& self) -> bool { FloatCore :: is_sign_negative (* self) } } } ; } signed_float_impl ! (f32) ; signed_float_impl ! (f64) ; # [doc = " Computes the absolute value."] # [doc = ""] # [doc = " For `f32` and `f64`, `NaN` will be returned if the number is `NaN`"] # [doc = ""] # [doc = " For signed integers, `::MIN` will be returned if the number is `::MIN`."] # [inline (always)] pub fn abs < T : Signed > (value : T) -> T { value . abs () } # [doc = " The positive difference of two numbers."] # [doc = ""] # [doc = " Returns zero if `x` is less than or equal to `y`, otherwise the difference"] # [doc = " between `x` and `y` is returned."] # [inline (always)] pub fn abs_sub < T : Signed > (x : T , y : T) -> T { x . abs_sub (& y) } # [doc = " Returns the sign of the number."] # [doc = ""] # [doc = " For `f32` and `f64`:"] # [doc = ""] # [doc = " * `1.0` if the number is positive, `+0.0` or `INFINITY`"] # [doc = " * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`"] # [doc = " * `NaN` if the number is `NaN`"] # [doc = ""] # [doc = " For signed integers:"] # [doc = ""] # [doc = " * `0` if the number is zero"] # [doc = " * `1` if the number is positive"] # [doc = " * `-1` if the number is negative"] # [inline (always)] pub fn signum < T : Signed > (value : T) -> T { value . signum () } # [doc = " A trait for values which cannot be negative"] pub trait Unsigned : Num { } macro_rules ! empty_trait_impl { ($ name : ident for $ ($ t : ty) *) => ($ (impl $ name for $ t { }) *) } empty_trait_impl ! (Unsigned for usize u8 u16 u32 u64) ; # [cfg (has_i128)] empty_trait_impl ! (Unsigned for u128) ; impl < T : Unsigned > Unsigned for Wrapping < T > where Wrapping < T > : Num { } # [test] fn unsigned_wrapping_is_unsigned () { fn require_unsigned < T : Unsigned > (_ : & T) { } require_unsigned (& Wrapping (42_u32)) ; } } # [doc = " The base trait for numeric types, covering `0` and `1` values,"] # [doc = " comparisons, basic numeric operations, and string conversion."] pub trait Num : PartialEq + Zero + One + NumOps { type FromStrRadixErr ; # [doc = " Convert from a string and radix <= 36."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```rust"] # [doc = " use num_traits::Num;"] # [doc = ""] # [doc = " let result = <i32 as Num>::from_str_radix(\"27\", 10);"] # [doc = " assert_eq!(result, Ok(27));"] # [doc = ""] # [doc = " let result = <i32 as Num>::from_str_radix(\"foo\", 10);"] # [doc = " assert!(result.is_err());"] # [doc = " ```"] fn from_str_radix (str : & str , radix : u32) -> Result < Self , Self :: FromStrRadixErr > ; } # [doc = " The trait for types implementing basic numeric operations"] # [doc = ""] # [doc = " This is automatically implemented for types which implement the operators."] pub trait NumOps < Rhs = Self , Output = Self > : Add < Rhs , Output = Output > + Sub < Rhs , Output = Output > + Mul < Rhs , Output = Output > + Div < Rhs , Output = Output > + Rem < Rhs , Output = Output > { } impl < T , Rhs , Output > NumOps < Rhs , Output > for T where T : Add < Rhs , Output = Output > + Sub < Rhs , Output = Output > + Mul < Rhs , Output = Output > + Div < Rhs , Output = Output > + Rem < Rhs , Output = Output > { } # [doc = " The trait for `Num` types which also implement numeric operations taking"] # [doc = " the second operand by reference."] # [doc = ""] # [doc = " This is automatically implemented for types which implement the operators."] pub trait NumRef : Num + for < 'r > NumOps < & 'r Self > { } impl < T > NumRef for T where T : Num + for < 'r > NumOps < & 'r T > { } # [doc = " The trait for references which implement numeric operations, taking the"] # [doc = " second operand either by value or by reference."] # [doc = ""] # [doc = " This is automatically implemented for types which implement the operators."] pub trait RefNum < Base > : NumOps < Base , Base > + for < 'r > NumOps < & 'r Base , Base > { } impl < T , Base > RefNum < Base > for T where T : NumOps < Base , Base > + for < 'r > NumOps < & 'r Base , Base > { } # [doc = " The trait for types implementing numeric assignment operators (like `+=`)."] # [doc = ""] # [doc = " This is automatically implemented for types which implement the operators."] pub trait NumAssignOps < Rhs = Self > : AddAssign < Rhs > + SubAssign < Rhs > + MulAssign < Rhs > + DivAssign < Rhs > + RemAssign < Rhs > { } impl < T , Rhs > NumAssignOps < Rhs > for T where T : AddAssign < Rhs > + SubAssign < Rhs > + MulAssign < Rhs > + DivAssign < Rhs > + RemAssign < Rhs > { } # [doc = " The trait for `Num` types which also implement assignment operators."] # [doc = ""] # [doc = " This is automatically implemented for types which implement the operators."] pub trait NumAssign : Num + NumAssignOps { } impl < T > NumAssign for T where T : Num + NumAssignOps { } # [doc = " The trait for `NumAssign` types which also implement assignment operations"] # [doc = " taking the second operand by reference."] # [doc = ""] # [doc = " This is automatically implemented for types which implement the operators."] pub trait NumAssignRef : NumAssign + for < 'r > NumAssignOps < & 'r Self > { } impl < T > NumAssignRef for T where T : NumAssign + for < 'r > NumAssignOps < & 'r T > { } macro_rules ! int_trait_impl { ($ name : ident for $ ($ t : ty) *) => ($ (impl $ name for $ t { type FromStrRadixErr = :: core :: num :: ParseIntError ; # [inline] fn from_str_radix (s : & str , radix : u32) -> Result < Self , :: core :: num :: ParseIntError > { <$ t >:: from_str_radix (s , radix) } }) *) } int_trait_impl ! (Num for usize u8 u16 u32 u64 isize i8 i16 i32 i64) ; # [cfg (has_i128)] int_trait_impl ! (Num for u128 i128) ; impl < T : Num > Num for Wrapping < T > where Wrapping < T > : Add < Output = Wrapping < T > > + Sub < Output = Wrapping < T > > + Mul < Output = Wrapping < T > > + Div < Output = Wrapping < T > > + Rem < Output = Wrapping < T > > , { type FromStrRadixErr = T :: FromStrRadixErr ; fn from_str_radix (str : & str , radix : u32) -> Result < Self , Self :: FromStrRadixErr > { T :: from_str_radix (str , radix) . map (Wrapping) } } # [derive (Debug)] pub enum FloatErrorKind { Empty , Invalid , } # [derive (Debug)] pub struct ParseFloatError { pub kind : FloatErrorKind , } impl fmt :: Display for ParseFloatError { fn fmt (& self , f : & mut fmt :: Formatter) -> fmt :: Result { let description = match self . kind { FloatErrorKind :: Empty => "cannot parse float from empty string" , FloatErrorKind :: Invalid => "invalid float literal" , } ; description . fmt (f) } } macro_rules ! float_trait_impl { ($ name : ident for $ ($ t : ident) *) => ($ (impl $ name for $ t { type FromStrRadixErr = ParseFloatError ; fn from_str_radix (src : & str , radix : u32) -> Result < Self , Self :: FromStrRadixErr > { use self :: FloatErrorKind ::*; use self :: ParseFloatError as PFE ; match src { "inf" => return Ok (core ::$ t :: INFINITY) , "-inf" => return Ok (core ::$ t :: NEG_INFINITY) , "NaN" => return Ok (core ::$ t :: NAN) , _ => { } , } fn slice_shift_char (src : & str) -> Option < (char , & str) > { let mut chars = src . chars () ; if let Some (ch) = chars . next () { Some ((ch , chars . as_str ())) } else { None } } let (is_positive , src) = match slice_shift_char (src) { None => return Err (PFE { kind : Empty }) , Some (('-' , "")) => return Err (PFE { kind : Empty }) , Some (('-' , src)) => (false , src) , Some ((_ , _)) => (true , src) , } ; let mut sig = if is_positive { 0.0 } else { - 0.0 } ; let mut prev_sig = sig ; let mut cs = src . chars () . enumerate () ; let mut exp_info = None ::< (char , usize) >; for (i , c) in cs . by_ref () { match c . to_digit (radix) { Some (digit) => { sig = sig * (radix as $ t) ; if is_positive { sig = sig + ((digit as isize) as $ t) ; } else { sig = sig - ((digit as isize) as $ t) ; } if prev_sig != 0.0 { if is_positive && sig <= prev_sig { return Ok (core ::$ t :: INFINITY) ; } if ! is_positive && sig >= prev_sig { return Ok (core ::$ t :: NEG_INFINITY) ; } if is_positive && (prev_sig != (sig - digit as $ t) / radix as $ t) { return Ok (core ::$ t :: INFINITY) ; } if ! is_positive && (prev_sig != (sig + digit as $ t) / radix as $ t) { return Ok (core ::$ t :: NEG_INFINITY) ; } } prev_sig = sig ; } , None => match c { 'e' | 'E' | 'p' | 'P' => { exp_info = Some ((c , i + 1)) ; break ; } , '.' => { break ; } , _ => { return Err (PFE { kind : Invalid }) ; } , } , } } if exp_info . is_none () { let mut power = 1.0 ; for (i , c) in cs . by_ref () { match c . to_digit (radix) { Some (digit) => { power = power / (radix as $ t) ; sig = if is_positive { sig + (digit as $ t) * power } else { sig - (digit as $ t) * power } ; if is_positive && sig < prev_sig { return Ok (core ::$ t :: INFINITY) ; } if ! is_positive && sig > prev_sig { return Ok (core ::$ t :: NEG_INFINITY) ; } prev_sig = sig ; } , None => match c { 'e' | 'E' | 'p' | 'P' => { exp_info = Some ((c , i + 1)) ; break ; } , _ => { return Err (PFE { kind : Invalid }) ; } , } , } } } let exp = match exp_info { Some ((c , offset)) => { let base = match c { 'E' | 'e' if radix == 10 => 10.0 , 'P' | 'p' if radix == 16 => 2.0 , _ => return Err (PFE { kind : Invalid }) , } ; let src = & src [offset ..] ; let (is_positive , exp) = match slice_shift_char (src) { Some (('-' , src)) => (false , src . parse ::< usize > ()) , Some (('+' , src)) => (true , src . parse ::< usize > ()) , Some ((_ , _)) => (true , src . parse ::< usize > ()) , None => return Err (PFE { kind : Invalid }) , } ; # [cfg (feature = "std")] fn pow (base : $ t , exp : usize) -> $ t { Float :: powi (base , exp as i32) } match (is_positive , exp) { (true , Ok (exp)) => pow (base , exp) , (false , Ok (exp)) => 1.0 / pow (base , exp) , (_ , Err (_)) => return Err (PFE { kind : Invalid }) , } } , None => 1.0 , } ; Ok (sig * exp) } }) *) } float_trait_impl ! (Num for f32 f64) ; # [doc = " A value bounded by a minimum and a maximum"] # [doc = ""] # [doc = "  If input is less than min then this returns min."] # [doc = "  If input is greater than max then this returns max."] # [doc = "  Otherwise this returns input."] # [doc = ""] # [doc = " **Panics** in debug mode if `!(min <= max)`."] # [inline] pub fn clamp < T : PartialOrd > (input : T , min : T , max : T) -> T { debug_assert ! (min <= max , "min must be less than or equal to max") ; if input < min { min } else if input > max { max } else { input } } # [doc = " A value bounded by a minimum value"] # [doc = ""] # [doc = "  If input is less than min then this returns min."] # [doc = "  Otherwise this returns input."] # [doc = "  `clamp_min(std::f32::NAN, 1.0)` preserves `NAN` different from `f32::min(std::f32::NAN, 1.0)`."] # [doc = ""] # [doc = " **Panics** in debug mode if `!(min == min)`. (This occurs if `min` is `NAN`.)"] # [inline] pub fn clamp_min < T : PartialOrd > (input : T , min : T) -> T { debug_assert ! (min == min , "min must not be NAN") ; if input < min { min } else { input } } # [doc = " A value bounded by a maximum value"] # [doc = ""] # [doc = "  If input is greater than max then this returns max."] # [doc = "  Otherwise this returns input."] # [doc = "  `clamp_max(std::f32::NAN, 1.0)` preserves `NAN` different from `f32::max(std::f32::NAN, 1.0)`."] # [doc = ""] # [doc = " **Panics** in debug mode if `!(max == max)`. (This occurs if `max` is `NAN`.)"] # [inline] pub fn clamp_max < T : PartialOrd > (input : T , max : T) -> T { debug_assert ! (max == max , "max must not be NAN") ; if input > max { max } else { input } } # [test] fn clamp_test () { assert_eq ! (1 , clamp (1 , - 1 , 2)) ; assert_eq ! (- 1 , clamp (- 2 , - 1 , 2)) ; assert_eq ! (2 , clamp (3 , - 1 , 2)) ; assert_eq ! (1 , clamp_min (1 , - 1)) ; assert_eq ! (- 1 , clamp_min (- 2 , - 1)) ; assert_eq ! (- 1 , clamp_max (1 , - 1)) ; assert_eq ! (- 2 , clamp_max (- 2 , - 1)) ; assert_eq ! (1.0 , clamp (1.0 , - 1.0 , 2.0)) ; assert_eq ! (- 1.0 , clamp (- 2.0 , - 1.0 , 2.0)) ; assert_eq ! (2.0 , clamp (3.0 , - 1.0 , 2.0)) ; assert_eq ! (1.0 , clamp_min (1.0 , - 1.0)) ; assert_eq ! (- 1.0 , clamp_min (- 2.0 , - 1.0)) ; assert_eq ! (- 1.0 , clamp_max (1.0 , - 1.0)) ; assert_eq ! (- 2.0 , clamp_max (- 2.0 , - 1.0)) ; assert ! (clamp (:: core :: f32 :: NAN , - 1.0 , 1.0) . is_nan ()) ; assert ! (clamp_min (:: core :: f32 :: NAN , 1.0) . is_nan ()) ; assert ! (clamp_max (:: core :: f32 :: NAN , 1.0) . is_nan ()) ; } # [test] # [should_panic] # [cfg (debug_assertions)] fn clamp_nan_min () { clamp (0. , :: core :: f32 :: NAN , 1.) ; } # [test] # [should_panic] # [cfg (debug_assertions)] fn clamp_nan_max () { clamp (0. , - 1. , :: core :: f32 :: NAN) ; } # [test] # [should_panic] # [cfg (debug_assertions)] fn clamp_nan_min_max () { clamp (0. , :: core :: f32 :: NAN , :: core :: f32 :: NAN) ; } # [test] # [should_panic] # [cfg (debug_assertions)] fn clamp_min_nan_min () { clamp_min (0. , :: core :: f32 :: NAN) ; } # [test] # [should_panic] # [cfg (debug_assertions)] fn clamp_max_nan_max () { clamp_max (0. , :: core :: f32 :: NAN) ; } # [test] fn from_str_radix_unwrap () { let i : i32 = Num :: from_str_radix ("0" , 10) . unwrap () ; assert_eq ! (i , 0) ; let f : f32 = Num :: from_str_radix ("0.0" , 10) . unwrap () ; assert_eq ! (f , 0.0) ; } # [test] fn from_str_radix_multi_byte_fail () { assert ! (f32 :: from_str_radix ("0.2" , 10) . is_err ()) ; assert ! (f32 :: from_str_radix ("0.2E1" , 10) . is_err ()) ; } # [test] fn wrapping_is_num () { fn require_num < T : Num > (_ : & T) { } require_num (& Wrapping (42_u32)) ; require_num (& Wrapping (- 42)) ; } # [test] fn wrapping_from_str_radix () { macro_rules ! test_wrapping_from_str_radix { ($ ($ t : ty) +) => { $ (for & (s , r) in & [("42" , 10) , ("42" , 2) , ("-13.0" , 10) , ("foo" , 10)] { let w = Wrapping ::<$ t >:: from_str_radix (s , r) . map (| w | w . 0) ; assert_eq ! (w , <$ t as Num >:: from_str_radix (s , r)) ; }) + } ; } test_wrapping_from_str_radix ! (usize u8 u16 u32 u64 isize i8 i16 i32 i64) ; } # [test] fn check_num_ops () { fn compute < T : Num + Copy > (x : T , y : T) -> T { x * y / y % y + y - y } assert_eq ! (compute (1 , 2) , 1) } # [test] fn check_numref_ops () { fn compute < T : NumRef > (x : T , y : & T) -> T { x * y / y % y + y - y } assert_eq ! (compute (1 , & 2) , 1) } # [test] fn check_refnum_ops () { fn compute < T : Copy > (x : & T , y : T) -> T where for < 'a > & 'a T : RefNum < T > , { & (& (& (& (x * y) / y) % y) + y) - y } assert_eq ! (compute (& 1 , 2) , 1) } # [test] fn check_refref_ops () { fn compute < T > (x : & T , y : & T) -> T where for < 'a > & 'a T : RefNum < T > , { & (& (& (& (x * y) / y) % y) + y) - y } assert_eq ! (compute (& 1 , & 2) , 1) } # [test] fn check_numassign_ops () { fn compute < T : NumAssign + Copy > (mut x : T , y : T) -> T { x *= y ; x /= y ; x %= y ; x += y ; x -= y ; x } assert_eq ! (compute (1 , 2) , 1) } }mod proconio { # ! [allow (clippy :: needless_doctest_main , clippy :: print_literal)] # ! [doc = " Easy IO library for competitive programming."] # ! [doc = ""] # ! [doc = " `proconio` provides an easy way to read values from stdin (or other source).  The main is"] # ! [doc = " `input!` macro."] # ! [doc = ""] # ! [doc = " # Examples"] # ! [doc = ""] # ! [doc = " The macro's user interface is basically the same with [tanakh's input"] # ! [doc = " macro](https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8)."] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let source = AutoSource::from(\"32 54 -23\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from source,"] # ! [doc = "     n: u8,"] # ! [doc = "     m: u32,"] # ! [doc = "     l: i32,"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // now you can use n, m and l as variable."] # ! [doc = " println!(\"{} {} {}\", n, m, l);"] # ! [doc = " # assert_eq!(n, 32);"] # ! [doc = " # assert_eq!(m, 54);"] # ! [doc = " # assert_eq!(l, -23);"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " In above code, variables n, m and l are declared and stored values are read from stdin."] # ! [doc = ""] # ! [doc = " You can declare mutable variables like below:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let source = AutoSource::from(\"32 54\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from source,"] # ! [doc = "     n: u32,"] # ! [doc = "     mut m: u32,"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " m += n; // OK: m is mutable"] # ! [doc = " # assert_eq!(n, 32);"] # ! [doc = " # assert_eq!(m, 86);"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " You can read an array or a matrix like this:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let source = AutoSource::from(\"5 4 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #    from source,"] # ! [doc = "     n: usize,"] # ! [doc = "     m: usize,"] # ! [doc = "     a: [[i32; n]; m] // `a` is Vec<Vec<i32>>, (m, n)-matrix."] # ! [doc = " }"] # ! [doc = " # assert_eq!("] # ! [doc = " #     a,"] # ! [doc = " #     ["] # ! [doc = " #         [1, 2, 3, 4, 5],"] # ! [doc = " #         [1, 2, 3, 4, 5],"] # ! [doc = " #         [1, 2, 3, 4, 5],"] # ! [doc = " #         [1, 2, 3, 4, 5]"] # ! [doc = " #     ]"] # ! [doc = " # );"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " If the first input is the length of the array, you can omit the length.  This is the only way"] # ! [doc = " to read jagged array (an array of arrays of which the member arrays can be of different sizes)"] # ! [doc = " at once.  (Of course you can use `input!` multiple times in for-loop to read such an array"] # ! [doc = " since `input!` can be used multiple times.)"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let source = AutoSource::from(\"3 3 1 2 3 0 2 1 2\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from source,"] # ! [doc = "     n: usize,"] # ! [doc = "     a: [[i32]; n],"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // if you enter \"3  3 1 2 3  0  2 1 2\" to the stdin, the result is as follows."] # ! [doc = " assert_eq!("] # ! [doc = "     a,"] # ! [doc = "     vec!["] # ! [doc = "         vec![1, 2, 3],"] # ! [doc = "         vec![],"] # ! [doc = "         vec![1, 2],"] # ! [doc = "     ]"] # ! [doc = " );"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " Strings can be read as `Vec<u8>` or `Vec<char>`.  Use `Bytes` and `Chars` to do so:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " use proconio::marker::{Bytes, Chars};"] # ! [doc = " # let source = AutoSource::from(\"  string   chars\\nbytes\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #     from source,"] # ! [doc = "     string: String, // read as String"] # ! [doc = "     chars: Chars,   // read as Vec<char>"] # ! [doc = "     bytes: Bytes,   // read as Vec<u8>"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // if you enter \"string chars bytes\" to the stdin, they are like this."] # ! [doc = " assert_eq!(string, \"string\");"] # ! [doc = " assert_eq!(chars, ['c', 'h', 'a', 'r', 's']);"] # ! [doc = " assert_eq!(bytes, b\"bytes\");"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " You can read tuples:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let source = AutoSource::from(\"1 2 3 4 5\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from source,"] # ! [doc = "     t: (i32, i32, i32, i32, i32),"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // if you enter \"1 2 3 4 5\" to the stdin, `t` is like this."] # ! [doc = " assert_eq!(t, (1, 2, 3, 4, 5));"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " And you can freely combine these types."] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let source = AutoSource::from(\"4 3 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from source,"] # ! [doc = "     n: usize,"] # ! [doc = "     m: usize,"] # ! [doc = "     t: [([u32; m], i32); n],"] # ! [doc = " }"] # ! [doc = " # assert_eq!("] # ! [doc = " #     t,"] # ! [doc = " #     ["] # ! [doc = " #         (vec![1,1,1],1),"] # ! [doc = " #         (vec![2,2,2],2),"] # ! [doc = " #         (vec![3,3,3],3),"] # ! [doc = " #         (vec![4,4,4],4),"] # ! [doc = " #     ]"] # ! [doc = " # );"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " You can use `input!` macro multiple times.  For the second time, `input!` macro reads rest of"] # ! [doc = " input.  It works even if the first input stops at the middle of a line.  The subsequent reads"] # ! [doc = " will be started at the rest of the line.  This may be helpful for problems where multiple"] # ! [doc = " datasets are given once."] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " # let mut source = AutoSource::from(\"4 2 1 2 2 3 4 2 1 2 2 3 4\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from &mut source,"] # ! [doc = "     n: usize,"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " for i in 0..n {"] # ! [doc = "     input! {"] # ! [doc = " #       from &mut source,"] # ! [doc = "         m: usize,"] # ! [doc = "         a: [i32; m],"] # ! [doc = "     }"] # ! [doc = " #   assert_eq!(a[0], if i % 2 == 0 { 1 } else { 3 });"] # ! [doc = " #   assert_eq!(a[1], if i % 2 == 0 { 2 } else { 4 });"] # ! [doc = " }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " In addition to `Chars` and `Bytes`, `Usize1` and `Isize1` are also special types.  They are"] # ! [doc = " read as `usize` and `isize` respectively, but the read value is decremented.  It enables us to"] # ! [doc = " automatically convert 1-indexed vertices numbers to 0-indexed array indices."] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # extern crate proconio;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::input;"] # ! [doc = " use proconio::marker::Usize1;"] # ! [doc = " # let mut source = AutoSource::from(\"4   1 3   3 4   6 1   5 3\");"] # ! [doc = ""] # ! [doc = " input! {"] # ! [doc = " #   from &mut source,"] # ! [doc = "     n: usize,"] # ! [doc = "     edges: [(Usize1, Usize1); n],"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // if you enter \"4   1 3   3 4   6 1   5 3\", the decremented value is stored."] # ! [doc = " assert_eq!(edges[0], (0, 2));"] # ! [doc = " assert_eq!(edges[1], (2, 3));"] # ! [doc = " assert_eq!(edges[2], (5, 0));"] # ! [doc = " assert_eq!(edges[3], (4, 2));"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " `Usize1` and `Isize1` doesn't hold actual value, so you cannot have value of the type.  Thus,"] # ! [doc = " they are only useful inside `input!` or `#[derive_readable]`.  You can think the reason these"] # ! [doc = " types exist is to tell \"how to read the value\".  This how-to can be defined through `Readable`"] # ! [doc = " trait.  This trait doesn't require the output type to be the same with the implementor."] # ! [doc = " `Usize1` is implementing `Readable` trait, and there the type of read value is defined as"] # ! [doc = " `usize`.  You can implement `Readable` for your own type to read values in customized way."] # ! [doc = ""] # ! [doc = " Finally, you can make your own types `Readable` using `#[derive_readable]` attribute.  Types"] # ! [doc = " used in the struct are automatically translated to their output types, so a member declared as"] # ! [doc = " `Usize1` has type `usize` as real struct."] # ! [doc = ""] # ! [doc = " **Note:** Using `#[derive_readable]` requires `derive` feature enabled.  To do so, open your"] # ! [doc = " Cargo.toml and modify the line of proconio from:"] # ! [doc = ""] # ! [doc = " ```toml"] # ! [doc = " proconio = \"=(version)\""] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " to:"] # ! [doc = ""] # ! [doc = " ```toml"] # ! [doc = " proconio = { version = \"=(version)\", features = [\"derive\"] }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " Example of `#[derive_readable]`:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # #[cfg(feature = \"derive\")]"] # ! [doc = " # {"] # ! [doc = " # extern crate proconio;"] # ! [doc = " use proconio::input;"] # ! [doc = " # use proconio::source::auto::AutoSource;"] # ! [doc = " use proconio::derive_readable;"] # ! [doc = ""] # ! [doc = " // Unit struct can derive readable.  This generates a no-op for the reading.  Not ignoring"] # ! [doc = " // the read value, but simply skip reading process.  You cannot use it to discard the input."] # ! [doc = " #[derive_readable]"] # ! [doc = " #[derive(PartialEq, Debug)]"] # ! [doc = " struct Weight;"] # ! [doc = ""] # ! [doc = " #[derive_readable]"] # ! [doc = " #[derive(PartialEq, Debug)]"] # ! [doc = " struct Cost(i32);"] # ! [doc = ""] # ! [doc = " #[derive_readable]"] # ! [doc = " #[derive(Debug)]"] # ! [doc = " struct Edge {"] # ! [doc = "     from: usize,"] # ! [doc = "     to: proconio::marker::Usize1, // The real Edge::to has type usize."] # ! [doc = "     weight: Weight,"] # ! [doc = "     cost: Cost,"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " fn main() {"] # ! [doc = " #   let source = AutoSource::from(\"12 32 35\");"] # ! [doc = "     input! {"] # ! [doc = " #       from source,"] # ! [doc = "         edge: Edge,"] # ! [doc = "     }"] # ! [doc = ""] # ! [doc = "     // if you enter \"12 32 35\" to the stdin, the values are as follows."] # ! [doc = "     assert_eq!(edge.from, 12);"] # ! [doc = "     assert_eq!(edge.to, 31);"] # ! [doc = "     assert_eq!(edge.weight, Weight);"] # ! [doc = "     assert_eq!(edge.cost, Cost(35));"] # ! [doc = " }"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " # `#[fastout]`"] # ! [doc = ""] # ! [doc = " If you import `proconio::fastout`, you can use `#[fastout]` attribute.  Adding this attribute"] # ! [doc = " to your `main()`, your `print!` and `println!` become faster."] # ! [doc = ""] # ! [doc = " **Note:** Using `#[proconio::fastout]` requires `derive` feature enabled.  To do so, open your"] # ! [doc = " Cargo.toml and modify the line of proconio from:"] # ! [doc = ""] # ! [doc = " ```toml"] # ! [doc = " proconio = \"=(version)\""] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " to:"] # ! [doc = ""] # ! [doc = " ```toml"] # ! [doc = " proconio = { version = \"=(version)\", features = [\"derive\"] }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " Example of `#[fastout]`:"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # #[cfg(feature = \"derive\")]"] # ! [doc = " # {"] # ! [doc = " # extern crate proconio;"] # ! [doc = " use proconio::fastout;"] # ! [doc = ""] # ! [doc = " #[fastout]"] # ! [doc = " fn main() {"] # ! [doc = "     print!(\"{}{}, \", 'h', \"ello\"); // \"hello\"       (no newline)"] # ! [doc = "     println!(\"{}!\", \"world\");      // \"world!\\n\""] # ! [doc = "     println!(\"{}\", 123456789);     // \"123456789\\n\""] # ! [doc = " }"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " ## Closures having `print!` or `println!` in `#[fastout]` function"] # ! [doc = ""] # ! [doc = " You cannot create a closure containing `print!` or `println!` in `#[fastout]` function.  This"] # ! [doc = " is because the closure becomes thread-unsafe since the closure refers the unlocked stdout"] # ! [doc = " introduced by `#[fastout]` attribute.  If this were not prohibited, an invalid usage of such a"] # ! [doc = " closure would produce a very complex error messages.  For example, `std::thread::spawn()`,"] # ! [doc = " which requires its argument closure to be thread-safe, causes a confusing error."] # ! [doc = ""] # ! [doc = " Yes, it is too conservative to make all of such closures compilation error because it is"] # ! [doc = " actually no problem to use such a closure only inside a single thread.  This is related to a"] # ! [doc = " limitation in `#[fastout]` implementation."] # ! [doc = ""] # ! [doc = " For more technical details, see documentation for `#[fastout]` in `proconio-derive`."] # ! [doc = ""] # ! [doc = " ### How to resolve this error"] # ! [doc = ""] # ! [doc = " Consider you want to run this code:"] # ! [doc = ""] # ! [doc = " ```compile_fail"] # ! [doc = " use proconio::fastout;"] # ! [doc = ""] # ! [doc = " #[fastout]"] # ! [doc = " fn main() {"] # ! [doc = "     let thread = std::thread::spawn(|| {"] # ! [doc = "         let x = 3;"] # ! [doc = "         let y = x * x;"] # ! [doc = "         println!(\"{}\", y);"] # ! [doc = "     });"] # ! [doc = ""] # ! [doc = "     thread.join().unwrap();"] # ! [doc = " }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " You will get an error like below."] # ! [doc = ""] # ! [doc = " ```text"] # ! [doc = " error: Closures in a #[fastout] function cannot contain `print!` or `println!` macro"] # ! [doc = ""] # ! [doc = " note: If you want to run your entire logic in a thread having extended size of stack, you can"] # ! [doc = " define a new function instead.  See documentation (https://.....) for more details."] # ! [doc = ""] # ! [doc = " note: This is because if you use this closure with `std::thread::spawn()` or any other"] # ! [doc = " functions requiring `Send` for an argument closure, the compiler emits an error about thread"] # ! [doc = " unsafety for our internal implementations.  If you are using the closure just in a single"] # ! [doc = " thread, it's actually no problem, but we cannot check the trait bounds at the macro-expansion"] # ! [doc = " time.  So for now, all closures having `print!` or `println!` is prohibited regardless of the"] # ! [doc = " `Send` requirements."] # ! [doc = "  --> src/test.rs:10:9"] # ! [doc = "    |"] # ! [doc = " 10 |         println!(\"{}\", y);"] # ! [doc = "    |         ^^^^^^^"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " If your `print!` is relying on the calculation in the thread, you can instead return the result"] # ! [doc = " from the thread."] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # #[cfg(feature = \"derive\")]"] # ! [doc = " # {"] # ! [doc = " use proconio::fastout;"] # ! [doc = ""] # ! [doc = " #[fastout]"] # ! [doc = " fn main() {"] # ! [doc = "     let thread = std::thread::spawn(|| {"] # ! [doc = "         let x = 3;"] # ! [doc = "         x * x"] # ! [doc = "     });"] # ! [doc = ""] # ! [doc = "     let y = thread.join().unwrap();"] # ! [doc = " #   assert_eq!(y, 9);"] # ! [doc = "     println!(\"{}\", y);"] # ! [doc = " }"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " If you are doing so complex job that it's too difficult to returning the results from your"] # ! [doc = " closure..."] # ! [doc = ""] # ! [doc = " ```compile_fail"] # ! [doc = " use proconio::fastout;"] # ! [doc = ""] # ! [doc = " # fn some_function(_: String) -> impl Iterator<Item = String> { vec![\"hello\".to_string(), \"world\".to_string()].into_iter() }"] # ! [doc = " # fn some_proc(x: &str) -> &str { x }"] # ! [doc = ""] # ! [doc = " #[fastout]"] # ! [doc = " fn main() {"] # ! [doc = "     let context = \"some context\".to_string();"] # ! [doc = "     let thread = std::thread::spawn(move || {"] # ! [doc = "         // Use many println! and the order is very important"] # ! [doc = "         // It's possible to aggregate the result and print it later, but it's not easy to read"] # ! [doc = "         // and seems ugly."] # ! [doc = "         println!(\"this is header.\");"] # ! [doc = "         for (i, item) in some_function(context).enumerate() {"] # ! [doc = "             print!(\"Item #{}: \", i);"] # ! [doc = "             print!(\"{}\", some_proc(&item));"] # ! [doc = "             println!(\"({})\", item);"] # ! [doc = "         }"] # ! [doc = "     });"] # ! [doc = ""] # ! [doc = "     thread.join().unwrap();"] # ! [doc = " }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " ...you can use a function instead."] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # #[cfg(feature = \"derive\")]"] # ! [doc = " # {"] # ! [doc = " use proconio::fastout;"] # ! [doc = ""] # ! [doc = " # fn some_function(_: String) -> impl Iterator<Item = String> { vec![\"hello\".to_string(), \"world\".to_string()].into_iter() }"] # ! [doc = " # fn some_proc(x: &str) -> &str { x }"] # ! [doc = ""] # ! [doc = " // You can add #[fastout] here"] # ! [doc = " #[fastout]"] # ! [doc = " fn process(context: String) {"] # ! [doc = "     // It's completely OK since this #[fastout] is a thing inside `process()`"] # ! [doc = "     println!(\"this is header.\");"] # ! [doc = "     for (i, item) in some_function(context).enumerate() {"] # ! [doc = "         print!(\"Item #{}: \", i);"] # ! [doc = "         print!(\"{}\", some_proc(&item));"] # ! [doc = "         println!(\"({})\", item);"] # ! [doc = "     }"] # ! [doc = " }"] # ! [doc = ""] # ! [doc = " // You must not add #[fastout] here!  It causes deadlock."] # ! [doc = " // #[fastout]"] # ! [doc = " fn main() {"] # ! [doc = "     let context = \"some context\".to_string();"] # ! [doc = "     let thread = std::thread::spawn(move || process(context));"] # ! [doc = "     thread.join().unwrap();"] # ! [doc = " }"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " **Important Note:** If you *spawn a new thread* which runs another function annotated with"] # ! [doc = " `#[fastout]`, you must not add `#[fastout]` to the caller.  If you add `#[fastout]` in caller"] # ! [doc = " too, then the caller has the lock for the stdout, and so callee cannot acquire the lock forever"] # ! [doc = " --- deadlock.  This is not the case when the caller and callee is executed in the same thread,"] # ! [doc = " since the lock of stdout is reentrant.  We cannot warn about this kind of deadlock since we"] # ! [doc = " don't know annotations attached to the function to be called.  (In the above example, we can't"] # ! [doc = " know whether the function `process()` has `#[fastout]` attribute or not.)"] # ! [doc = ""] # ! [doc = " If your code is so complex that you cannot avoid deadlock, you should give up using"] # ! [doc = " `#[fastout]` and simply use `println!` or manually handle your stdout in usual Rust way."] # ! [doc = ""] # ! [doc = " ## Issues of printing order"] # ! [doc = ""] # ! [doc = " `#[fastout]` enables buffering to stdout, so if you print something in other functions between"] # ! [doc = " two prints in main, the order of printing may differ.  In other words, the below example"] # ! [doc = ""] # ! [doc = " ```"] # ! [doc = " # #[cfg(feature = \"derive\")]"] # ! [doc = " # {"] # ! [doc = " # use proconio::fastout;"] # ! [doc = " fn foo() { println!(\"between\"); }"] # ! [doc = " #[fastout]"] # ! [doc = " fn main() {"] # ! [doc = "     println!(\"hello\");"] # ! [doc = "     foo();"] # ! [doc = "     println!(\"world\");"] # ! [doc = " }"] # ! [doc = " # }"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " *likely* prints like"] # ! [doc = ""] # ! [doc = " ```text"] # ! [doc = " between"] # ! [doc = " hello"] # ! [doc = " world"] # ! [doc = " ```"] # ! [doc = ""] # ! [doc = " If you don't like this behavior, you can remove #[fastout] from your `main()`."] # ! [doc = ""] # [cfg (feature = "derive")] pub use proconio_derive :: * ; pub mod marker { # [doc = " Chars: read a string as array of chars."] pub enum Chars { } # [doc = " Bytes: read a string as array of bytes."] pub enum Bytes { } # [doc = " Usize1: 1-indexed usize.  Output of reading has type usize."] pub enum Usize1 { } # [doc = " Isize1: 1-indexed isize.  Output of reading has type isize."] pub enum Isize1 { } } pub mod read { use crate :: marker :: { Bytes , Chars , Isize1 , Usize1 } ; use crate :: source :: { Readable , Source } ; use std :: any :: type_name ; use std :: fmt :: Debug ; use std :: io :: BufRead ; use std :: str :: FromStr ; impl < T : FromStr > Readable for T where T :: Err : Debug , { type Output = T ; fn read < R : BufRead , S : Source < R > > (source : & mut S) -> T { let token = source . next_token_unwrap () ; match token . parse () { Ok (v) => v , Err (e) => panic ! (concat ! ("failed to parse the input `{input}` " , "to the value of type `{ty}`: {err:?}; " , "ensure that the input format is collectly specified " , "and that the input value must handle specified type." ,) , input = token , ty = type_name ::< T > () , err = e ,) , } } } impl Readable for Chars { type Output = Vec < char > ; fn read < R : BufRead , S : Source < R > > (source : & mut S) -> Vec < char > { source . next_token_unwrap () . chars () . collect () } } impl Readable for Bytes { type Output = Vec < u8 > ; fn read < R : BufRead , S : Source < R > > (source : & mut S) -> Vec < u8 > { source . next_token_unwrap () . bytes () . collect () } } impl Readable for Usize1 { type Output = usize ; fn read < R : BufRead , S : Source < R > > (source : & mut S) -> usize { usize :: read (source) - 1 } } impl Readable for Isize1 { type Output = isize ; fn read < R : BufRead , S : Source < R > > (source : & mut S) -> isize { isize :: read (source) - 1 } } } pub mod source { use std :: io :: BufRead ; pub mod line { use super :: Source ; use std :: io :: BufRead ; use std :: iter :: Peekable ; use std :: str :: SplitWhitespace ; # [doc = " Source reading stream line by line."] # [doc = ""] # [doc = " It is a wrapper for `BufRead`.  You can create `LineSource` from any type implementing"] # [doc = " `BufRead`."] pub struct LineSource < R : BufRead > { tokens : Peekable < SplitWhitespace < 'static > > , current_context : Box < str > , reader : R , } impl < R : BufRead > LineSource < R > { # [doc = " Creates a `LineSource` by specified `BufRead`."] pub fn new (reader : R) -> LineSource < R > { LineSource { current_context : "" . to_string () . into_boxed_str () , tokens : "" . split_whitespace () . peekable () , reader , } } fn prepare (& mut self) { while self . tokens . peek () . is_none () { let mut line = String :: new () ; let num_bytes = self . reader . read_line (& mut line) . expect ("failed to get linel maybe an IO error.") ; if num_bytes == 0 { return ; } self . current_context = line . into_boxed_str () ; self . tokens = unsafe { std :: mem :: transmute :: < _ , & 'static str > (& * self . current_context) } . split_whitespace () . peekable () ; } } } impl < R : BufRead > Source < R > for LineSource < R > { # [doc = " Gets a next token."] fn next_token (& mut self) -> Option < & str > { self . prepare () ; self . tokens . next () } # [doc = " Check if tokens are empty"] fn is_empty (& mut self) -> bool { self . prepare () ; self . tokens . peek () . is_none () } } use std :: io :: BufReader ; # [doc = " You can create `LineSource` from `&str`.  Since `&[u8]` is a `Read`, `BufRead` can be easily"] # [doc = " created by wrapping using `BufReader`."] impl < 'a > From < & 'a str > for LineSource < BufReader < & 'a [u8] > > { fn from (s : & 'a str) -> LineSource < BufReader < & 'a [u8] > > { LineSource :: new (BufReader :: new (s . as_bytes ())) } } } pub mod once { use super :: Source ; use std :: io :: BufRead ; use std :: iter :: Peekable ; use std :: marker :: PhantomData ; use std :: str :: SplitWhitespace ; # [doc = " Source reading entire content for the first time."] # [doc = ""] # [doc = " It is a wrapper for `BufRead`.  You can create `OnceSource` from any type implementing"] # [doc = " `BufRead`."] pub struct OnceSource < R : BufRead > { tokens : Peekable < SplitWhitespace < 'static > > , context : Box < str > , _read : PhantomData < R > , } impl < R : BufRead > OnceSource < R > { # [doc = " Creates `Source` using specified reader of `BufRead`."] pub fn new (mut source : R) -> OnceSource < R > { let mut context = String :: new () ; source . read_to_string (& mut context) . expect ("failed to read from source; maybe an IO error.") ; let context = context . into_boxed_str () ; let mut res = OnceSource { context , tokens : "" . split_whitespace () . peekable () , _read : PhantomData , } ; use std :: mem ; let context : & 'static str = unsafe { mem :: transmute (& * res . context) } ; res . tokens = context . split_whitespace () . peekable () ; res } } impl < R : BufRead > Source < R > for OnceSource < R > { # [doc = " Gets a next token."] fn next_token (& mut self) -> Option < & str > { self . tokens . next () } # [doc = " Check if tokens are empty"] fn is_empty (& mut self) -> bool { self . tokens . peek () . is_none () } } use std :: io :: BufReader ; # [doc = " You can create `LineSource` from `&str`.  Since `&[u8]` is a `Read`, `BufRead` can be easily"] # [doc = " created by wrapping using `BufReader`."] impl < 'a > From < & 'a str > for OnceSource < BufReader < & 'a [u8] > > { fn from (s : & 'a str) -> OnceSource < BufReader < & 'a [u8] > > { OnceSource :: new (BufReader :: new (s . as_bytes ())) } } } pub mod auto { # ! [doc = " Defines `AutoSource`."] # ! [doc = ""] # ! [doc = " It is `LineSource` for debug build, `OnceSource` for release build."] # [cfg (debug_assertions)] pub use super :: line :: LineSource as AutoSource ; # [cfg (not (debug_assertions))] pub use super :: once :: OnceSource as AutoSource ; } # [doc = " The main trait. Types implementing this trait can be used for source of `input!` macro."] pub trait Source < R : BufRead > { # [doc = " Gets a whitespace-splitted next token."] fn next_token (& mut self) -> Option < & str > ; # [doc = " Check if tokens are empty"] fn is_empty (& mut self) -> bool ; # [doc = " Force gets a whitespace-splitted next token."] fn next_token_unwrap (& mut self) -> & str { self . next_token () . expect (concat ! ("failed to get the next token; " , "maybe reader reached an end of input. " , "ensure that arguments for `input!` macro is correctly " , "specified to match the problem input.")) } } impl < R : BufRead , S : Source < R > > Source < R > for & '_ mut S { fn next_token (& mut self) -> Option < & str > { (* self) . next_token () } fn is_empty (& mut self) -> bool { (* self) . is_empty () } } # [doc = " A trait representing which type can be read from `Source`."] # [doc = ""] # [doc = " If you want to read your own type using `input!`, you can implement this trait for your type."] # [doc = " Alternatively, you can add `#[derive_readable]` if you put `use"] # [doc = " proconio_derive::derive_readable` in your source.  It automatically implements `Readable` if"] # [doc = " all members of your type are `Readable`."] pub trait Readable { type Output ; fn read < R : BufRead , S : Source < R > > (source : & mut S) -> Self :: Output ; } } use crate :: source :: auto :: AutoSource ; use lazy_static :: lazy_static ; use std :: io ; use std :: io :: { BufReader , Stdin } ; use std :: sync :: Mutex ; lazy_static ! { # [doc (hidden)] pub static ref STDIN_SOURCE : Mutex < AutoSource < BufReader < Stdin >>> = Mutex :: new (AutoSource :: new (BufReader :: new (io :: stdin ()))) ; } # [doc = " read input from stdin."] # [doc = ""] # [doc = " basic syntax is:"] # [doc = " ```text"] # [doc = " input! {"] # [doc = "     from source,          // optional: if you omitted, stdin is used by default."] # [doc = "     (mut) variable: type, // mut is optional: mut makes the variable mutable."] # [doc = "     ..."] # [doc = " }"] # [doc = " ```"] # [doc = " the trailing comma is optional.  `source` can be anything implementing `Source`.  This macro"] # [doc = " moves out the specified source.  If you want to prevent moving, you can use `&mut source` since"] # [doc = " `&mut S` where `S: Source` also implements `Source`."] # [macro_export] macro_rules ! input { (@ from [$ source : expr] @ rest) => { } ; (@ from [$ source : expr] @ rest mut $ ($ rest : tt) *) => { $ crate :: input ! { @ from [$ source] @ mut [mut] @ rest $ ($ rest) * } } ; (@ from [$ source : expr] @ rest $ ($ rest : tt) *) => { $ crate :: input ! { @ from [$ source] @ mut [] @ rest $ ($ rest) * } } ; (@ from [$ source : expr] @ mut [$ ($ mut : tt) ?] @ rest $ var : tt : $ ($ rest : tt) *) => { $ crate :: input ! { @ from [$ source] @ mut [$ ($ mut) *] @ var $ var @ kind [] @ rest $ ($ rest) * } } ; (@ from [$ source : expr] @ mut [$ ($ mut : tt) ?] @ var $ var : tt @ kind [$ ($ kind : tt) *] @ rest) => { let $ ($ mut) * $ var = $ crate :: read_value ! (@ source [$ source] @ kind [$ ($ kind) *]) ; } ; (@ from [$ source : expr] @ mut [$ ($ mut : tt) ?] @ var $ var : tt @ kind [$ ($ kind : tt) *] @ rest , $ ($ rest : tt) *) => { $ crate :: input ! (@ from [$ source] @ mut [$ ($ mut) *] @ var $ var @ kind [$ ($ kind) *] @ rest) ; $ crate :: input ! (@ from [$ source] @ rest $ ($ rest) *) ; } ; (@ from [$ source : expr] @ mut [$ ($ mut : tt) ?] @ var $ var : tt @ kind [$ ($ kind : tt) *] @ rest $ tt : tt $ ($ rest : tt) *) => { $ crate :: input ! (@ from [$ source] @ mut [$ ($ mut) *] @ var $ var @ kind [$ ($ kind) * $ tt] @ rest $ ($ rest) *) ; } ; (from $ source : expr , $ ($ rest : tt) *) => { # [allow (unused_variables , unused_mut)] let mut s = $ source ; $ crate :: input ! { @ from [& mut s] @ rest $ ($ rest) * } } ; ($ ($ rest : tt) *) => { let mut locked_stdin = $ crate :: STDIN_SOURCE . lock () . expect (concat ! ("failed to lock the stdin; please re-run this program.  " , "If this issue repeatedly occur, this is a bug in `proconio`.  " , "Please report this issue from " , "<https://github.com/statiolake/proconio-rs/issues>.")) ; $ crate :: input ! { @ from [& mut * locked_stdin] @ rest $ ($ rest) * } drop (locked_stdin) ; } ; } # [doc (hidden)] # [macro_export] macro_rules ! read_value { (@ source [$ source : expr] @ kind [[$ ($ kind : tt) *]]) => { $ crate :: read_value ! (@ array @ source [$ source] @ kind [] @ rest $ ($ kind) *) } ; (@ array @ source [$ source : expr] @ kind [$ ($ kind : tt) *] @ rest) => { { let len = < usize as $ crate :: source :: Readable >:: read ($ source) ; $ crate :: read_value ! (@ source [$ source] @ kind [[$ ($ kind) *; len]]) } } ; (@ array @ source [$ source : expr] @ kind [$ ($ kind : tt) *] @ rest ; $ ($ rest : tt) *) => { $ crate :: read_value ! (@ array @ source [$ source] @ kind [$ ($ kind) *] @ len [$ ($ rest) *]) } ; (@ array @ source [$ source : expr] @ kind [$ ($ kind : tt) *] @ rest $ tt : tt $ ($ rest : tt) *) => { $ crate :: read_value ! (@ array @ source [$ source] @ kind [$ ($ kind) * $ tt] @ rest $ ($ rest) *) } ; (@ array @ source [$ source : expr] @ kind [$ ($ kind : tt) *] @ len [$ ($ len : tt) *]) => { { let len = $ ($ len) *; (0 .. len) . map (| _ | $ crate :: read_value ! (@ source [$ source] @ kind [$ ($ kind) *])) . collect ::< Vec < _ >> () } } ; (@ source [$ source : expr] @ kind [($ ($ kinds : tt) *)]) => { $ crate :: read_value ! (@ tuple @ source [$ source] @ kinds [] @ current [] @ rest $ ($ kinds) *) } ; (@ tuple @ source [$ source : expr] @ kinds [$ ([$ ($ kind : tt) *]) *] @ current [] @ rest) => { ($ ($ crate :: read_value ! (@ source [$ source] @ kind [$ ($ kind) *]) ,) *) } ; (@ tuple @ source [$ source : expr] @ kinds [$ ($ kinds : tt) *] @ current [$ ($ curr : tt) *] @ rest) => { $ crate :: read_value ! (@ tuple @ source [$ source] @ kinds [$ ($ kinds) * [$ ($ curr) *]] @ current [] @ rest) } ; (@ tuple @ source [$ source : expr] @ kinds [$ ($ kinds : tt) *] @ current [$ ($ curr : tt) *] @ rest , $ ($ rest : tt) *) => { $ crate :: read_value ! (@ tuple @ source [$ source] @ kinds [$ ($ kinds) * [$ ($ curr) *]] @ current [] @ rest $ ($ rest) *) } ; (@ tuple @ source [$ source : expr] @ kinds [$ ($ kinds : tt) *] @ current [$ ($ curr : tt) *] @ rest $ tt : tt $ ($ rest : tt) *) => { $ crate :: read_value ! (@ tuple @ source [$ source] @ kinds [$ ($ kinds) *] @ current [$ ($ curr) * $ tt] @ rest $ ($ rest) *) } ; (@ source [$ source : expr] @ kind []) => { compile_error ! (concat ! ("Reached unreachable statement while parsing macro input.  " , "This is a bug in `proconio`.  " , "Please report this issue from " , "<https://github.com/statiolake/proconio-rs/issues>.")) ; } ; (@ source [$ source : expr] @ kind [$ kind : ty]) => { <$ kind as $ crate :: source :: Readable >:: read ($ source) } } # [doc = " Checks if some of tokens are left on stdin."] # [doc = ""] # [doc = " This is useful when the number of test cases is not specified like ICPC problems."] # [doc = ""] # [doc = " ```text"] # [doc = " loop {"] # [doc = "     if is_stdin_empty() {"] # [doc = "         break;"] # [doc = "     }"] # [doc = ""] # [doc = "     // do the normal logic"] # [doc = "     input! { ... }"] # [doc = " }"] # [doc = " ```"] pub fn is_stdin_empty () -> bool { use crate :: source :: Source ; let mut lock = STDIN_SOURCE . lock () . expect (concat ! ("failed to lock the stdin; please re-run this program.  " , "If this issue repeatedly occur, this is a bug in `proconio`.  " , "Please report this issue from " , "<https://github.com/statiolake/proconio-rs/issues>.")) ; lock . is_empty () } # [cfg (test)] mod tests { use crate :: source :: auto :: AutoSource ; # [test] fn input_empty () { let source = AutoSource :: from ("") ; input ! { from source , } } # [test] fn input_number () { let source = AutoSource :: from ("    32   54 -23\r\r\n\nfalse") ; input ! { from source , n : u8 , m : u32 , l : i32 , } assert_eq ! (n , 32) ; assert_eq ! (m , 54) ; assert_eq ! (l , - 23) ; } # [test] fn input_str () { use crate :: marker :: { Bytes , Chars } ; let source = AutoSource :: from ("  string   chars\nbytes") ; input ! { from source , string : String , chars : Chars , bytes : Bytes , } assert_eq ! (string , "string") ; assert_eq ! (chars , ['c' , 'h' , 'a' , 'r' , 's']) ; assert_eq ! (bytes , b"bytes") ; } # [test] fn input_array () { let source = AutoSource :: from ("5 3 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5") ; input ! { from source , n : usize , m : usize , a : [i32 ; n] , b : [[i32 ; n] ; m] } assert_eq ! (a , [1 , 2 , 3 , 4 , 5]) ; assert_eq ! (b , [[1 , 2 , 3 , 4 , 5] , [1 , 2 , 3 , 4 , 5] , [1 , 2 , 3 , 4 , 5]]) ; } # [test] fn input_vla () { let source = AutoSource :: from ("5 3 1 2 3 2 1 2 4 1 2 3 4 0 6 1 2 3 4 5 6") ; input ! { from source , n : usize , a : [[i32] ; n] , } assert_eq ! (a , vec ! [vec ! [1 , 2 , 3] , vec ! [1 , 2] , vec ! [1 , 2 , 3 , 4] , vec ! [] , vec ! [1 , 2 , 3 , 4 , 5 , 6] ,]) ; } # [test] fn input_tuple () { let source = AutoSource :: from ("4 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5") ; input ! { from source , n : usize , t : [(i32 , i32 , i32 , i32 , i32) ; n] , } assert_eq ! (t , [(1 , 2 , 3 , 4 , 5) , (1 , 2 , 3 , 4 , 5) , (1 , 2 , 3 , 4 , 5) , (1 , 2 , 3 , 4 , 5)]) ; } # [test] fn input_multiple_times () { let mut source = AutoSource :: from ("4 1 2 3 4\n1 2\r\n\r\r\n3 4") ; input ! { from & mut source , n : usize , } for i in 0 .. n { input ! { from & mut source , j : i32 , k : i32 , } assert_eq ! (j , if i % 2 == 0 { 1 } else { 3 }) ; assert_eq ! (k , if i % 2 == 0 { 2 } else { 4 }) ; } } # [test] fn input_iusize1 () { use crate :: marker :: Usize1 ; let mut source = AutoSource :: from ("4 1 2 3 4 5 6 7 8") ; input ! { from & mut source , n : usize , } for i in 0 .. n { input ! { from & mut source , from : Usize1 , to : Usize1 } assert_eq ! (from , i * 2) ; assert_eq ! (to , i * 2 + 1) ; } } # [test] fn input_mut () { let mut source = AutoSource :: from ("8 1 2 3 4 5 6 7 8") ; input ! { from & mut source , mut n : usize , } let mut sum = 0 ; while n > 0 { input ! (from & mut source , x : u32) ; sum += x ; n -= 1 ; } assert_eq ! (sum , 36) ; } # [test] fn input_with_complex_type () { let mut source = AutoSource :: from ("Hello\n2\n3 1 2 3\n4 5 ab\n4") ; input ! { from & mut source , hello : crate :: marker :: Bytes , from : crate :: marker :: Usize1 , vla : [crate :: marker :: Isize1] , tuple : (crate :: marker :: Usize1 , crate :: marker :: Isize1 , crate :: marker :: Chars) , unit : (crate :: marker :: Usize1) , } assert_eq ! (hello , b"Hello") ; assert_eq ! (from , 1) ; assert_eq ! (vla , [0 , 1 , 2]) ; assert_eq ! (tuple , (3 , 4 , vec ! ['a' , 'b'])) ; assert_eq ! (unit , (3 ,)) ; } # [test] fn input_single_tt_pattern () { let mut source = AutoSource :: from ("3 42 0\n1 2 3\n") ; input ! { from & mut source , (n , mut k) : (usize , usize) , _ : usize , xs : [u32 ; n] , } k += 1 ; assert_eq ! (n , 3) ; assert_eq ! (k , 43) ; assert_eq ! (xs , [1 , 2 , 3]) ; } # [test] # [should_panic] fn input_err_different_type () { let mut source = AutoSource :: from ("3.2\n") ; input ! { from & mut source , _n : i32 , } } # [test] # [should_panic] fn input_err_different_format () { let mut source = AutoSource :: from ("") ; input ! { from & mut source , _n : i32 , } } } }mod superslice { # ! [doc = " This crate provides extensions for [`slice`]s."] # ! [doc = " "] # ! [doc = " # Examples"] # ! [doc = " "] # ! [doc = " ```"] # ! [doc = " use superslice::*;"] # ! [doc = " "] # ! [doc = " let b = [1, 3];"] # ! [doc = " "] # ! [doc = " assert_eq!(b.lower_bound(&1), 0);"] # ! [doc = " "] # ! [doc = " assert_eq!(b.upper_bound(&1), 1);"] # ! [doc = " "] # ! [doc = " assert_eq!(b.equal_range(&3), 1..2);"] # ! [doc = " ```"] # ! [doc = " "] # ! [doc = " [`slice`]: https://doc.rust-lang.org/stable/std/primitive.slice.html"] use std :: cmp :: Ordering :: { self , Less , Greater } ; # [doc = " Extends [`slice`] with fast operations on ordered slices."] # [doc = " "] # [doc = " [`slice`]: https://doc.rust-lang.org/stable/std/primitive.slice.html"] pub trait Ext { type Item ; # [doc = " Returns the index `i` pointing to the first element in the ordered slice"] # [doc = " that is _not less_ than `x`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by its elements."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let a = [10, 11, 13, 13, 15];"] # [doc = " assert_eq!(a.lower_bound(&9), 0);"] # [doc = " assert_eq!(a.lower_bound(&10), 0);"] # [doc = " assert_eq!(a.lower_bound(&11), 1);"] # [doc = " assert_eq!(a.lower_bound(&12), 2);"] # [doc = " assert_eq!(a.lower_bound(&13), 2);"] # [doc = " assert_eq!(a.lower_bound(&14), 4);"] # [doc = " assert_eq!(a.lower_bound(&15), 4);"] # [doc = " assert_eq!(a.lower_bound(&16), 5);"] # [doc = " ```"] fn lower_bound (& self , x : & Self :: Item) -> usize where Self :: Item : Ord ; # [doc = " Returns the index `i` pointing to the first element in the ordered slice"] # [doc = " for which `f(self[i]) != Less`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by the comparator"] # [doc = " function. The comparator function should take an element and return"] # [doc = " `Ordering` that is consistent with the ordering of the slice."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [1, 2, 3, 6, 9, 9];"] # [doc = " assert_eq!(b.lower_bound(&3), b.lower_bound_by(|x| x.cmp(&3)));"] # [doc = " ```"] fn lower_bound_by < 'a , F > (& 'a self , f : F) -> usize where F : FnMut (& 'a Self :: Item) -> Ordering ; # [doc = " Returns the index `i` pointing to the first element in the ordered slice"] # [doc = " for which `f(self[i]) >= k`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by the keys of its"] # [doc = " elements."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [1, 2, 3, 6, 9, 9];"] # [doc = " assert_eq!(b.lower_bound(&3), b.lower_bound_by_key(&6, |x| x * 2));"] # [doc = " ```"] fn lower_bound_by_key < 'a , K , F > (& 'a self , k : & K , f : F) -> usize where F : FnMut (& 'a Self :: Item) -> K , K : Ord ; # [doc = " Returns the index `i` pointing to the first element in the ordered slice"] # [doc = " that is _greater_ than `x`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by its elements."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let a = [10, 11, 13, 13, 15];"] # [doc = " assert_eq!(a.upper_bound(&9), 0);"] # [doc = " assert_eq!(a.upper_bound(&10), 1);"] # [doc = " assert_eq!(a.upper_bound(&11), 2);"] # [doc = " assert_eq!(a.upper_bound(&12), 2);"] # [doc = " assert_eq!(a.upper_bound(&13), 4);"] # [doc = " assert_eq!(a.upper_bound(&14), 4);"] # [doc = " assert_eq!(a.upper_bound(&15), 5);"] # [doc = " assert_eq!(a.upper_bound(&16), 5);"] # [doc = " ```"] fn upper_bound (& self , x : & Self :: Item) -> usize where Self :: Item : Ord ; # [doc = " Returns the index `i` pointing to the first element in the ordered slice"] # [doc = " for which `f(self[i]) == Greater`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by the comparator"] # [doc = " function. The comparator function should take an element and return"] # [doc = " `Ordering` that is consistent with the ordering of the slice."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [1, 2, 3, 6, 9, 9];"] # [doc = " assert_eq!(b.upper_bound(&3), b.upper_bound_by(|x| x.cmp(&3)));"] # [doc = " ```"] fn upper_bound_by < 'a , F > (& 'a self , f : F) -> usize where F : FnMut (& 'a Self :: Item) -> Ordering ; # [doc = " Returns the index `i` pointing to the first element in the ordered slice"] # [doc = " for which `f(self[i]) > k`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by the keys of its"] # [doc = " elements."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [1, 2, 3, 6, 9, 9];"] # [doc = " assert_eq!(b.lower_bound(&3), b.lower_bound_by_key(&6, |x| x * 2));"] fn upper_bound_by_key < 'a , K , F > (& 'a self , k : & K , f : F) -> usize where F : FnMut (& 'a Self :: Item) -> K , K : Ord ; # [doc = " Returns the [`Range`] `a..b` such that all elements in `self[a..b]` are"] # [doc = " _equal_ to `x`."] # [doc = " "] # [doc = " The slice MUST be ordered by the order defined by its elements."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [10, 11, 13, 13, 15];"] # [doc = " for i in 9..17 {"] # [doc = "     assert_eq!(b.equal_range(&i), (b.lower_bound(&i)..b.upper_bound(&i)));"] # [doc = " }"] # [doc = " ```"] # [doc = " [`Range`]: https://doc.rust-lang.org/stable/std/ops/struct.Range.html"] fn equal_range (& self , x : & Self :: Item) -> std :: ops :: Range < usize > where Self :: Item : Ord ; # [doc = " Returns the [`Range`] `a..b` such that for all elements `e` in `self[a..b]` "] # [doc = " `f(e) == Equal`."] # [doc = ""] # [doc = " The slice MUST be ordered by the order defined by the comparator"] # [doc = " function. The comparator function should take an element and return"] # [doc = " `Ordering` that is consistent with the ordering of the slice."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [10, 11, 13, 13, 15];"] # [doc = " for i in 9..17 {"] # [doc = "     assert_eq!(b.equal_range(&i), b.equal_range_by(|x| x.cmp(&i)));"] # [doc = " }"] # [doc = " ```"] # [doc = " [`Range`]: https://doc.rust-lang.org/stable/std/ops/struct.Range.html"] fn equal_range_by < 'a , F > (& 'a self , f : F) -> std :: ops :: Range < usize > where F : FnMut (& 'a Self :: Item) -> Ordering ; # [doc = " Returns the [`Range`] `a..b` such that for all elements `e` in `self[a..b]` "] # [doc = " `f(e) == k`."] # [doc = ""] # [doc = " The slice MUST be ordered by the order defined by the keys of its"] # [doc = " elements."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let b = [10, 11, 13, 13, 15];"] # [doc = " for i in 9..17 {"] # [doc = "     let i2 = i * 2;"] # [doc = "     assert_eq!(b.equal_range(&i), b.equal_range_by_key(&i2, |x| x * 2));"] # [doc = " }"] # [doc = " ```"] # [doc = " [`Range`]: https://doc.rust-lang.org/stable/std/ops/struct.Range.html"] fn equal_range_by_key < 'a , K , F > (& 'a self , k : & K , f : F) -> std :: ops :: Range < usize > where F : FnMut (& 'a Self :: Item) -> K , K : Ord ; # [doc = " Transforms the slice into the next permutation from the set of all"] # [doc = " permutations that are lexicographically ordered with respect to the"] # [doc = " natural order of T. Returns true if such permutation exists, otherwise"] # [doc = " transforms the range into the first permutation and returns false."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let mut b = [2, 1, 3];"] # [doc = " let mut v = Vec::new();"] # [doc = " for _ in 0..6 {"] # [doc = "     let x = b.next_permutation();"] # [doc = "     v.push((x, b.to_vec()));"] # [doc = " }"] # [doc = " assert_eq!(v, &[(true, [2, 3, 1].to_vec()),"] # [doc = "                 (true, [3, 1, 2].to_vec()),"] # [doc = "                 (true, [3, 2, 1].to_vec()),"] # [doc = "                 (false, [1, 2, 3].to_vec()),"] # [doc = "                 (true, [1, 3, 2].to_vec()),"] # [doc = "                 (true, [2, 1, 3].to_vec())]);"] fn next_permutation (& mut self) -> bool where Self :: Item : Ord ; # [doc = " Transforms the slice into the previous permutation from the set of all"] # [doc = " permutations that are lexicographically ordered with respect to the"] # [doc = " natural order of T. Returns true if such permutation exists, otherwise"] # [doc = " transforms the range into the last permutation and returns false."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let mut b = [2, 1, 3];"] # [doc = " let mut v = Vec::new();"] # [doc = " for _ in 0..6 {"] # [doc = "     let x = b.prev_permutation();"] # [doc = "     v.push((x, b.to_vec()));"] # [doc = " }"] # [doc = " assert_eq!(v, &[(true, [1, 3, 2].to_vec()),"] # [doc = "                 (true, [1, 2, 3].to_vec()),"] # [doc = "                 (false, [3, 2, 1].to_vec()),"] # [doc = "                 (true, [3, 1, 2].to_vec()),"] # [doc = "                 (true, [2, 3, 1].to_vec()),"] # [doc = "                 (true, [2, 1, 3].to_vec())]);"] fn prev_permutation (& mut self) -> bool where Self :: Item : Ord ; # [doc = " Applies `permutation` to the slice. For each element at index `i` the"] # [doc = " following holds:"] # [doc = " "] # [doc = "   new_self[i] == old_self[permutation[i]]"] # [doc = ""] # [doc = " The transformation happens in O(N) time and O(1) space. `permutation`"] # [doc = " is mutated during the transformation but it is restored to its original"] # [doc = " state on return."] # [doc = " "] # [doc = " # Panics"] # [doc = " "] # [doc = " This function panics if `self` and `permutation` do not have the same"] # [doc = " length or any value in `permutation` is not in `0..self.len()`."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let mut b = ['d', 'a', 'c', 'b'];"] # [doc = " let mut p = [1, 3, 2, 0];"] # [doc = " b.apply_permutation(&mut p);"] # [doc = " assert_eq!(b, ['a', 'b', 'c', 'd']);"] # [doc = " assert_eq!(p, [1, 3, 2, 0]);"] fn apply_permutation (& mut self , permutation : & mut [isize]) ; # [doc = " Applies the inverse of `permutation` to the slice. For each element at"] # [doc = " index `i` the following holds:"] # [doc = " "] # [doc = "   new_self[permutation[i]] == old_self[i]"] # [doc = ""] # [doc = " The transformation happens in O(N) time and O(1) space. `permutation`"] # [doc = " is mutated during the transformation but it is restored to its original"] # [doc = " state on return."] # [doc = " "] # [doc = " # Panics"] # [doc = " "] # [doc = " This function panics if `self` and `permutation` do not have the same"] # [doc = " length or any value in `permutation` is not in `0..self.len()`."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let mut b = ['d', 'a', 'c', 'b'];"] # [doc = " let mut p = [3, 0, 2, 1];"] # [doc = " b.apply_inverse_permutation(&mut p);"] # [doc = " assert_eq!(b, ['a', 'b', 'c', 'd']);"] # [doc = " assert_eq!(p, [3, 0, 2, 1]);"] fn apply_inverse_permutation (& mut self , permutation : & mut [isize]) ; } impl < T > Ext for [T] { type Item = T ; fn lower_bound (& self , x : & Self :: Item) -> usize where T : Ord , { self . lower_bound_by (| y | y . cmp (x)) } fn lower_bound_by < 'a , F > (& 'a self , mut f : F) -> usize where F : FnMut (& 'a Self :: Item) -> Ordering , { let s = self ; let mut size = s . len () ; if size == 0 { return 0 ; } let mut base = 0usize ; while size > 1 { let half = size / 2 ; let mid = base + half ; let cmp = f (unsafe { s . get_unchecked (mid) }) ; base = if cmp == Less { mid } else { base } ; size -= half ; } let cmp = f (unsafe { s . get_unchecked (base) }) ; base + (cmp == Less) as usize } fn lower_bound_by_key < 'a , K , F > (& 'a self , k : & K , mut f : F) -> usize where F : FnMut (& 'a Self :: Item) -> K , K : Ord , { self . lower_bound_by (| e | f (e) . cmp (k)) } fn upper_bound (& self , x : & Self :: Item) -> usize where T : Ord , { self . upper_bound_by (| y | y . cmp (x)) } fn upper_bound_by < 'a , F > (& 'a self , mut f : F) -> usize where F : FnMut (& 'a Self :: Item) -> Ordering , { let s = self ; let mut size = s . len () ; if size == 0 { return 0 ; } let mut base = 0usize ; while size > 1 { let half = size / 2 ; let mid = base + half ; let cmp = f (unsafe { s . get_unchecked (mid) }) ; base = if cmp == Greater { base } else { mid } ; size -= half ; } let cmp = f (unsafe { s . get_unchecked (base) }) ; base + (cmp != Greater) as usize } fn upper_bound_by_key < 'a , K , F > (& 'a self , k : & K , mut f : F) -> usize where F : FnMut (& 'a Self :: Item) -> K , K : Ord , { self . upper_bound_by (| e | f (e) . cmp (k)) } fn equal_range (& self , x : & Self :: Item) -> std :: ops :: Range < usize > where T : Ord , { self . equal_range_by (| y | y . cmp (x)) } fn equal_range_by < 'a , F > (& 'a self , mut f : F) -> std :: ops :: Range < usize > where F : FnMut (& 'a Self :: Item) -> Ordering , { let s = self ; let mut size = s . len () ; if size == 0 { return 0 .. 0 ; } let mut base = (0usize , 0usize) ; while size > 1 { let half = size / 2 ; let mid = (base . 0 + half , base . 1 + half) ; let cmp = (f (unsafe { s . get_unchecked (mid . 0) }) , f (unsafe { s . get_unchecked (mid . 1) }) ,) ; base = (if cmp . 0 == Less { mid . 0 } else { base . 0 } , if cmp . 1 == Greater { base . 1 } else { mid . 1 } ,) ; size -= half ; } let cmp = (f (unsafe { s . get_unchecked (base . 0) }) , f (unsafe { s . get_unchecked (base . 1) }) ,) ; (base . 0 + (cmp . 0 == Less) as usize .. base . 1 + (cmp . 1 != Greater) as usize) } fn equal_range_by_key < 'a , K , F > (& 'a self , k : & K , mut f : F) -> std :: ops :: Range < usize > where F : FnMut (& 'a Self :: Item) -> K , K : Ord , { self . equal_range_by (| e | f (e) . cmp (k)) } fn next_permutation (& mut self) -> bool where Self :: Item : Ord { if self . len () <= 1 { return false ; } let last = self . len () - 1 ; let mut a = last ; loop { let mut b = a ; a -= 1 ; if self [a] < self [b] { b = last ; while self [a] >= self [b] { b -= 1 ; } self . swap (a , b) ; self [a + 1 ..] . reverse () ; return true ; } if a == 0 { self . reverse () ; return false ; } } } fn prev_permutation (& mut self) -> bool where Self :: Item : Ord { if self . len () <= 1 { return false ; } let last = self . len () - 1 ; let mut a = last ; loop { let mut b = a ; a -= 1 ; if self [b] < self [a] { b = last ; while self [b] >= self [a] { b -= 1 ; } self . swap (a , b) ; self [a + 1 ..] . reverse () ; return true ; } if a == 0 { self . reverse () ; return false ; } } } fn apply_permutation (& mut self , perm : & mut [isize]) { assert_eq ! (self . len () , perm . len ()) ; assert ! (self . len () < isize :: max_value () as usize) ; for i in 0 .. self . len () as isize { let mut c = perm [i as usize] ; if c < 0 { perm [i as usize] = ! c ; } else if i != c { loop { let n = perm [c as usize] ; self . swap (c as usize , n as usize) ; perm [c as usize] = ! n ; c = n ; if i == c { break ; } } } } } fn apply_inverse_permutation (& mut self , perm : & mut [isize]) { assert_eq ! (self . len () , perm . len ()) ; assert ! (self . len () < isize :: max_value () as usize) ; for i in 0 .. self . len () as isize { let mut c = perm [i as usize] ; if c < 0 { perm [i as usize] = ! c ; } else if i != c { loop { self . swap (c as usize , i as usize) ; let n = perm [c as usize] ; perm [c as usize] = ! n ; c = n ; if i == c { break ; } } } } } } pub trait Ext2 { # [doc = " Transforms the slice in the inverse permutation."] # [doc = " "] # [doc = " # Panics"] # [doc = " "] # [doc = " This function panics if any value in `self` is not in `0..self.len()`."] # [doc = " "] # [doc = " # Example:"] # [doc = " "] # [doc = " ```"] # [doc = " # use superslice::*;"] # [doc = " let mut p = [1, 3, 2, 0];"] # [doc = " p.invert_permutation();"] # [doc = " assert_eq!(p, [3, 0, 2, 1]);"] fn invert_permutation (& mut self) ; } impl Ext2 for [isize] { fn invert_permutation (& mut self) { assert ! (self . len () < isize :: max_value () as usize) ; for i in 0 .. self . len () as isize { let mut c = self [i as usize] ; if c < 0 { self [i as usize] = ! c ; } else if i != c { let mut n = i ; loop { let t = self [c as usize] ; self [c as usize] = ! n ; n = c ; c = t ; if c == i { self [i as usize] = n ; break ; } } } } } } # [cfg (test)] mod tests { use super :: Ext ; # [test] fn lower_bound () { let b : [u32 ; 0] = [] ; assert_eq ! (b . lower_bound (& 0) , 0) ; let b = [1 , 3 , 3 , 5] ; assert_eq ! (b . lower_bound (& 0) , 0) ; assert_eq ! (b . lower_bound (& 1) , 0) ; assert_eq ! (b . lower_bound (& 2) , 1) ; assert_eq ! (b . lower_bound (& 3) , 1) ; assert_eq ! (b . lower_bound (& 4) , 3) ; assert_eq ! (b . lower_bound (& 5) , 3) ; assert_eq ! (b . lower_bound (& 6) , 4) ; } # [test] fn upper_bound () { let b : [u32 ; 0] = [] ; assert_eq ! (b . upper_bound (& 0) , 0) ; let b = [1 , 3 , 3 , 5] ; assert_eq ! (b . upper_bound (& 0) , 0) ; assert_eq ! (b . upper_bound (& 1) , 1) ; assert_eq ! (b . upper_bound (& 2) , 1) ; assert_eq ! (b . upper_bound (& 3) , 3) ; assert_eq ! (b . upper_bound (& 4) , 3) ; assert_eq ! (b . upper_bound (& 5) , 4) ; assert_eq ! (b . upper_bound (& 6) , 4) ; } # [test] fn equal_range () { let b : [u32 ; 0] = [] ; assert_eq ! (b . equal_range (& 0) , 0 .. 0) ; let b = [1 , 3 , 3 , 5] ; assert_eq ! (b . equal_range (& 0) , 0 .. 0) ; assert_eq ! (b . equal_range (& 1) , 0 .. 1) ; assert_eq ! (b . equal_range (& 2) , 1 .. 1) ; assert_eq ! (b . equal_range (& 3) , 1 .. 3) ; assert_eq ! (b . equal_range (& 4) , 3 .. 3) ; assert_eq ! (b . equal_range (& 5) , 3 .. 4) ; assert_eq ! (b . equal_range (& 6) , 4 .. 4) ; } } }